
****************************************
```python
# Technical explanation for the solving algorithm:
# This code implements a Finite Volume Method (FVM) to solve the 1D Euler equations,
# which describe the conservation of mass, momentum, and energy for compressible,
# inviscid fluid flow. The FVM approach ensures conservation by integrating the
# equations over discrete control volumes (cells) and computing fluxes at cell interfaces.
#
# The core of this solver is the HLLC (Harten-Lax-van Leer-Contact) approximate Riemann solver.
# The Euler equations are a system of hyperbolic conservation laws, and discontinuities
# (like shocks and contact discontinuities) can form. A Riemann solver is used at each
# cell interface to determine the numerical flux, which represents the flow of conserved
# quantities between cells.
#
# The HLLC solver is chosen for its balance of accuracy and computational efficiency.
# It approximates the solution to the Riemann problem by assuming a three-wave structure:
# a left-going wave (speed SL), a right-going wave (speed SR), and a contact discontinuity
# (speed S_star) in between. Unlike the simpler HLL solver, HLLC explicitly resolves
# the contact discontinuity, leading to sharper resolution of these features.
#
# The steps involved in the HLLC solver are:
# 1. Convert conserved variables (density, momentum, total energy) to primitive variables
#    (density, velocity, pressure) for both left and right states at an interface.
# 2. Calculate the speed of sound for both states.
# 3. Estimate the left (SL) and right (SR) wave speeds. These are typically chosen as
#    the minimum and maximum characteristic speeds (eigenvalues of the flux Jacobian)
#    from the left and right states.
# 4. Calculate the contact wave speed (S_star) and the pressure in the star region (p_star)
#    using jump conditions across the waves.
# 5. Based on the signs of SL, S_star, and SR, determine which region of the Riemann fan
#    the interface falls into.
# 6. Compute the numerical flux (F_HLLC) using the appropriate state (left, right, or
#    one of the two star states separated by the contact discontinuity).
#
# The time integration is performed using a second-order Runge-Kutta (SSP-RK2) scheme.
# This scheme improves temporal accuracy and stability compared to the first-order
# explicit Euler scheme, which was identified as a potential source of instability.
# SSP-RK2 involves two stages of flux computation and updates, ensuring better preservation
# of solution properties.
#
# Spatial reconstruction is enhanced using a second-order MUSCL (Monotonic Upstream-centered
# Scheme for Conservation Laws) approach with a Minmod slope limiter. This is crucial for
# reducing numerical diffusion and achieving sharper resolution of discontinuities (shocks,
# contact discontinuities, rarefactions) compared to a first-order scheme. The primitive
# variables (rho, u, p) are reconstructed at cell interfaces, which is generally more robust
# than reconstructing conserved variables.
#
# The time step (dt) is determined by the CFL (Courant-Friedrichs-Lewy) condition to ensure
# numerical stability, based on the maximum characteristic speed in the domain.
#
# Boundary conditions are handled using zero-order extrapolation (transmissive) for ghost cells.
# For a second-order spatial scheme (like MUSCL), 2 ghost cells are typically required on each side.
#
# The simulation proceeds by repeatedly:
# 1. Applying boundary conditions to ghost cells.
# 2. Calculating numerical fluxes at all cell interfaces using the HLLC solver, with
#    interface states reconstructed by MUSCL.
# 3. Updating the conserved variables in each cell using the SSP-RK2 time integration formula.
# 4. Enforcing positivity constraints on conserved variables (density and total energy)
#    after each update to maintain physical validity and numerical stability.
# 5. Incrementing time and adjusting the time step.
#
# Finally, the conserved variables are converted back to primitive variables for plotting
# density, velocity, and pressure at the specified final time.

import numpy as np
import matplotlib.pyplot as plt
import scipy # Included as per requirement, though not explicitly used for core solver
import torch # Included as per requirement, though not explicitly used for core solver

# Define constants
GAMMA = 1.4 # Ratio of specific heats for an ideal gas

# Function to convert primitive variables (rho, u, p) to conserved variables (rho, rho*u, rho*E)
# This function is designed to work with scalar inputs or broadcasted NumPy arrays.
def primitive_to_conserved(rho, u, p):
    # rho_u = rho * u
    # rho_E = 0.5 * rho * u**2 + p / (GAMMA - 1)
    rho_u = rho * u
    rho_E = 0.5 * rho * u**2 + p / (GAMMA - 1)
    # Stacking along the last axis to get shape (N, 3) if inputs are (N,)
    return np.stack([rho, rho_u, rho_E], axis=-1)

# Function to convert conserved variables (rho, rho*u, rho*E) to primitive variables (rho, u, p)
# This function is vectorized to handle arrays of conserved states.
def conserved_to_primitive_vectorized(U_arr):
    # U_arr is expected to be of shape (N, 3) where N is the number of states
    rho = U_arr[..., 0]
    rho_u = U_arr[..., 1]
    rho_E = U_arr[..., 2]

    # Optimization: Enforce minimum density for numerical stability.
    # This prevents division by zero or sqrt of negative numbers.
    # This is applied to the conserved variable directly after update, but also here for safety.
    rho = np.maximum(rho, 1e-12) 

    u = rho_u / rho

    # Optimization: Ensure total energy is sufficient to yield positive pressure.
    # This is a critical safeguard against negative pressures and numerical instability.
    # The internal energy component (p / (GAMMA - 1)) must be positive.
    # So, rho_E must be greater than 0.5 * rho * u^2.
    min_rho_E = 0.5 * rho * u**2
    rho_E = np.maximum(rho_E, min_rho_E + 1e-12) # Add a small epsilon to ensure strictly positive internal energy

    # Compute pressure
    p = (GAMMA - 1) * (rho_E - 0.5 * rho * u**2)

    # Optimization: Enforce minimum pressure to prevent unphysical negative pressures.
    p = np.maximum(p, 1e-12) 

    return rho, u, p

# Function to compute the physical flux F for a given conserved state U
# This function is vectorized to handle arrays of conserved states.
def compute_flux_vectorized(U_arr):
    # U_arr is expected to be of shape (N, 3)
    rho, u, p = conserved_to_primitive_vectorized(U_arr)
    
    # F = [rho*u, rho*u^2 + p, (rho*E + p)*u]
    # Note: rho*E is U_arr[..., 2]
    flux_rho = rho * u
    flux_rho_u = rho * u**2 + p
    flux_rho_E = (U_arr[..., 2] + p) * u
    
    # Stacking along the last axis to get shape (N, 3)
    return np.stack([flux_rho, flux_rho_u, flux_rho_E], axis=-1)

# Minmod limiter function for MUSCL reconstruction
# Optimization: This function is vectorized to operate on arrays of slopes.
def minmod(a, b):
    # minmod(a, b) = sign(a) * max(0, min(|a|, b*sign(a)))
    # A common definition: minmod(a, b) = 0.5 * (np.sign(a) + np.sign(b)) * np.minimum(np.abs(a), np.abs(b))
    # This version is robust for general use:
    return np.where(a * b > 0, np.sign(a) * np.minimum(np.abs(a), np.abs(b)), 0.0)

# HLLC Riemann Solver (vectorized version)
def hllc_solver_vectorized(UL_conserved_arr, UR_conserved_arr):
    # UL_conserved_arr and UR_conserved_arr are expected to be of shape (N_interfaces, 3)

    # Convert conserved states to primitive states
    rhoL, uL, pL = conserved_to_primitive_vectorized(UL_conserved_arr)
    rhoR, uR, pR = conserved_to_primitive_vectorized(UR_conserved_arr)

    # Calculate speeds of sound
    cL = np.sqrt(GAMMA * pL / rhoL)
    cR = np.sqrt(GAMMA * pR / rhoR)

    # Estimate wave speeds SL, SR (Toro's 1999, Chapter 10, Eq. 10.30)
    # These are the fastest left-going and right-going characteristic speeds
    SL = np.minimum(uL - cL, uR - cR)
    SR = np.maximum(uL + cL, uR + cR)

    # Calculate S_star (contact wave speed) using Eq. 10.42 from Toro's book
    # This formula is derived from the equality of pressure and velocity across the contact
    # discontinuity in the star region.
    num = pR - pL + rhoL * uL * (SL - uL) - rhoR * uR * (SR - uR)
    den = rhoL * (SL - uL) - rhoR * (SR - uR)
    
    # Optimization: Handle potential division by zero in 'den' for S_star calculation.
    # Replace very small denominators with a small non-zero value to prevent NaN/Inf.
    den = np.where(np.abs(den) < 1e-12, 1e-12, den)
    S_star = num / den

    # Calculate p_star (pressure in star region) using Eq. 10.43 from Toro's book
    # This formula is derived from the jump condition across the left shock/rarefaction wave.
    p_star = pL + rhoL * (SL - uL) * (S_star - uL)
    
    # Optimization: Ensure p_star is non-negative.
    p_star = np.maximum(p_star, 1e-12)

    # Calculate the HLLC flux based on the wave speeds
    FL_arr = compute_flux_vectorized(UL_conserved_arr)
    FR_arr = compute_flux_vectorized(UR_conserved_arr)

    # Calculate star states U_star_L and U_star_R
    # Need to handle division by zero if SL - S_star or SR - S_star is zero
    # For robustness, add a small epsilon to the denominator or use np.where.
    
    # For rho_star_L
    den_L_star = (SL - S_star)
    rho_star_L = rhoL * (SL - uL) / np.where(np.abs(den_L_star) < 1e-12, 1e-12, den_L_star)
    rho_star_L = np.maximum(rho_star_L, 1e-12) # Ensure positive density in star state

    u_star_L = S_star
    # Optimization: Ensure E_star_L calculation is robust against very small rho_star_L
    # by ensuring the internal energy component is positive.
    E_star_L = p_star / ((GAMMA - 1) * rho_star_L) + 0.5 * S_star**2
    E_star_L = np.maximum(E_star_L, 0.5 * S_star**2 + 1e-12) # Ensure total energy is at least kinetic energy
    U_star_L_arr = np.stack([rho_star_L, rho_star_L * u_star_L, rho_star_L * E_star_L], axis=-1)
    
    # For rho_star_R
    den_R_star = (SR - S_star)
    rho_star_R = rhoR * (SR - uR) / np.where(np.abs(den_R_star) < 1e-12, 1e-12, den_R_star)
    rho_star_R = np.maximum(rho_star_R, 1e-12) # Ensure positive density in star state

    u_star_R = S_star
    # Optimization: Ensure E_star_R calculation is robust against very small rho_star_R
    E_star_R = p_star / ((GAMMA - 1) * rho_star_R) + 0.5 * S_star**2
    E_star_R = np.maximum(E_star_R, 0.5 * S_star**2 + 1e-12) # Ensure total energy is at least kinetic energy
    U_star_R_arr = np.stack([rho_star_R, rho_star_R * u_star_R, rho_star_R * E_star_R], axis=-1)

    # Optimization: Compute F_star_L and F_star_R using the jump condition formula.
    # This is more consistent with the HLLC derivation and can be more numerically stable
    # than recomputing fluxes from the star states.
    # F_star = F + S * (U_star - U)
    F_star_L_arr = FL_arr + SL[:, np.newaxis] * (U_star_L_arr - UL_conserved_arr)
    F_star_R_arr = FR_arr + SR[:, np.newaxis] * (U_star_R_arr - UR_conserved_arr)

    # Initialize output flux array with zeros, shape (N_interfaces, 3)
    flux_HLLC = np.zeros_like(FL_arr)

    # Select the appropriate flux based on wave speeds using vectorized conditions (np.where)
    # This replaces the sequential if/elif/else structure with parallel array operations.

    # Region 1: SL >= 0 (all waves to the right, flux is FL)
    mask1 = (SL >= 0)
    flux_HLLC[mask1] = FL_arr[mask1]

    # Region 2: SL < 0 and S_star >= 0 (left wave left, contact/right wave right/stationary, flux is F_star_L)
    mask2 = (SL < 0) & (S_star >= 0)
    flux_HLLC[mask2] = F_star_L_arr[mask2]

    # Region 3: S_star < 0 and SR >= 0 (left wave/contact left, right wave right/stationary, flux is F_star_R)
    mask3 = (S_star < 0) & (SR >= 0)
    flux_HLLC[mask3] = F_star_R_arr[mask3]

    # Region 4: SR < 0 (all waves to the left, flux is FR)
    mask4 = (SR < 0)
    flux_HLLC[mask4] = FR_arr[mask4]
    
    return flux_HLLC

# Function to compute the right-hand side (RHS) of the conservation law (spatial derivative term)
# This function is used by the time integrator.
def compute_rhs(U_current, dx, N_cells, num_ghost_cells):
    # Apply boundary conditions (zero-order extrapolation for ghost cells)
    # Optimization: Boundary conditions are applied here before flux calculation for each stage.
    # Left ghost cells take values from the first computational cell
    U_current[0:num_ghost_cells] = U_current[num_ghost_cells]
    # Right ghost cells take values from the last computational cell
    U_current[N_cells + num_ghost_cells : N_cells + 2 * num_ghost_cells] = U_current[N_cells + num_ghost_cells - 1]

    # Convert all conserved variables to primitive variables for MUSCL reconstruction
    rho_all, u_all, p_all = conserved_to_primitive_vectorized(U_current)
    
    # Optimization: MUSCL reconstruction on primitive variables.
    # This improves accuracy to second order in space and reduces numerical diffusion.
    # We need to compute fluxes for N_cells + 1 interfaces.
    # These interfaces are at indices `num_ghost_cells` to `N_cells + num_ghost_cells` in the padded array.
    # For interface `j` (0 to N_cells), it's between cell `j+1` and `j+2` in the `_recon` arrays below.
    # UL_interface_state (right-reconstructed state of cell j+1): U_L = U[j+1] + 0.5 * minmod(U[j+1] - U[j], U[j+2] - U[j+1])
    # UR_interface_state (left-reconstructed state of cell j+2): U_R = U[j+2] - 0.5 * minmod(U[j+2] - U[j+1], U[j+3] - U[j+2])

    # Extract relevant primitive variables for reconstruction.
    # We need 4 cells for each interface reconstruction (i-1, i, i+1, i+2).
    # For N_cells + 1 interfaces, we need data from `num_ghost_cells-2` to `N_cells + num_ghost_cells + 1`.
    rho_recon = rho_all[num_ghost_cells-2 : N_cells + num_ghost_cells + 2]
    u_recon = u_all[num_ghost_cells-2 : N_cells + num_ghost_cells + 2]
    p_recon = p_all[num_ghost_cells-2 : N_cells + num_ghost_cells + 2]

    # Create arrays to store reconstructed primitive variables at interfaces
    # Shape: (N_cells + 1, 3) for (rho, u, p)
    UL_primitive_interface = np.zeros((N_cells + 1, 3))
    UR_primitive_interface = np.zeros((N_cells + 1, 3))

    # Vectorized MUSCL reconstruction for rho, u, p
    # UL_primitive_interface[:, 0] is rho_L
    UL_primitive_interface[:, 0] = rho_recon[1:-2] + 0.5 * minmod(rho_recon[1:-2] - rho_recon[0:-3], rho_recon[2:-1] - rho_recon[1:-2])
    UR_primitive_interface[:, 0] = rho_recon[2:-1] - 0.5 * minmod(rho_recon[2:-1] - rho_recon[1:-2], rho_recon[3:] - rho_recon[2:-1])
    # UL_primitive_interface[:, 1] is u_L
    UL_primitive_interface[:, 1] = u_recon[1:-2] + 0.5 * minmod(u_recon[1:-2] - u_recon[0:-3], u_recon[2:-1] - u_recon[1:-2])
    UR_primitive_interface[:, 1] = u_recon[2:-1] - 0.5 * minmod(u_recon[2:-1] - u_recon[1:-2], u_recon[3:] - u_recon[2:-1])
    # UL_primitive_interface[:, 2] is p_L
    UL_primitive_interface[:, 2] = p_recon[1:-2] + 0.5 * minmod(p_recon[1:-2] - p_recon[0:-3], p_recon[2:-1] - p_recon[1:-2])
    UR_primitive_interface[:, 2] = p_recon[2:-1] - 0.5 * minmod(p_recon[2:-1] - p_recon[1:-2], p_recon[3:] - p_recon[2:-1])

    # Convert reconstructed primitive states to conserved states for the Riemann solver
    UL_conserved_interface = primitive_to_conserved(UL_primitive_interface[:, 0], UL_primitive_interface[:, 1], UL_primitive_interface[:, 2])
    UR_conserved_interface = primitive_to_conserved(UR_primitive_interface[:, 0], UR_primitive_interface[:, 1], UR_primitive_interface[:, 2])

    # Compute numerical fluxes at all cell interfaces using the HLLC solver
    fluxes = hllc_solver_vectorized(UL_conserved_interface, UR_conserved_interface)

    # Compute the RHS term (F_{i+1/2} - F_{i-1/2}) / dx
    # This is for the computational cells only.
    # The fluxes array has N_cells + 1 fluxes.
    # fluxes[0] is F_{1/2} (leftmost interface of first computational cell)
    # fluxes[N_cells] is F_{N_cells+1/2} (rightmost interface of last computational cell)
    # So, for cell `i` (0 to N_cells-1), the update is `(fluxes[i+1] - fluxes[i])`.
    rhs = -(fluxes[1:] - fluxes[:-1]) / dx
    
    return rhs

# Main simulation function
def solve_euler_equations():
    # Simulation parameters
    x_min, x_max = 0.0, 1.0 # Spatial domain
    t_final = 0.2 # Final simulation time
    N_cells = 200 # Number of computational cells
    CFL = 0.4 # Courant-Friedrichs-Lewy number for stability. Reduced for SSP-RK2 and MUSCL.
    num_ghost_cells = 2 # Number of ghost cells on each side for second-order MUSCL scheme

    # Grid setup
    dx = (x_max - x_min) / N_cells # Cell size
    # Cell centers for plotting. These are the centers of the computational cells.
    x_centers = np.linspace(x_min + 0.5 * dx, x_max - 0.5 * dx, N_cells)
    
    # Initialize conserved variables array U
    # U has shape (N_total_cells, 3) where 3 corresponds to [rho, rho*u, rho*E]
    # Add ghost cells to the total number of cells
    U = np.zeros((N_cells + 2 * num_ghost_cells, 3))

    # Set initial conditions (Sod shock tube problem)
    # Left state: (rho, u, p) = (1.0, 0.0, 1.0) for x <= 0.5
    # Right state: (rho, u, p) = (0.125, 0.0, 0.1) for x > 0.5
    
    # Initialize computational cells (excluding ghost cells)
    # Create arrays for initial primitive variables
    rho_init_arr = np.zeros(N_cells)
    u_init_arr = np.zeros(N_cells)
    p_init_arr = np.zeros(N_cells)

    left_state_mask = x_centers <= 0.5
    right_state_mask = x_centers > 0.5

    rho_init_arr[left_state_mask] = 1.0
    u_init_arr[left_state_mask] = 0.0
    p_init_arr[left_state_mask] = 1.0

    rho_init_arr[right_state_mask] = 0.125
    u_init_arr[right_state_mask] = 0.0
    p_init_arr[right_state_mask] = 0.1
    
    # Convert initial primitive variables to conserved variables in a vectorized manner
    U[num_ghost_cells : N_cells + num_ghost_cells] = primitive_to_conserved(rho_init_arr, u_init_arr, p_init_arr)

    # Time integration loop
    t = 0.0
    iteration = 0
    print("Detailed Result Printing:")
    print("--------------------------------------------------")
    print(f"Simulation Parameters:")
    print(f"  Spatial Domain: [{x_min}, {x_max}]")
    print(f"  Number of Computational Cells: {N_cells}")
    print(f"  Cell Size (dx): {dx:.6f}")
    print(f"  Final Simulation Time (t_final): {t_final}")
    print(f"  CFL Number: {CFL}")
    print(f"  Number of Ghost Cells per side: {num_ghost_cells}")
    print("--------------------------------------------------")
    print("Starting Time Integration Loop (SSP-RK2 with MUSCL)...")

    while t < t_final:
        # Optimization: Calculate dt based on CFL condition at the beginning of each time step.
        # This requires current primitive variables across all cells (including ghost cells for max speed).
        rho_all, u_all, p_all = conserved_to_primitive_vectorized(U)
        c_all = np.sqrt(GAMMA * p_all / rho_all)
        
        # Calculate maximum characteristic speed in the domain for CFL condition
        # Use only computational cells for max speed calculation to avoid boundary effects
        max_char_speed = np.max(np.abs(u_all[num_ghost_cells:-num_ghost_cells]) + c_all[num_ghost_cells:-num_ghost_cells])
        
        # Determine time step dt based on CFL condition
        # Optimization: Added a check for max_char_speed being zero to prevent division by zero.
        # If max_char_speed is very small, dt can become very large, potentially overshooting t_final.
        # If max_char_speed is NaN/Inf, dt will also be NaN/Inf, causing instability.
        if max_char_speed < 1e-12: # If flow is stationary or near-stationary
            dt = t_final - t # Take a large step to finish, or handle as error
            print("Warning: Max characteristic speed near zero. Taking large dt.")
        else:
            dt = CFL * dx / max_char_speed
        
        # Ensure we don't overshoot t_final in the last step
        if t + dt > t_final:
            dt = t_final - t
        
        # Optimization: SSP-RK2 Time Integration
        # Stage 1: Compute U_star
        # U_star = U^n + dt * RHS(U^n)
        # Need a copy of U for U_n to avoid modifying it during RHS calculation for U_star
        U_n = U.copy() 
        
        # Compute RHS for U^n
        rhs_n = compute_rhs(U_n, dx, N_cells, num_ghost_cells)
        
        # Update U_star (only computational cells)
        U_star = U_n.copy() # Start with U^n
        U_star[num_ghost_cells : N_cells + num_ghost_cells] += dt * rhs_n
        
        # Optimization: Enforce positivity on conserved variables after Stage 1 update.
        # This is crucial for stability, preventing unphysical states (negative density or energy).
        U_star[:, 0] = np.maximum(U_star[:, 0], 1e-12) # rho
        U_star[:, 2] = np.maximum(U_star[:, 2], 1e-12) # rho*E (total energy)

        # Stage 2: Compute U^(n+1)
        # U^(n+1) = 0.5 * U^n + 0.5 * (U_star + dt * RHS(U_star))
        
        # Compute RHS for U_star
        rhs_star = compute_rhs(U_star, dx, N_cells, num_ghost_cells)
        
        # Update U^(n+1) (only computational cells)
        U_next = 0.5 * U_n[num_ghost_cells : N_cells + num_ghost_cells] + \
                 0.5 * (U_star[num_ghost_cells : N_cells + num_ghost_cells] + dt * rhs_star)
        
        # Assign U_next back to the computational cells of U
        U[num_ghost_cells : N_cells + num_ghost_cells] = U_next

        # Optimization: Enforce positivity on conserved variables after final update.
        U[:, 0] = np.maximum(U[:, 0], 1e-12) # rho
        U[:, 2] = np.maximum(U[:, 2], 1e-12) # rho*E (total energy)

        t += dt
        iteration += 1

        # Optimization: Add NaN/Inf check to detect numerical instability early.
        # If the solution becomes unstable, print a message and break the loop.
        if np.any(np.isnan(U)) or np.any(np.isinf(U)):
            print(f"Numerical instability detected at iteration {iteration}, time {t:.6f}. Breaking simulation.")
            break

        if iteration % 100 == 0 or t >= t_final:
            print(f"  Time: {t:.6f}/{t_final:.6f}, dt: {dt:.8f}, Iteration: {iteration}, Max Char Speed: {max_char_speed:.4f}")

    print("--------------------------------------------------")
    print(f"Simulation finished at t = {t:.6f} after {iteration} iterations.")
    print("--------------------------------------------------")

    # Extract primitive variables from the final conserved state for plotting
    # Only consider the computational cells
    final_rho, final_u, final_p = conserved_to_primitive_vectorized(U[num_ghost_cells : N_cells + num_ghost_cells])

    # Plotting results
    plt.figure(figsize=(12, 8))

    plt.subplot(3, 1, 1)
    plt.plot(x_centers, final_rho, 'b-')
    plt.title(f'Sod Shock Tube Problem at t = {t_final}')
    plt.ylabel('Density (œÅ)')
    plt.grid(True)

    plt.subplot(3, 1, 2)
    plt.plot(x_centers, final_u, 'r-')
    plt.ylabel('Velocity (u)')
    plt.grid(True)

    plt.subplot(3, 1, 3)
    plt.plot(x_centers, final_p, 'g-')
    plt.ylabel('Pressure (p)')
    plt.xlabel('Position (x)')
    plt.grid(True)

    plt.tight_layout()
    
    # Save the plot without showing it
    plot_filename = 'sod_shock_tube_hllc_ssp_rk2_muscl.png'
    plt.savefig(plot_filename)
    plt.close()
    print(f"Plot saved as {plot_filename}")

# Execute the simulation
if __name__ == "__main__":
    solve_euler_equations()
```
****************************************
