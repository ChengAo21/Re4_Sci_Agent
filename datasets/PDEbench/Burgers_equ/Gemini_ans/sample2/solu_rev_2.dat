
****************************************
```python
# Technical explanation for the solving algorithm
# The 1-D viscous Burgers' equation is a nonlinear partial differential equation:
# u_t + u u_x - nu u_xx = 0
# This equation is solved using the Finite Difference Method (FDM) with an Implicit-Explicit (IMEX) time-stepping scheme.
#
# 1. Spatial Discretization:
#    - The spatial domain [-1, 1] is discretized into a uniform grid of N_x points.
#    - Spatial derivatives are approximated using finite differences.
#
# 2. Time Discretization (IMEX Euler):
#    - The equation is split into a convection term (u u_x) and a diffusion term (nu u_xx).
#    - The convection term is treated explicitly, meaning its value at the current time step (n) is used to advance the solution.
#    - The diffusion term is treated implicitly, meaning its value at the next time step (n+1) is used. This makes the diffusion part unconditionally stable, allowing for larger time steps compared to explicit diffusion.
#    - The semi-discrete form is derived from u_t = -u u_x + nu u_xx:
#      (u^{n+1} - u^n) / dt = - (u u_x)^n + nu (u_xx)^{n+1}
#    - Rearranging for u^{n+1}:
#      u^{n+1} - dt * nu * (u_xx)^{n+1} = u^n - dt * (u u_x)^n
#    - This leads to a linear system of the form A * u^{n+1} = RHS, where A is a tridiagonal matrix.
#    - While the current implementation uses a first-order IMEX Euler scheme, higher-order IMEX Runge-Kutta methods could be employed for improved temporal accuracy, especially for longer simulations.
#
# 3. Discretization of Terms:
#    a. Convection Term (u u_x):
#       - To handle oscillations near steep gradients or discontinuities (shocks), a first-order upwind scheme based on the conservative form (u^2/2)_x is used.
#       - Specifically, the Rusanov (or Local Lax-Friedrichs) numerical flux is employed for the term (u^2/2)_x. This flux is robust and introduces sufficient numerical diffusion to prevent spurious oscillations, making it suitable for shock capturing.
#       - The term u u_x is rewritten as (u^2/2)_x. Let f(u) = u^2/2.
#       - The discrete form for -(u u_x) is -(F_{i+1/2} - F_{i-1/2}) / dx, where F is the numerical flux.
#       - The Rusanov flux F_{i+1/2} is calculated as:
#         F_{i+1/2} = 0.5 * (f(u_i) + f(u_{i+1})) - 0.5 * alpha * (u_{i+1} - u_i)
#         where alpha = max(|f'(u)|) over the interval [u_i, u_{i+1}]. For f(u) = u^2/2, f'(u) = u, so alpha = max(|u_i|, |u_{i+1}|).
#       - This first-order scheme introduces some numerical diffusion, which smooths the solution. For sharper features, higher-order TVD schemes with flux limiters could be considered, but they add complexity.
#
#    b. Diffusion Term (nu u_xx):
#       - A second-order central difference approximation is used: u_xx(i) approx (u_{i+1} - 2u_i + u_{i-1}) / dx^2.
#       - This forms the tridiagonal matrix A for the implicit step.
#
# 4. Boundary Conditions:
#    - Dirichlet boundary conditions u(-1, t) = 0 and u(1, t) = 0 are applied directly by modifying the first and last rows of the implicit matrix A and the corresponding elements of the RHS vector. This ensures that the solution at the boundaries remains zero throughout the simulation.
#
# 5. Solution of Linear System:
#    - At each time step, a tridiagonal linear system A * u^{n+1} = RHS is solved.
#    - Optimization: The matrix A for the implicit diffusion term is constant throughout the simulation (after applying fixed boundary conditions). Therefore, it is constructed and pre-factorized once using `scipy.sparse.linalg.splu` before the time-stepping loop. This pre-factorization significantly speeds up the repeated linear system solves at each time step, as only a forward and backward substitution is needed.
#
# 6. Time Step (dt) Selection:
#    - The time step `dt` is chosen based on the CFL condition for the explicit convection term: dt <= dx / max(|u|). The implicit diffusion term does not impose a strict stability limit on `dt`.
#    - Adaptive time stepping could further optimize performance by adjusting `dt` based on solution smoothness or error estimates.
#
# 7. Code Structure and Optimization:
#    - The code is modularized into a class `BurgersSolver` to improve readability, maintainability, and reusability.
#    - Key operations like explicit convection calculation and implicit matrix setup are encapsulated in methods.
#    - Vectorized NumPy operations are extensively used for efficiency, particularly in the Rusanov flux calculation, avoiding explicit Python loops. This is a key optimization for numerical performance.
#    - The `u_history` array stores the full solution, which is convenient for plotting but can be memory-intensive for very large simulations. For such cases, saving only selected snapshots would be more memory-efficient.
#
# 8. Validation and Further Work:
#    - Numerical accuracy can be verified through grid convergence studies (varying N_x and dt) or by comparing results with known analytical/benchmark solutions for specific cases of the Burgers' equation.
#    - The current setup effectively handles the given problem, including oscillations near discontinuities, due to the robust Rusanov flux.

import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt

class BurgersSolver:
    # Initialize the solver with problem parameters and discretization settings
    def __init__(self, nu, x_min, x_max, t_min, t_max, N_x, CFL_number):
        # Problem parameters
        self.nu = nu
        self.x_min, self.x_max = x_min, x_max
        self.t_min, self.t_max = t_min, t_max

        # Discretization parameters
        self.N_x = N_x
        self.dx = (self.x_max - self.x_min) / (self.N_x - 1)
        self.CFL_number = CFL_number

        # Grid generation
        self.x = np.linspace(self.x_min, self.x_max, self.N_x)

        # Initial condition
        self.u_initial = -np.sin(np.pi * self.x)

        # Determine time step (dt) based on CFL condition
        # CFL condition for explicit convection: dt <= dx / max(|u|)
        # Initial max(|u|) is 1.0
        max_u_val = np.max(np.abs(self.u_initial))
        # Calculate maximum allowed dt based on convection
        # Handle case where max_u_val might be zero (e.g., if initial u is all zeros)
        dt_max_conv = self.dx / max_u_val if max_u_val > 0 else self.dx
        self.dt = self.CFL_number * dt_max_conv

        # Adjust dt to ensure it divides the total time interval evenly, or slightly less
        self.N_t = int(np.ceil((self.t_max - self.t_min) / self.dt))
        self.dt = (self.t_max - self.t_min) / self.N_t  # Recalculate dt to hit t_max exactly

        # Store solution at each time step for contour plot
        # This can be memory-intensive for very large simulations.
        self.u_history = np.zeros((self.N_t + 1, self.N_x))
        self.u_history[0, :] = self.u_initial.copy()
        self.current_u = self.u_initial.copy()

        # Pre-factorize the implicit matrix A
        # This is a significant optimization as A is constant for the implicit part
        self.A_factor = self._setup_implicit_matrix()

        # Print simulation setup details
        self._print_setup_details(max_u_val)

    # Print simulation setup details
    def _print_setup_details(self, initial_max_u_val):
        print("# Simulation Setup:")
        print(f"# Viscosity (nu): {self.nu:.6f}")
        print(f"# Spatial domain: [{self.x_min}, {self.x_max}] with {self.N_x} points")
        print(f"# Spatial step (dx): {self.dx:.4f}")
        print(f"# Time domain: [{self.t_min}, {self.t_max}]")
        print(f"# Initial max(|u|): {initial_max_u_val:.4f}")
        print(f"# Calculated dt based on CFL ({self.CFL_number}): {self.dt:.6f}")
        print(f"# Number of time steps (N_t): {self.N_t}")
        print(f"# Final dt: {self.dt:.6f}")

    # Setup and pre-factorize the implicit matrix A
    # This method is called once during initialization for optimization.
    def _setup_implicit_matrix(self):
        # The implicit part is: u_i_next - dt*nu * (u_xx)_i_next = RHS_i
        # Using central difference for u_xx: (u_{i+1} - 2u_i + u_{i-1}) / dx^2
        # So, for interior points:
        # (-dt*nu/dx^2)u_{i-1}_next + (1 + 2*dt*nu/dx^2)u_i_next + (-dt*nu/dx^2)u_{i+1}_next = RHS_i

        main_diag_val = 1 + 2 * self.nu * self.dt / self.dx**2
        off_diag_val = -self.nu * self.dt / self.dx**2

        # Create arrays for the diagonals
        main_diag_arr = np.full(self.N_x, main_diag_val)
        off_diag_lower_arr = np.full(self.N_x - 1, off_diag_val)
        off_diag_upper_arr = np.full(self.N_x - 1, off_diag_val)

        # Apply Dirichlet boundary conditions to the diagonals of A
        # For u[0] = 0:
        # The first row of A should be [1, 0, ..., 0]
        main_diag_arr[0] = 1.0
        off_diag_upper_arr[0] = 0.0  # This sets A[0,1] to 0

        # For u[N_x-1] = 0:
        # The last row of A should be [0, ..., 0, 1]
        main_diag_arr[self.N_x-1] = 1.0
        off_diag_lower_arr[self.N_x-2] = 0.0  # This sets A[N_x-1, N_x-2] to 0

        # Create the sparse tridiagonal matrix
        diagonals = [off_diag_lower_arr, main_diag_arr, off_diag_upper_arr]
        offsets = [-1, 0, 1]
        A_matrix = sp.diags(diagonals, offsets, shape=(self.N_x, self.N_x), format='csc')

        # Pre-factorize the matrix A for efficient repeated solves
        # This is a significant optimization.
        return spla.splu(A_matrix)

    # Calculate the explicit convection term using Rusanov flux
    # This method is optimized using NumPy vectorization.
    def _compute_explicit_convection(self, u):
        # f(u) = u^2 / 2
        f_u = 0.5 * u**2

        # Vectorized Rusanov flux calculation
        # This avoids explicit Python loops, significantly improving performance.
        u_L = u[:-1]
        u_R = u[1:]
        f_u_L = f_u[:-1]
        f_u_R = f_u[1:]
        # alpha = max(|f'(u)|) = max(|u_L|, |u_R|) for Rusanov flux
        alpha = np.maximum(np.abs(u_L), np.abs(u_R))
        F_flux = 0.5 * (f_u_L + f_u_R) - 0.5 * alpha * (u_R - u_L)

        # Calculate the spatial derivative of the flux for interior points
        # The term is -(F_{i+1/2} - F_{i-1/2}) / dx
        RHS_conv = np.zeros(self.N_x)
        RHS_conv[1:-1] = -(F_flux[1:] - F_flux[:-1]) / self.dx
        return RHS_conv

    # Perform one time step
    def _solve_time_step(self):
        # 1. Calculate the explicit convection term (RHS_conv)
        RHS_conv = self._compute_explicit_convection(self.current_u)

        # 2. Set up the RHS vector for the implicit diffusion system
        # RHS_diffusion_vector = current_u + dt * RHS_conv
        RHS_diffusion_vector = self.current_u + self.dt * RHS_conv

        # Ensure boundary conditions are strictly zero for RHS vector
        # These are Dirichlet BCs, so u_next[0] and u_next[N_x-1] must be 0.
        # The A_matrix is set up such that A[0,0]=1, A[0,j>0]=0 and A[N_x-1,N_x-1]=1, A[N_x-1,j<N_x-1]=0.
        # So, setting RHS_diffusion_vector[0]=0 and RHS_diffusion_vector[N_x-1]=0 directly enforces the BCs.
        RHS_diffusion_vector[0] = 0.0
        RHS_diffusion_vector[self.N_x-1] = 0.0

        # Solve the linear system A * u_next = RHS_diffusion_vector
        # Optimization: Use the pre-factorized matrix A_factor for solving
        u_next = self.A_factor.solve(RHS_diffusion_vector)

        # Update for next time step
        self.current_u = u_next.copy()

    # Run the simulation
    def solve(self):
        for n in range(self.N_t):
            self._solve_time_step()
            self.u_history[n+1, :] = self.current_u

        # Print simulation outcome details
        self._print_outcome_details()

    # Print simulation outcome details
    def _print_outcome_details(self):
        print("\n# Simulation Outcome:")
        print(f"# Max velocity magnitude at t=0: {np.max(np.abs(self.u_history[0, :])):.4f}")
        print(f"# Max velocity magnitude at t=1: {np.max(np.abs(self.u_history[-1, :])):.4f}")
        print(f"# Min velocity at t=1: {np.min(self.u_history[-1, :]):.4f}")
        print(f"# Max velocity at t=1: {np.max(self.u_history[-1, :]):.4f}")

    # Plot the results
    def plot_results(self):
        # Create time array for plotting
        t_values = np.linspace(self.t_min, self.t_max, self.N_t + 1)

        # Figure 1: Contour plot of velocity magnitude u(x,t)
        plt.figure(figsize=(10, 6))
        X_grid, T_grid = np.meshgrid(self.x, t_values)
        plt.contourf(X_grid, T_grid, self.u_history, levels=100, cmap='viridis')
        plt.colorbar(label='Velocity u(x,t)')
        plt.title('Contour Plot of Velocity Magnitude for 1D Burgers Equation')
        plt.xlabel('Spatial Coordinate x')
        plt.ylabel('Time t')
        plt.grid(True, linestyle=':', alpha=0.7)
        plt.tight_layout()
        plt.savefig('burgers_contour.png', dpi=300)  # Save figure
        plt.close() # Close the figure to free memory

        # Figure 2: Velocity profiles at selected time snapshots
        plt.figure(figsize=(10, 6))
        time_snapshots = [0.0, 0.25, 0.5, 0.75, 1.0]
        for t_snap in time_snapshots:
            # Find the closest time step index
            idx = np.argmin(np.abs(t_values - t_snap))
            plt.plot(self.x, self.u_history[idx, :], label=f't = {t_values[idx]:.2f}')

        plt.title('Velocity Profiles at Different Time Snapshots')
        plt.xlabel('Spatial Coordinate x')
        plt.ylabel('Velocity u(x,t)')
        plt.grid(True, linestyle=':', alpha=0.7)
        plt.legend()
        plt.tight_layout()
        plt.savefig('burgers_profiles.png', dpi=300)  # Save figure
        plt.close() # Close the figure to free memory

# Main execution block
if __name__ == "__main__":
    # Problem parameters
    nu = 0.01 / np.pi  # Kinematic viscosity coefficient
    x_min, x_max = -1.0, 1.0  # Spatial domain
    t_min, t_max = 0.0, 1.0  # Time domain

    # Discretization parameters
    N_x = 201  # Number of spatial points (odd number for central point)
    CFL_number = 0.8  # Chosen CFL number for the explicit convection part

    # Create and run the solver
    solver = BurgersSolver(nu, x_min, x_max, t_min, t_max, N_x, CFL_number)
    solver.solve()
    solver.plot_results()
```
****************************************
