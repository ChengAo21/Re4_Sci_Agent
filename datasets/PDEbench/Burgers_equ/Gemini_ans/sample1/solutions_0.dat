
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt

# Technical explanation for the solving algorithm:
# The 1-D viscous Burgers' equation is a nonlinear partial differential equation
# that combines a nonlinear convective term (u u_x) and a linear diffusive term (nu u_xx).
# Due to the nonlinear convection, solutions can develop steep gradients or shock-like
# features, which can lead to numerical oscillations if not handled properly by the scheme.

# This implementation utilizes the Finite Difference Method (FDM) with an explicit
# time-stepping scheme, specifically the Forward Euler method. This approach is chosen
# for its relative simplicity in implementation from scratch while addressing the
# oscillation handling requirement.
#
# 1. Spatial Discretization:
#    - The spatial domain [-1, 1] is discretized into a uniform grid of points.
#    - The second-order spatial derivative (u_xx) for the diffusion term (nu u_xx) is
#      approximated using a standard second-order accurate central difference scheme:
#      u_xx_i approx (u_{i+1} - 2u_i + u_{i-1}) / dx^2
#    - The first-order spatial derivative (u_x) within the nonlinear convective term (u u_x)
#      is approximated using a first-order upwind scheme. This choice is critical for
#      maintaining numerical stability and suppressing spurious oscillations (like the
#      Gibbs phenomenon) that would typically arise from central differences when
#      strong convective transport leads to steep solution gradients. The upwind scheme
#      introduces numerical diffusion, which effectively smooths out sharp features.
#      Specifically, for the term u u_x, the approximation depends on the sign of u_i:
#      - If u_i >= 0 (indicating flow from left to right), the information propagates
#        from the left. Thus, the spatial derivative u_x is approximated by a backward
#        difference: (u_i - u_{i-1}) / dx. The convective term becomes u_i * (u_i - u_{i-1}) / dx.
#      - If u_i < 0 (indicating flow from right to left), the information propagates
#        from the right. Thus, the spatial derivative u_x is approximated by a forward
#        difference: (u_{i+1} - u_i) / dx. The convective term becomes u_i * (u_{i+1} - u_i) / dx.
#
# 2. Time Discretization:
#    - A Forward Euler scheme is employed for time integration, updating the solution
#      from time step 'n' to 'n+1':
#      u_i^{n+1} = u_i^n + dt * RHS_i^n
#      where RHS_i^n = - (u u_x)_i^n + nu * (u_xx)_i^n.
#    - This explicit scheme is conditionally stable. The time step (dt) must satisfy
#      the Courant-Friedrichs-Lewy (CFL) condition, which imposes limits based on both
#      the convective and diffusive terms to ensure numerical stability:
#      dt <= dx / max(|u|) (for the convective part)
#      dt <= 0.5 * dx^2 / nu (for the diffusive part)
#      The smallest of these two limits dictates the maximum stable time step. A safety
#      factor (e.g., 0.9) is typically applied to the calculated dt to ensure robust stability.
#
# 3. Boundary Conditions:
#    - Dirichlet boundary conditions, u(-1, t) = 0 and u(1, t) = 0, are applied directly
#      by fixing the velocity values at the grid boundaries (u[0] and u[Nx-1]) to zero
#      at each time step.
#
# 4. Initial Condition:
#    - The initial velocity profile u(x, 0) = -sin(pi x) is set at the beginning of the
#      simulation (t=0).
#
# The first-order upwind scheme, while introducing numerical diffusion and being only
# first-order accurate in space for the convective term, is a pragmatic and effective
# choice for problems with potential shock formation or steep gradients, as it inherently
# damps oscillations and ensures stability for explicit schemes.

# Problem parameters
nu = 0.01 / np.pi  # Kinematic viscosity coefficient

# Domain parameters
x_min, x_max = -1.0, 1.0  # Spatial domain
t_min, t_max = 0.0, 1.0    # Time domain

# Grid parameters
Nx = 401  # Number of spatial points (including boundaries)
dx = (x_max - x_min) / (Nx - 1)  # Spatial step size

# Calculate stable time step (CFL condition)
# The maximum absolute velocity from the initial condition is 1.0.
# This value is used to estimate the convective CFL limit.
max_u_initial = 1.0
dt_cfl_conv = dx / max_u_initial  # CFL limit due to convection
dt_cfl_diff = 0.5 * dx**2 / nu    # CFL limit due to diffusion
# Choose dt slightly smaller than the minimum of the two CFL limits for safety
dt = min(dt_cfl_conv, dt_cfl_diff) * 0.9

# Determine the number of time steps based on the chosen dt
Nt = int((t_max - t_min) / dt) + 1
# Recalculate dt to ensure it perfectly spans the total time duration
dt = (t_max - t_min) / (Nt - 1)

# Create spatial and temporal grids
x = np.linspace(x_min, x_max, Nx)
t = np.linspace(t_min, t_max, Nt)

# Initialize solution array to store u(x,t) for all x and t
U_solution = np.zeros((Nt, Nx))

# Apply initial condition at t=0
U_solution[0, :] = -np.sin(np.pi * x)

# Prepare the current time step's solution array for iteration
u_n = np.copy(U_solution[0, :])

# Time-stepping loop: Iterate from the first time step (n=0) up to Nt-2
# to compute solutions for n+1 up to Nt-1.
for n in range(Nt - 1):
    # Create a temporary array to store the solution at the next time step (n+1)
    u_np1 = np.zeros_like(u_n)

    # Apply Dirichlet boundary conditions for the next time step
    # u(-1, t) = 0 and u(1, t) = 0
    u_np1[0] = 0.0
    u_np1[Nx - 1] = 0.0

    # Calculate spatial derivatives and update u for interior points (i = 1 to Nx-2)
    # The loop excludes the boundary points as their values are fixed by boundary conditions.
    for i in range(1, Nx - 1):
        # Calculate the diffusion term (nu * u_xx) using a central difference approximation
        diffusion_term = nu * (u_n[i+1] - 2 * u_n[i] + u_n[i-1]) / dx**2

        # Calculate the convection term (u * u_x) using the first-order upwind scheme
        convection_term = 0.0
        if u_n[i] >= 0:
            # If u_i is non-negative, use a backward difference for u_x (upwind from left)
            convection_term = u_n[i] * (u_n[i] - u_n[i-1]) / dx
        else:
            # If u_i is negative, use a forward difference for u_x (upwind from right)
            convection_term = u_n[i] * (u_n[i+1] - u_n[i]) / dx

        # Update u_i using the Forward Euler scheme: u_i^{n+1} = u_i^n + dt * (-convection_term + diffusion_term)
        u_np1[i] = u_n[i] + dt * (-convection_term + diffusion_term)

    # Update u_n to be the newly computed u_np1 for the next iteration
    u_n = np.copy(u_np1)
    # Store the computed solution for the current time step (n+1) in the solution array
    U_solution[n+1, :] = u_np1

# Detailed result printing within the code architecture
print("# Simulation Parameters:")
print(f"  Viscosity (nu): {nu:.4e}")
print(f"  Spatial Domain: [{x_min}, {x_max}]")
print(f"  Time Domain: [{t_min}, {t_max}]")
print(f"  Number of Spatial Points (Nx): {Nx}")
print(f"  Spatial Step Size (dx): {dx:.4e}")
print(f"  Number of Time Steps (Nt): {Nt}")
print(f"  Time Step Size (dt): {dt:.4e}")
print(f"  Total Simulation Time: {t_max - t_min:.2f}")
print(f"  CFL Condition (Convection Limit): {dt_cfl_conv:.4e}")
print(f"  CFL Condition (Diffusion Limit): {dt_cfl_diff:.4e}")
print(f"  Ratio of Chosen dt to Minimum CFL Limit: {dt / min(dt_cfl_conv, dt_cfl_diff):.4f}")
print("\n# Simulation Results Summary:")
print(f"  Maximum absolute velocity observed: {np.max(np.abs(U_solution)):.4f}")
print(f"  Minimum velocity observed: {np.min(U_solution):.4f}")
print(f"  Maximum velocity observed: {np.max(U_solution):.4f}")
print(f"  Final solution shape: {U_solution.shape} (Time points x Spatial points)")

# Plotting results

# Figure 1: Contour plot of velocity magnitude u(x,t)
plt.figure(figsize=(10, 6))
# Create meshgrid for the contour plot from spatial and temporal arrays
X, T = np.meshgrid(x, t)
# Plot filled contours of the velocity field
contour = plt.contourf(X, T, U_solution, levels=100, cmap='viridis')
plt.colorbar(contour, label='Velocity u(x,t)')
plt.title('Contour Plot of Velocity Magnitude for 1D Burgers\' Equation')
plt.xlabel('Spatial Position (x)')
plt.ylabel('Time (t)')
plt.grid(True, linestyle=':', alpha=0.7)
plt.tight_layout()
plt.savefig('burgers_contour.png', dpi=300) # Save the figure to a file
plt.close() # Close the plot to free memory, as plt.show() is not allowed

# Figure 2: Velocity profiles at different time instances
plt.figure(figsize=(10, 6))
# Plot the initial velocity profile at t=0
plt.plot(x, U_solution[0, :], label=f't = {t[0]:.2f} (Initial)', linestyle='--')
# Select a few representative time steps to plot intermediate profiles
# These indices correspond to approximately 25%, 50%, 75%, and 100% of the total simulation time
time_indices_to_plot = [int(Nt * 0.25), int(Nt * 0.5), int(Nt * 0.75), Nt - 1]
for idx in time_indices_to_plot:
    plt.plot(x, U_solution[idx, :], label=f't = {t[idx]:.2f}')

plt.title('Velocity Profiles at Different Time Instances')
plt.xlabel('Spatial Position (x)')
plt.ylabel('Velocity u(x,t)')
plt.legend()
plt.grid(True, linestyle=':', alpha=0.7)
plt.tight_layout()
plt.savefig('burgers_profiles.png', dpi=300) # Save the figure to a file
plt.close() # Close the plot to free memory

print("\n# Plotting Complete:")
print("  'burgers_contour.png' saved (Contour plot of velocity magnitude).")
print("  'burgers_profiles.png' saved (Velocity profiles at different times).")
```
****************************************
