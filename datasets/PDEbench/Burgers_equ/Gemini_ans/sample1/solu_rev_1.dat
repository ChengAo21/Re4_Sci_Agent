
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import solve_banded

# Technical explanation for the solving algorithm:
# The 1-D viscous Burgers' equation is a nonlinear partial differential equation
# that combines a nonlinear convective term (u u_x) and a linear diffusive term (nu u_xx).
# Solutions can develop steep gradients or shock-like features, which require careful
# numerical treatment to avoid oscillations and ensure stability.

# This implementation utilizes a semi-implicit Finite Difference Method (FDM) for time
# integration, which significantly improves numerical stability compared to a fully explicit scheme.
# The approach is as follows:
# 1.  Spatial Discretization:
#     - The spatial domain [-1, 1] is discretized into a uniform grid.
#     - The second-order spatial derivative (u_xx) for the diffusion term (nu u_xx) is
#       approximated using a standard second-order accurate central difference scheme:
#       u_xx_i approx (u_{i+1} - 2u_i + u_{i-1}) / dx^2.
#     - The first-order spatial derivative (u_x) within the nonlinear convective term (u u_x)
#       is approximated using a first-order upwind scheme. This choice is crucial for
#       maintaining numerical stability and suppressing spurious oscillations (like the
#       Gibbs phenomenon) that would typically arise from central differences when
#       strong convective transport leads to steep solution gradients. The upwind scheme
#       introduces numerical diffusion, which effectively smooths out sharp features.
#       Specifically, for the term u u_x, the approximation depends on the sign of u_i:
#       - If u_i >= 0 (indicating flow from left to right), the information propagates
#         from the left. Thus, u_x is approximated by a backward difference: (u_i - u_{i-1}) / dx.
#       - If u_i < 0 (indicating flow from right to left), the information propagates
#         from the right. Thus, u_x is approximated by a forward difference: (u_{i+1} - u_i) / dx.

# 2.  Time Discretization (Semi-Implicit Scheme):
#     - The time integration uses a semi-implicit approach:
#       - The nonlinear convective term (-u u_x) is treated explicitly using the solution
#         from the current time step 'n'.
#       - The linear diffusive term (nu u_xx) is treated implicitly using the Crank-Nicolson
#         method. Crank-Nicolson is second-order accurate in time and unconditionally stable
#         for the linear diffusion equation.
#     - The combined scheme for u_i^{n+1} is derived from:
#       (u_i^{n+1} - u_i^n) / dt = - (u u_x)_i^n + nu * 0.5 * ( (u_xx)_i^{n+1} + (u_xx)_i^n )
#     - Rearranging this equation leads to a tridiagonal system of linear equations for
#       u^{n+1} at each time step:
#       -r u_{i-1}^{n+1} + (1+2r) u_{i}^{n+1} - r u_{i+1}^{n+1} = RHS_i^n
#       where r = (nu * dt) / (2 * dx^2), and RHS_i^n contains terms from u^n and the
#       explicit convection term. This system is efficiently solved using `scipy.linalg.solve_banded`.

# 3.  Stability Considerations:
#     - The explicit treatment of the convection term still imposes a Courant-Friedrichs-Lewy (CFL)
#       condition for stability: dt <= dx / max(|u|). The maximum absolute velocity from the
#       initial condition is used to estimate this limit. A safety factor is applied to ensure
#       robust stability. The implicit treatment of diffusion removes its stability constraint,
#       allowing for larger time steps than a fully explicit scheme.

# 4.  Boundary Conditions:
#     - Dirichlet boundary conditions, u(-1, t) = 0 and u(1, t) = 0, are applied directly
#       by fixing the velocity values at the grid boundaries (u[0] and u[Nx-1]) to zero
#       at each time step. These are incorporated into the tridiagonal system's RHS.

# 5.  Initial Condition:
#     - The initial velocity profile u(x, 0) = -sin(pi x) is set at the beginning of the
#       simulation (t=0).

# The semi-implicit approach with first-order upwind for convection provides a robust and
# oscillation-free solution for problems with potential shock formation or steep gradients,
# balancing stability with reasonable accuracy.

# Problem parameters
nu = 0.01 / np.pi  # Kinematic viscosity coefficient

# Domain parameters
x_min, x_max = -1.0, 1.0  # Spatial domain
t_min, t_max = 0.0, 1.0    # Time domain

# Grid parameters
Nx = 401  # Number of spatial points (including boundaries)
dx = (x_max - x_min) / (Nx - 1)  # Spatial step size

# Calculate stable time step (CFL condition)
# The maximum absolute velocity from the initial condition is 1.0.
# This value is used to estimate the convective CFL limit.
max_u_initial = 1.0 # For u(x,0) = -sin(pi*x), max(|u|) is 1.0
dt_cfl_conv = dx / max_u_initial  # CFL limit due to explicit convection
# With Crank-Nicolson for diffusion, the diffusion CFL limit is removed.
# We use a conservative safety factor for the explicit convection term.
safety_factor = 0.8 # Reduced from 0.9 to be more conservative for nonlinear convection
dt = dt_cfl_conv * safety_factor

# Determine the number of time steps based on the chosen dt
Nt = int((t_max - t_min) / dt) + 1
# Recalculate dt to ensure it perfectly spans the total time duration
dt = (t_max - t_min) / (Nt - 1)

# Create spatial and temporal grids
x = np.linspace(x_min, x_max, Nx)
t = np.linspace(t_min, t_max, Nt)

# Initialize solution array to store u(x,t) for all x and t
U_solution = np.zeros((Nt, Nx))

# Apply initial condition at t=0
U_solution[0, :] = -np.sin(np.pi * x)

# Prepare the current time step's solution array for iteration
u_n = np.copy(U_solution[0, :])

# Precompute constant for Crank-Nicolson diffusion term
r = (nu * dt) / (2 * dx**2)

# Optimized parts explanation:
# 1. Vectorization of Convection Term:
#    Instead of a Python for-loop iterating through each spatial point to calculate
#    the upwind convection term, NumPy's vectorized operations are used. This involves
#    identifying indices where u_n is positive or negative and applying the
#    corresponding upwind difference formula to entire arrays or slices. This
#    significantly reduces computation time by leveraging NumPy's optimized C
#    implementations.
# 2. Semi-Implicit Time Integration (Crank-Nicolson for Diffusion):
#    The previous fully explicit scheme was prone to numerical instability, leading
#    to NaNs and overflows. By treating the diffusion term implicitly with Crank-Nicolson,
#    the stability constraint due to diffusion is removed. This allows for a larger
#    stable time step (dt) primarily limited by the explicit convection term,
#    making the simulation more robust and efficient.
# 3. Tridiagonal System Solver:
#    The implicit part of the scheme results in a tridiagonal system of linear equations.
#    Instead of implementing a custom tridiagonal solver or using a general dense
#    matrix solver (e.g., np.linalg.solve), `scipy.linalg.solve_banded` is used.
#    This function is highly optimized for banded matrices, providing a very fast
#    and memory-efficient solution for the linear system at each time step.
# 4. Precomputation of 'r':
#    The constant 'r' (nu * dt / (2 * dx**2)) is precomputed outside the time loop.
#    This avoids redundant calculations in every iteration, contributing to minor
#    performance improvement.

# Time-stepping loop
for n in range(Nt - 1):
    # Create a temporary array for the next time step's solution
    u_np1 = np.zeros_like(u_n)

    # Apply Dirichlet boundary conditions for the next time step
    # u(-1, t) = 0 and u(1, t) = 0
    u_np1[0] = 0.0
    u_np1[Nx - 1] = 0.0

    # Calculate the explicit convection term for interior points (vectorized)
    # This term is -u * du/dx
    convection_term_explicit = np.zeros(Nx)
    # Indices for interior points (from 1 to Nx-2)
    interior_indices = np.arange(1, Nx - 1)

    # Identify where u_n is positive (use backward difference for u_x)
    positive_u_mask = u_n[interior_indices] >= 0
    positive_u_indices = interior_indices[positive_u_mask]
    convection_term_explicit[positive_u_indices] = \
        u_n[positive_u_indices] * (u_n[positive_u_indices] - u_n[positive_u_indices - 1]) / dx

    # Identify where u_n is negative (use forward difference for u_x)
    negative_u_mask = u_n[interior_indices] < 0
    negative_u_indices = interior_indices[negative_u_mask]
    convection_term_explicit[negative_u_indices] = \
        u_n[negative_u_indices] * (u_n[negative_u_indices + 1] - u_n[negative_u_indices]) / dx

    # Calculate the explicit part of the diffusion term (nu * 0.5 * u_xx^n)
    # This is part of the RHS of the Crank-Nicolson scheme
    diffusion_term_explicit_part = nu * 0.5 * (u_n[2:] - 2 * u_n[1:-1] + u_n[:-2]) / dx**2

    # Construct the Right Hand Side (RHS) vector for the tridiagonal system
    # RHS_i = u_i^n - dt * (convection_term_explicit)_i + dt * (diffusion_term_explicit_part)_i
    # The convection_term_explicit is already -u*u_x, so we add it.
    RHS = u_n[1:-1] - dt * convection_term_explicit[1:-1] + dt * diffusion_term_explicit_part

    # Construct the diagonals for the tridiagonal matrix A
    # The system is for interior points (Nx-2 equations for Nx-2 unknowns)
    # Coefficients: -r (lower), (1+2r) (main), -r (upper)
    # solve_banded expects (lower_bandwidth, upper_bandwidth) and a matrix of diagonals
    # ab[0] = upper diagonal, ab[1] = main diagonal, ab[2] = lower diagonal
    ab = np.zeros((3, Nx - 2))
    ab[0, 1:] = -r  # Upper diagonal (c_i), shifted by 1 for solve_banded format
    ab[1, :] = 1 + 2 * r  # Main diagonal (b_i)
    ab[2, :-1] = -r  # Lower diagonal (a_i), shifted by 1 for solve_banded format

    # Solve the tridiagonal system for the interior points of u_np1
    u_np1[1:-1] = solve_banded((1, 1), ab, RHS)

    # Update u_n to be the newly computed u_np1 for the next iteration
    u_n = np.copy(u_np1)
    # Store the computed solution for the current time step (n+1) in the solution array
    U_solution[n+1, :] = u_np1

# Detailed result printing within the code architecture
print("# Simulation Parameters:")
print(f"  Viscosity (nu): {nu:.4e}")
print(f"  Spatial Domain: [{x_min}, {x_max}]")
print(f"  Time Domain: [{t_min}, {t_max}]")
print(f"  Number of Spatial Points (Nx): {Nx}")
print(f"  Spatial Step Size (dx): {dx:.4e}")
print(f"  Number of Time Steps (Nt): {Nt}")
print(f"  Time Step Size (dt): {dt:.4e}")
print(f"  Total Simulation Time: {t_max - t_min:.2f}")
print(f"  CFL Condition (Convection Limit): {dt_cfl_conv:.4e}")
print(f"  Chosen dt safety factor: {safety_factor:.2f}")
print(f"  Ratio of Chosen dt to Convection CFL Limit: {dt / dt_cfl_conv:.4f}")
print("\n# Simulation Results Summary:")
print(f"  Maximum absolute velocity observed: {np.max(np.abs(U_solution)):.4f}")
print(f"  Minimum velocity observed: {np.min(U_solution):.4f}")
print(f"  Maximum velocity observed: {np.max(U_solution):.4f}")
print(f"  Final solution shape: {U_solution.shape} (Time points x Spatial points)")

# Plotting results

# Figure 1: Contour plot of velocity magnitude u(x,t)
plt.figure(figsize=(10, 6))
# Create meshgrid for the contour plot from spatial and temporal arrays
X, T = np.meshgrid(x, t)
# Plot filled contours of the velocity field
contour = plt.contourf(X, T, U_solution, levels=100, cmap='viridis')
plt.colorbar(contour, label='Velocity u(x,t)')
plt.title('Contour Plot of Velocity Magnitude for 1D Burgers\' Equation')
plt.xlabel('Spatial Position (x)')
plt.ylabel('Time (t)')
plt.grid(True, linestyle=':', alpha=0.7)
plt.tight_layout()
plt.savefig('burgers_contour.png', dpi=300) # Save the figure to a file
plt.close() # Close the plot to free memory, as plt.show() is not allowed

# Figure 2: Velocity profiles at different time instances
plt.figure(figsize=(10, 6))
# Plot the initial velocity profile at t=0
plt.plot(x, U_solution[0, :], label=f't = {t[0]:.2f} (Initial)', linestyle='--')
# Select a few representative time steps to plot intermediate profiles
# These indices correspond to approximately 25%, 50%, 75%, and 100% of the total simulation time
time_indices_to_plot = [int(Nt * 0.25), int(Nt * 0.5), int(Nt * 0.75), Nt - 1]
# Ensure indices are within bounds and unique
time_indices_to_plot = sorted(list(set([idx for idx in time_indices_to_plot if idx < Nt])))
for idx in time_indices_to_plot:
    plt.plot(x, U_solution[idx, :], label=f't = {t[idx]:.2f}')

plt.title('Velocity Profiles at Different Time Instances')
plt.xlabel('Spatial Position (x)')
plt.ylabel('Velocity u(x,t)')
plt.legend()
plt.grid(True, linestyle=':', alpha=0.7)
plt.tight_layout()
plt.savefig('burgers_profiles.png', dpi=300) # Save the figure to a file
plt.close() # Close the plot to free memory

print("\n# Plotting Complete:")
print("  'burgers_contour.png' saved (Contour plot of velocity magnitude).")
print("  'burgers_profiles.png' saved (Velocity profiles at different times).")
```
****************************************
