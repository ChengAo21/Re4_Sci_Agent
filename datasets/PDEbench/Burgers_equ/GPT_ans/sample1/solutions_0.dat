
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import ticker

# Technical explanation:
# We solve the 1-D viscous Burgers' equation:
#   u_t + u u_x = nu u_xx,  x in [-1,1], t in [0,1]
# with initial condition u(x,0) = -sin(pi x) and boundary conditions u(-1,t)=u(1,t)=0.
#
# We choose Plan 1: Finite Difference Method (FDM) with explicit time stepping and a flux limiter
# to handle nonlinear convection and suppress oscillations near steep gradients.
#
# Key points:
# - Spatial domain discretized uniformly.
# - Convection term discretized using a flux-limited scheme (Minmod limiter) to avoid spurious oscillations.
# - Diffusion term discretized with second-order central differences.
# - Forward Euler explicit time stepping.
# - CFL condition enforced for stability.
#
# This approach balances simplicity and robustness, controlling oscillations near shocks.

def minmod(a, b):
    """Minmod flux limiter function."""
    result = np.zeros_like(a)
    mask = (a * b) > 0
    result[mask] = np.where(np.abs(a[mask]) < np.abs(b[mask]), a[mask], b[mask])
    return result

def compute_flux_limited_derivative(u, dx):
    """
    Compute the spatial derivative u_x using a flux-limited scheme (Minmod limiter).
    This is a high-resolution scheme blending first-order upwind and second-order central differences.
    """
    # Number of points
    N = len(u)
    
    # Compute slopes (differences)
    du_forward = np.zeros(N)
    du_backward = np.zeros(N)
    
    du_forward[:-1] = u[1:] - u[:-1]
    du_backward[1:] = u[1:] - u[:-1]
    
    # Compute limited slope (minmod)
    slope = minmod(du_backward, du_forward)
    
    # Reconstruct left and right states at cell interfaces
    # Here we use a MUSCL-type approach for flux limiting
    
    # Flux at interfaces (i+1/2)
    # Upwind direction depends on sign of u at interface
    # We approximate u at interfaces by linear reconstruction with limited slope
    
    # Compute u at interfaces from left and right
    uL = u[:-1] + 0.5 * slope[:-1]
    uR = u[1:] - 0.5 * slope[1:]
    
    # Numerical flux for convection: Godunov flux for scalar conservation law
    # Flux function f(u) = u^2 / 2
    fL = 0.5 * uL**2
    fR = 0.5 * uR**2
    
    # Upwind flux: if average velocity >0 take fL else fR
    u_avg = 0.5 * (u[:-1] + u[1:])
    flux = np.where(u_avg >= 0, fL, fR)
    
    # Compute derivative of flux: (flux_i+1/2 - flux_i-1/2)/dx
    # flux array length = N-1, so derivative length = N-2 interior points
    dudx = np.zeros(N)
    dudx[1:-1] = (flux[1:] - flux[:-1]) / dx
    
    # Boundary points: use one-sided differences (first order upwind)
    # Left boundary flux derivative
    # flux at i=0.5 interface = flux[0]
    # flux at i=-0.5 interface: approximate zero flux (boundary)
    dudx[0] = (flux[0] - 0) / dx
    # Right boundary flux derivative
    # flux at i=N-0.5 interface = flux[-1]
    # flux at i=N+0.5 interface: approximate zero flux (boundary)
    dudx[-1] = (0 - flux[-1]) / dx
    
    return dudx

def burgers_solver():
    # Parameters
    nu = 0.01 / np.pi  # viscosity
    x_start, x_end = -1.0, 1.0
    t_start, t_end = 0.0, 1.0
    
    # Discretization parameters
    Nx = 201  # number of spatial points
    dx = (x_end - x_start) / (Nx - 1)
    x = np.linspace(x_start, x_end, Nx)
    
    # Initial condition
    u0 = -np.sin(np.pi * x)
    
    # Time step based on CFL condition
    # CFL for convection: dt <= dx / max|u|
    # CFL for diffusion: dt <= dx^2 / (2*nu)
    umax = np.max(np.abs(u0))
    dt_conv = dx / umax if umax > 1e-10 else 1e-3
    dt_diff = dx**2 / (2 * nu)
    dt = 0.8 * min(dt_conv, dt_diff)  # safety factor
    
    Nt = int(np.ceil((t_end - t_start) / dt))
    dt = (t_end - t_start) / Nt  # adjust dt to fit exactly
    
    # Initialize solution array
    u = u0.copy()
    
    # Storage for solution snapshots for contour plot
    # Save every n_save steps
    n_save = max(Nt // 100, 1)
    saved_times = []
    saved_solutions = []
    
    # Time integration loop
    for n in range(Nt + 1):
        t = n * dt
        
        # Save solution snapshot
        if n % n_save == 0 or n == Nt:
            saved_times.append(t)
            saved_solutions.append(u.copy())
        
        if n == Nt:
            break
        
        # Compute convection term derivative with flux limiter
        dudx_conv = compute_flux_limited_derivative(u, dx)
        
        # Compute diffusion term derivative (second derivative central difference)
        d2udx2 = np.zeros_like(u)
        d2udx2[1:-1] = (u[2:] - 2 * u[1:-1] + u[:-2]) / dx**2
        
        # Enforce boundary conditions for diffusion term (u=0 at boundaries)
        # d2udx2 at boundaries remains zero (Dirichlet BC)
        
        # Time update (Forward Euler)
        u_new = u - dt * dudx_conv + dt * nu * d2udx2
        
        # Enforce Dirichlet boundary conditions
        u_new[0] = 0.0
        u_new[-1] = 0.0
        
        # Update solution
        u = u_new
    
    # Convert saved solutions to array for plotting
    U = np.array(saved_solutions)  # shape (time_steps, Nx)
    T = np.array(saved_times)
    
    # Plotting results
    
    # 1) Contour plot of velocity u(x,t)
    fig1, ax1 = plt.subplots(figsize=(8, 5))
    X, TT = np.meshgrid(x, T)
    cp = ax1.contourf(X, TT, U, levels=50, cmap='viridis')
    cbar = fig1.colorbar(cp, ax=ax1)
    cbar.set_label('Velocity u(x,t)')
    ax1.set_xlabel('x')
    ax1.set_ylabel('t')
    ax1.set_title('Contour plot of velocity u(x,t) for 1D Burgers equation')
    ax1.xaxis.set_major_locator(ticker.MultipleLocator(0.5))
    ax1.yaxis.set_major_locator(ticker.MultipleLocator(0.2))
    fig1.tight_layout()
    fig1.savefig('burgers_velocity_contour.png', dpi=150)
    plt.close(fig1)
    
    # 2) Velocity profile at final time t=1
    fig2, ax2 = plt.subplots(figsize=(8, 5))
    ax2.plot(x, U[-1, :], 'b-', label=f't = {T[-1]:.3f}')
    ax2.plot(x, u0, 'r--', label='Initial condition')
    ax2.set_xlabel('x')
    ax2.set_ylabel('Velocity u(x,t)')
    ax2.set_title('Velocity profile at final time t=1')
    ax2.legend()
    ax2.grid(True)
    fig2.tight_layout()
    fig2.savefig('burgers_velocity_profile_final.png', dpi=150)
    plt.close(fig2)
    
    # Detailed result printing
    print(f"1D Burgers equation solved on domain x in [{x_start},{x_end}], t in [{t_start},{t_end}]")
    print(f"Spatial points: {Nx}, Time steps: {Nt}, dt: {dt:.5e}, dx: {dx:.5e}")
    print(f"Viscosity nu = {nu:.5e}")
    print(f"Initial max velocity magnitude: {np.max(np.abs(u0)):.5e}")
    print(f"Final max velocity magnitude: {np.max(np.abs(U[-1])):.5e}")
    print(f"Saved {len(T)} solution snapshots for contour plotting.")
    print("Figures saved as 'burgers_velocity_contour.png' and 'burgers_velocity_profile_final.png'.")

if __name__ == "__main__":
    burgers_solver()
```

****************************************
