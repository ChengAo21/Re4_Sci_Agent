
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import ticker
from scipy.sparse import diags
from scipy.sparse.linalg import splu

# Technical explanation:
# We solve the 1-D viscous Burgers equation:
#   u_t + u u_x = nu u_xx,  x in [-1,1], t in [0,1]
# with initial condition u(x,0) = -sin(pi x) and Dirichlet boundary conditions u(-1,t)=u(1,t)=0.
#
# Algorithm:
# - Spatial discretization: uniform grid with Nx points.
# - Convection term discretized using a MUSCL-type flux-limited scheme with Minmod limiter to suppress oscillations near steep gradients.
# - Diffusion term treated implicitly using Crank-Nicolson scheme (theta=0.5) for stability and second-order accuracy.
# - Time integration: IMEX SSP-RK3 scheme:
#   Explicit SSP-RK3 for nonlinear convection term,
#   Implicit Crank-Nicolson for diffusion term solved via sparse LU factorization.
# - Adaptive time stepping based on CFL condition considering both convection and diffusion constraints.
# - LU factorization caching is updated only when dt changes significantly.
# - Nt is dynamically adjusted in a while loop to reach final time exactly.
# - Dirichlet BCs enforced at every stage.
# - Results saved for contour and profile plots.
#
# Optimizations:
# - LU factorization caching with update on dt change.
# - Vectorized flux limiter and flux computations.
# - Dynamic time stepping with exact final time matching.
# - Modular code structure for clarity and maintainability.

def minmod(a, b):
    # Minmod flux limiter function: returns limited slope to prevent spurious oscillations
    result = np.zeros_like(a)
    mask = (a * b) > 0
    result[mask] = np.where(np.abs(a[mask]) < np.abs(b[mask]), a[mask], b[mask])
    return result

def compute_flux_limited_derivative(u, dx):
    # Compute spatial derivative of convection flux f(u) = u^2/2 using MUSCL-type flux limiter (Minmod)
    N = len(u)
    du_forward = np.zeros(N)
    du_backward = np.zeros(N)
    du_forward[:-1] = u[1:] - u[:-1]
    du_backward[1:] = u[1:] - u[:-1]

    slope = minmod(du_backward, du_forward)

    # Reconstruct left and right states at interfaces (i+1/2)
    uL = u[:-1] + 0.5 * slope[:-1]
    uR = u[1:] - 0.5 * slope[1:]

    fL = 0.5 * uL**2
    fR = 0.5 * uR**2

    u_avg = 0.5 * (u[:-1] + u[1:])
    flux = np.where(u_avg >= 0, fL, fR)

    dudx = np.zeros(N)
    # Interior points
    dudx[1:-1] = (flux[1:] - flux[:-1]) / dx

    # Boundary flux derivatives using ghost cells with zero velocity (Dirichlet BC)
    flux_left_ghost = 0.0
    dudx[0] = (flux[0] - flux_left_ghost) / dx
    flux_right_ghost = 0.0
    dudx[-1] = (flux_right_ghost - flux[-1]) / dx

    return dudx

def build_diffusion_matrix(N, dx, nu, dt):
    # Build matrix A for implicit diffusion solve: (I - theta*dt*nu*Dxx), theta=0.5 (Crank-Nicolson)
    theta = 0.5
    r = theta * nu * dt / dx**2

    main_diag = (1 + 2 * r) * np.ones(N)
    off_diag = -r * np.ones(N - 1)

    # Dirichlet BC: enforce u=0 at boundaries by setting rows to identity
    main_diag[0] = 1.0
    main_diag[-1] = 1.0
    off_diag[0] = 0.0
    off_diag[-1] = 0.0

    diagonals = [main_diag, off_diag, off_diag]
    A = diags(diagonals, [0, -1, 1], format='csc')
    return A

def build_diffusion_rhs_matrix(N, dx, nu, dt):
    # Build matrix B for RHS of Crank-Nicolson: (I + (1 - theta)*dt*nu*Dxx)
    theta = 0.5
    r = (1 - theta) * nu * dt / dx**2

    main_diag = (1 - 2 * r) * np.ones(N)
    off_diag = r * np.ones(N - 1)

    # Dirichlet BC: enforce u=0 at boundaries by setting rows to identity
    main_diag[0] = 1.0
    main_diag[-1] = 1.0
    off_diag[0] = 0.0
    off_diag[-1] = 0.0

    diagonals = [main_diag, off_diag, off_diag]
    B = diags(diagonals, [0, -1, 1], format='csc')
    return B

def apply_dirichlet_bc(u):
    # Enforce Dirichlet boundary conditions u(-1,t) = u(1,t) = 0
    u[0] = 0.0
    u[-1] = 0.0

class LinearSolver:
    # Linear solver with LU factorization caching, updated when matrix A changes
    def __init__(self):
        self.lu = None
        self.A_current = None

    def update_matrix(self, A):
        # Update LU factorization if matrix A changed
        if self.A_current is None or not (A != self.A_current).nnz == 0:
            self.lu = splu(A)
            self.A_current = A

    def solve(self, b):
        return self.lu.solve(b)

def ssp_rk3_step(u, dx, nu, dt, A, B, solver):
    # Perform one SSP-RK3 time step for Burgers equation with IMEX treatment:
    # Explicit convection with flux limiter, implicit diffusion with Crank-Nicolson
    # u: current solution vector
    # A, B: sparse matrices for implicit diffusion solve
    # solver: LinearSolver instance with LU factorization

    # Stage 1
    dudx_conv = compute_flux_limited_derivative(u, dx)
    rhs1 = B.dot(u) - dt * dudx_conv
    solver.update_matrix(A)
    u1 = solver.solve(rhs1)
    apply_dirichlet_bc(u1)

    # Stage 2
    dudx_conv = compute_flux_limited_derivative(u1, dx)
    rhs2 = (3/4) * u + (1/4) * (B.dot(u1) - dt * dudx_conv)
    u2 = solver.solve(rhs2)
    apply_dirichlet_bc(u2)

    # Stage 3
    dudx_conv = compute_flux_limited_derivative(u2, dx)
    rhs3 = (1/3) * u + (2/3) * (B.dot(u2) - dt * dudx_conv)
    u_new = solver.solve(rhs3)
    apply_dirichlet_bc(u_new)

    return u_new

def burgers_solver():
    # Parameters
    nu = 0.01 / np.pi  # viscosity
    x_start, x_end = -1.0, 1.0
    t_start, t_end = 0.0, 1.0

    # Discretization parameters
    Nx = 201  # spatial points
    dx = (x_end - x_start) / (Nx - 1)
    x = np.linspace(x_start, x_end, Nx)

    # Initial condition
    u0 = -np.sin(np.pi * x)
    apply_dirichlet_bc(u0)

    # Safety factor for CFL condition
    safety_factor = 0.4

    # Initialize time stepping variables
    t = t_start
    u = u0.copy()

    # Initial dt based on initial max velocity and diffusion constraint
    umax = np.max(np.abs(u))
    dt_conv = dx / umax if umax > 1e-10 else 1e-3
    dt_diff = dx**2 / (2 * nu)
    dt = safety_factor * min(dt_conv, dt_diff)

    # Initialize linear solver instance
    linear_solver = LinearSolver()

    # Build initial diffusion matrices
    A = build_diffusion_matrix(Nx, dx, nu, dt)
    B = build_diffusion_rhs_matrix(Nx, dx, nu, dt)

    # Storage for snapshots for contour plot
    saved_times = [t]
    saved_solutions = [u.copy()]

    # Time integration loop with adaptive dt to reach t_end exactly
    while t < t_end:
        # Adjust dt to not exceed t_end
        if t + dt > t_end:
            dt = t_end - t

        # Rebuild diffusion matrices if dt changed significantly (>10%)
        # This avoids unnecessary LU refactorization
        if abs(dt - (A.diagonal()[0] - 1) * dx**2 / (nu * 0.5)) / dt > 0.1:
            A = build_diffusion_matrix(Nx, dx, nu, dt)
            B = build_diffusion_rhs_matrix(Nx, dx, nu, dt)

        # Perform one SSP-RK3 step with IMEX diffusion
        u_new = ssp_rk3_step(u, dx, nu, dt, A, B, linear_solver)

        # Update time and solution
        t += dt
        u = u_new

        # Save snapshots approximately every 0.004 units of time (~250 snapshots total)
        if len(saved_times) == 1 or (t - saved_times[-1]) >= 0.004 or np.isclose(t, t_end):
            saved_times.append(t)
            saved_solutions.append(u.copy())

        # Adaptive time step update based on current max velocity and diffusion
        umax = np.max(np.abs(u))
        dt_conv = dx / umax if umax > 1e-10 else 1e-3
        dt_diff = dx**2 / (2 * nu)
        dt_new = safety_factor * min(dt_conv, dt_diff)

        # Limit dt change to max 20% per step for stability
        max_change = 0.2
        if dt_new > dt * (1 + max_change):
            dt = dt * (1 + max_change)
        elif dt_new < dt * (1 - max_change):
            dt = dt * (1 - max_change)
        else:
            dt = dt_new

        # Check for numerical instability
        if np.any(np.isnan(u)) or np.any(np.isinf(u)):
            print(f"Numerical instability detected at time t={t:.5f}")
            break

    # Convert saved solutions to array for plotting
    U = np.array(saved_solutions)  # shape (time_steps, Nx)
    T = np.array(saved_times)

    # Plotting results

    # 1) Contour plot of velocity u(x,t)
    fig1, ax1 = plt.subplots(figsize=(8, 5))
    X, TT = np.meshgrid(x, T)
    cp = ax1.contourf(X, TT, U, levels=50, cmap='viridis')
    cbar = fig1.colorbar(cp, ax=ax1)
    cbar.set_label('Velocity u(x,t)')
    ax1.set_xlabel('x')
    ax1.set_ylabel('t')
    ax1.set_title('Contour plot of velocity u(x,t) for 1D Burgers equation')
    ax1.xaxis.set_major_locator(ticker.MultipleLocator(0.5))
    ax1.yaxis.set_major_locator(ticker.MultipleLocator(0.2))
    fig1.tight_layout()
    fig1.savefig('burgers_velocity_contour.png', dpi=150)
    plt.close(fig1)

    # 2) Velocity profile at final time t=1
    fig2, ax2 = plt.subplots(figsize=(8, 5))
    ax2.plot(x, U[-1, :], 'b-', label=f't = {T[-1]:.3f}')
    ax2.plot(x, u0, 'r--', label='Initial condition')
    ax2.set_xlabel('x')
    ax2.set_ylabel('Velocity u(x,t)')
    ax2.set_title('Velocity profile at final time t=1')
    ax2.legend()
    ax2.grid(True)
    fig2.tight_layout()
    fig2.savefig('burgers_velocity_profile_final.png', dpi=150)
    plt.close(fig2)

    # Detailed result printing
    print(f"1D Burgers equation solved on domain x in [{x_start},{x_end}], t in [{t_start},{t_end}]")
    print(f"Spatial points: {Nx}")
    print(f"Final time reached: {t:.5f}")
    print(f"Final time step size dt: {dt:.5e}")
    print(f"Spatial step size dx: {dx:.5e}")
    print(f"Viscosity nu = {nu:.5e}")
    print(f"Initial max velocity magnitude: {np.max(np.abs(u0)):.5e}")
    print(f"Final max velocity magnitude: {np.max(np.abs(U[-1])):.5e}")
    print(f"Saved {len(T)} solution snapshots for contour plotting.")
    print("Figures saved as 'burgers_velocity_contour.png' and 'burgers_velocity_profile_final.png'.")

if __name__ == "__main__":
    burgers_solver()
```

****************************************
