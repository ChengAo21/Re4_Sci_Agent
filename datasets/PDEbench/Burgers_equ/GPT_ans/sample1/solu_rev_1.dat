
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import ticker

# Technical explanation:
# We solve the 1-D viscous Burgers equation:
#   u_t + u u_x = nu u_xx,  x in [-1,1], t in [0,1]
# with initial condition u(x,0) = -sin(pi x) and Dirichlet boundary conditions u(-1,t)=u(1,t)=0.
#
# Algorithm:
# - Spatial discretization: uniform grid with Nx points.
# - Convection term discretized using a flux-limited scheme with Minmod limiter to suppress oscillations near steep gradients.
# - Diffusion term treated implicitly using Crank-Nicolson scheme (semi-implicit IMEX approach) to improve stability and allow larger time steps.
# - Time integration: SSP-RK3 (Strong Stability Preserving Runge-Kutta 3rd order) for the convection term explicitly,
#   combined with implicit solve for diffusion term at each RK stage.
# - Adaptive time stepping based on CFL condition evaluated at each time step to ensure stability.
#
# This approach balances accuracy, stability, and oscillation control for nonlinear convection-diffusion PDEs.

def minmod(a, b):
    # Minmod flux limiter function: returns limited slope to prevent spurious oscillations
    result = np.zeros_like(a)
    mask = (a * b) > 0
    result[mask] = np.where(np.abs(a[mask]) < np.abs(b[mask]), a[mask], b[mask])
    return result

def compute_flux_limited_derivative(u, dx):
    # Compute spatial derivative of convection flux f(u) = u^2/2 using MUSCL-type flux limiter (Minmod)
    N = len(u)
    # Compute forward and backward differences for slopes
    du_forward = np.zeros(N)
    du_backward = np.zeros(N)
    du_forward[:-1] = u[1:] - u[:-1]
    du_backward[1:] = u[1:] - u[:-1]

    # Limited slope
    slope = minmod(du_backward, du_forward)

    # Reconstruct left and right states at interfaces (i+1/2)
    # For interfaces 0.5 to N-1.5 (total N-1 interfaces)
    uL = u[:-1] + 0.5 * slope[:-1]
    uR = u[1:] - 0.5 * slope[1:]

    # Compute fluxes at interfaces
    fL = 0.5 * uL**2
    fR = 0.5 * uR**2

    # Upwind flux selection based on average velocity at interface
    u_avg = 0.5 * (u[:-1] + u[1:])
    flux = np.where(u_avg >= 0, fL, fR)

    # Compute flux derivative (convection term) at cell centers
    dudx = np.zeros(N)
    # Interior points: difference of fluxes divided by dx
    dudx[1:-1] = (flux[1:] - flux[:-1]) / dx

    # Boundary fluxes: enforce Dirichlet BC by zero velocity outside domain
    # Left boundary flux derivative (i=0)
    # Approximate flux at i-0.5 interface as zero (ghost cell u=0)
    flux_left_ghost = 0.0
    dudx[0] = (flux[0] - flux_left_ghost) / dx
    # Right boundary flux derivative (i=N-1)
    flux_right_ghost = 0.0
    dudx[-1] = (flux_right_ghost - flux[-1]) / dx

    return dudx

def build_diffusion_matrix(N, dx, nu, dt):
    # Build the tridiagonal matrix for implicit diffusion solve using Crank-Nicolson scheme
    # Matrix A corresponds to (I - theta * dt * nu * Dxx), theta=0.5 for Crank-Nicolson
    # Dxx is the second derivative operator with Dirichlet BCs
    from scipy.sparse import diags

    theta = 0.5
    r = theta * nu * dt / dx**2

    main_diag = (1 + 2 * r) * np.ones(N)
    off_diag = -r * np.ones(N - 1)

    # Dirichlet BC: first and last rows correspond to boundary points fixed to zero velocity
    main_diag[0] = 1.0
    main_diag[-1] = 1.0
    off_diag[0] = 0.0
    off_diag[-1] = 0.0

    diagonals = [main_diag, off_diag, off_diag]
    A = diags(diagonals, [0, -1, 1], format='csc')

    return A

def build_diffusion_rhs_matrix(N, dx, nu, dt):
    # Build matrix B for RHS of Crank-Nicolson: (I + (1 - theta) * dt * nu * Dxx)
    from scipy.sparse import diags

    theta = 0.5
    r = (1 - theta) * nu * dt / dx**2

    main_diag = (1 - 2 * r) * np.ones(N)
    off_diag = r * np.ones(N - 1)

    # Dirichlet BC: first and last rows correspond to boundary points fixed to zero velocity
    main_diag[0] = 1.0
    main_diag[-1] = 1.0
    off_diag[0] = 0.0
    off_diag[-1] = 0.0

    diagonals = [main_diag, off_diag, off_diag]
    B = diags(diagonals, [0, -1, 1], format='csc')

    return B

def apply_dirichlet_bc(u):
    # Enforce Dirichlet boundary conditions u(-1,t) = u(1,t) = 0
    u[0] = 0.0
    u[-1] = 0.0

def ssp_rk3_step(u, dx, nu, dt, A, B, solver):
    # Perform one SSP-RK3 time step for Burgers equation with IMEX treatment:
    # Explicit convection with flux limiter, implicit diffusion with Crank-Nicolson
    # u: current solution vector
    # A, B: sparse matrices for implicit diffusion solve
    # solver: linear solver function for A x = b

    # Stage 1
    dudx_conv = compute_flux_limited_derivative(u, dx)
    rhs1 = B.dot(u) - dt * dudx_conv
    u1 = solver(A, rhs1)
    apply_dirichlet_bc(u1)

    # Stage 2
    dudx_conv = compute_flux_limited_derivative(u1, dx)
    rhs2 = (3/4) * u + (1/4) * (B.dot(u1) - dt * dudx_conv)
    u2 = solver(A, rhs2)
    apply_dirichlet_bc(u2)

    # Stage 3
    dudx_conv = compute_flux_limited_derivative(u2, dx)
    rhs3 = (1/3) * u + (2/3) * (B.dot(u2) - dt * dudx_conv)
    u_new = solver(A, rhs3)
    apply_dirichlet_bc(u_new)

    return u_new

def linear_solver(A, b):
    # Solve sparse linear system A x = b efficiently
    from scipy.sparse.linalg import splu
    # LU factorization cached for repeated solves
    if not hasattr(linear_solver, "lu"):
        linear_solver.lu = splu(A)
    return linear_solver.lu.solve(b)

def burgers_solver():
    # Parameters
    nu = 0.01 / np.pi  # viscosity
    x_start, x_end = -1.0, 1.0
    t_start, t_end = 0.0, 1.0

    # Discretization parameters
    Nx = 201  # spatial points
    dx = (x_end - x_start) / (Nx - 1)
    x = np.linspace(x_start, x_end, Nx)

    # Initial condition
    u0 = -np.sin(np.pi * x)
    apply_dirichlet_bc(u0)

    # Initial time step guess (will be adapted)
    safety_factor = 0.4  # smaller safety factor for stability
    umax = np.max(np.abs(u0))
    dt_conv = dx / umax if umax > 1e-10 else 1e-3
    dt_diff = dx**2 / (2 * nu)
    dt = safety_factor * min(dt_conv, dt_diff)

    # Time stepping parameters
    Nt = int(np.ceil((t_end - t_start) / dt))
    dt = (t_end - t_start) / Nt  # adjust dt to fit exactly

    # Pre-build diffusion matrices for implicit solve (will be rebuilt if dt changes)
    A = build_diffusion_matrix(Nx, dx, nu, dt)
    B = build_diffusion_rhs_matrix(Nx, dx, nu, dt)

    # Initialize solution
    u = u0.copy()

    # Storage for snapshots for contour plot
    n_save = max(Nt // 100, 1)
    saved_times = []
    saved_solutions = []

    # Time integration loop with adaptive dt based on CFL condition
    for n in range(Nt + 1):
        t = n * dt

        # Save solution snapshot
        if n % n_save == 0 or n == Nt:
            saved_times.append(t)
            saved_solutions.append(u.copy())

        if n == Nt:
            break

        # Adaptive time step based on current max velocity
        umax = np.max(np.abs(u))
        dt_conv = dx / umax if umax > 1e-10 else 1e-3
        dt_diff = dx**2 / (2 * nu)
        dt_new = safety_factor * min(dt_conv, dt_diff)

        # If dt changes significantly, rebuild matrices and update Nt accordingly
        if abs(dt_new - dt) / dt > 0.1:
            dt = dt_new
            A = build_diffusion_matrix(Nx, dx, nu, dt)
            B = build_diffusion_rhs_matrix(Nx, dx, nu, dt)
            # Note: Nt fixed for simplicity; in practice, could adjust Nt and time grid

        # Perform one SSP-RK3 step with IMEX diffusion
        u = ssp_rk3_step(u, dx, nu, dt, A, B, linear_solver)

        # Check for NaNs or Infs to stop early if instability occurs
        if np.any(np.isnan(u)) or np.any(np.isinf(u)):
            print(f"Numerical instability detected at time step {n}, t={t:.5f}")
            break

    # Convert saved solutions to array for plotting
    U = np.array(saved_solutions)  # shape (time_steps, Nx)
    T = np.array(saved_times)

    # Plotting results

    # 1) Contour plot of velocity u(x,t)
    fig1, ax1 = plt.subplots(figsize=(8, 5))
    X, TT = np.meshgrid(x, T)
    cp = ax1.contourf(X, TT, U, levels=50, cmap='viridis')
    cbar = fig1.colorbar(cp, ax=ax1)
    cbar.set_label('Velocity u(x,t)')
    ax1.set_xlabel('x')
    ax1.set_ylabel('t')
    ax1.set_title('Contour plot of velocity u(x,t) for 1D Burgers equation')
    ax1.xaxis.set_major_locator(ticker.MultipleLocator(0.5))
    ax1.yaxis.set_major_locator(ticker.MultipleLocator(0.2))
    fig1.tight_layout()
    fig1.savefig('burgers_velocity_contour.png', dpi=150)
    plt.close(fig1)

    # 2) Velocity profile at final time t=1
    fig2, ax2 = plt.subplots(figsize=(8, 5))
    ax2.plot(x, U[-1, :], 'b-', label=f't = {T[-1]:.3f}')
    ax2.plot(x, u0, 'r--', label='Initial condition')
    ax2.set_xlabel('x')
    ax2.set_ylabel('Velocity u(x,t)')
    ax2.set_title('Velocity profile at final time t=1')
    ax2.legend()
    ax2.grid(True)
    fig2.tight_layout()
    fig2.savefig('burgers_velocity_profile_final.png', dpi=150)
    plt.close(fig2)

    # Detailed result printing
    print(f"1D Burgers equation solved on domain x in [{x_start},{x_end}], t in [{t_start},{t_end}]")
    print(f"Spatial points: {Nx}, Time steps: {Nt}, dt: {dt:.5e}, dx: {dx:.5e}")
    print(f"Viscosity nu = {nu:.5e}")
    print(f"Initial max velocity magnitude: {np.max(np.abs(u0)):.5e}")
    print(f"Final max velocity magnitude: {np.max(np.abs(U[-1])):.5e}")
    print(f"Saved {len(T)} solution snapshots for contour plotting.")
    print("Figures saved as 'burgers_velocity_contour.png' and 'burgers_velocity_profile_final.png'.")

if __name__ == "__main__":
    burgers_solver()
```

****************************************
