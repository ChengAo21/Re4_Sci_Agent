
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

# Technical explanation:
# We solve the 1-D viscous Burgers' equation:
#    u_t + u u_x = nu u_xx
# on the domain x in [-1,1], t in [0,1], with initial condition u(x,0) = -sin(pi x)
# and Dirichlet boundary conditions u(-1,t) = u(1,t) = 0.
#
# Numerical method:
# - Time discretization: IMEX Crank-Nicolson scheme
#   * Diffusion term treated implicitly with Crank-Nicolson (second-order, unconditionally stable)
#   * Nonlinear convection term treated explicitly at previous time step
# - Spatial discretization:
#   * Diffusion term: second-order central differences
#   * Convection term: first-order upwind scheme with vectorized implementation to reduce oscillations near steep gradients
#
# This approach balances stability, accuracy, and computational efficiency.
# The implicit diffusion treatment allows larger time steps without oscillations,
# and the upwind convection discretization controls spurious oscillations near sharp gradients.

# ---------------------------
# Parameters and domain setup
nu = 0.01 / np.pi  # viscosity
x_start, x_end = -1.0, 1.0
t_start, t_end = 0.0, 1.0

Nx = 201  # number of spatial points including boundaries
x = np.linspace(x_start, x_end, Nx)
dx = x[1] - x[0]

# Initial velocity magnitude estimate for CFL condition
max_u_init = 1.0  # max initial velocity magnitude ~1 from initial condition

# CFL condition for convection (explicit upwind)
dt_cfl = 0.8 * dx / max_u_init

# Initial number of time steps and time step size
Nt = 5000
dt = (t_end - t_start) / Nt

# Adjust dt and Nt to satisfy CFL condition explicitly
if dt > dt_cfl:
    dt = dt_cfl
    Nt = int(np.ceil((t_end - t_start) / dt))
    dt = (t_end - t_start) / Nt  # adjust dt exactly

# ---------------------------
# Initial condition: u(x,0) = -sin(pi x)
u = -np.sin(np.pi * x)

# Enforce Dirichlet BCs at initial time
u[0] = 0.0
u[-1] = 0.0

# ---------------------------
# Precompute coefficients for Crank-Nicolson diffusion implicit matrix
r = nu * dt / dx**2

# Construct sparse matrix A for second derivative with Dirichlet BCs
# Interior points: i=1,...,Nx-2
diagonals = [
    np.ones(Nx - 3),        # lower diagonal
    -2 * np.ones(Nx - 2),   # main diagonal
    np.ones(Nx - 3)         # upper diagonal
]
offsets = [-1, 0, 1]
A = diags(diagonals, offsets, shape=(Nx - 2, Nx - 2), format='csc')

# Left matrix: (I - r/2 * A)
LHS = diags([np.ones(Nx - 2)], [0], shape=(Nx - 2, Nx - 2), format='csc') - (r / 2) * A

# Right matrix: (I + r/2 * A)
RHS_mat = diags([np.ones(Nx - 2)], [0], shape=(Nx - 2, Nx - 2), format='csc') + (r / 2) * A

# ---------------------------
# Vectorized function to compute u_x at interior points using first-order upwind scheme
def compute_ux_upwind(u, dx):
    ux = np.zeros_like(u)
    # Boolean arrays for positive and negative velocities at interior points
    pos = u >= 0
    neg = ~pos

    # Interior points indices
    interior = slice(1, -1)

    # For positive velocity: backward difference
    ux[interior][pos[interior]] = (u[interior][pos[interior]] - u[np.array(range(len(u)))[interior][pos[interior]] - 1]) / dx
    # For negative velocity: forward difference
    ux[interior][neg[interior]] = (u[np.array(range(len(u)))[interior][neg[interior]] + 1] - u[interior][neg[interior]]) / dx

    # Boundary points: one-sided differences consistent with BCs
    ux[0] = (u[1] - u[0]) / dx  # forward difference at left boundary
    ux[-1] = (u[-1] - u[-2]) / dx  # backward difference at right boundary

    return ux

# ---------------------------
# Prepare storage for solution at all time steps
u_all = np.zeros((Nt + 1, Nx))
u_all[0, :] = u.copy()

# Store snapshots every N_snap steps for plotting
N_snap = Nt // 10
snapshots = []
time_snapshots = []

# ---------------------------
# Time-stepping loop
for n in range(Nt):
    # Compute convection term u * u_x at time n using vectorized upwind derivative
    ux = compute_ux_upwind(u, dx)
    conv_term = u * ux  # nonlinear convection term at time n (explicit)

    # Right hand side vector for interior points
    b = RHS_mat.dot(u[1:-1]) - dt * conv_term[1:-1]

    # Boundary conditions are zero Dirichlet, so no boundary terms added to b

    # Solve linear system for u^{n+1} interior points
    u_interior = spsolve(LHS, b)

    # Update solution vector
    u[1:-1] = u_interior

    # Enforce Dirichlet BCs
    u[0] = 0.0
    u[-1] = 0.0

    # Store solution
    u_all[n + 1, :] = u.copy()

    # Store snapshots for plotting
    if (n + 1) % N_snap == 0 or n == Nt - 1:
        snapshots.append(u.copy())
        time_snapshots.append(t_start + (n + 1) * dt)

# Convert snapshots to numpy array for plotting
snapshots = np.array(snapshots)
time_snapshots = np.array(time_snapshots)

# ---------------------------
# Plot 1: Contour plot of velocity u(x,t)
plt.figure(figsize=(8, 6))
X, T = np.meshgrid(x, np.linspace(t_start, t_end, Nt + 1))
cp = plt.contourf(X, T, u_all, levels=50, cmap='jet')
plt.colorbar(cp, label='Velocity u(x,t)')
plt.xlabel('x')
plt.ylabel('t')
plt.title('Contour plot of velocity u(x,t) for 1D Burgers equation')
plt.tight_layout()
plt.savefig('burgers_velocity_contour.png')
plt.close()

# ---------------------------
# Plot 2: Velocity profiles at selected time snapshots
plt.figure(figsize=(8, 6))
for i, t_snap in enumerate(time_snapshots):
    plt.plot(x, snapshots[i], label=f't={t_snap:.3f}')
plt.xlabel('x')
plt.ylabel('Velocity u(x,t)')
plt.title('Velocity profiles at selected times')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig('burgers_velocity_profiles.png')
plt.close()

# ---------------------------
# Detailed result printing within code architecture
print("1D Burgers equation solved with IMEX Crank-Nicolson scheme and vectorized upwind convection discretization.")
print(f"Domain: x in [{x_start}, {x_end}], t in [{t_start}, {t_end}]")
print(f"Spatial points: {Nx}, Time steps: {Nt}, dt: {dt:.5e}, dx: {dx:.5e}")
print(f"Viscosity nu = {nu:.5e}")
print(f"Stored {len(time_snapshots)} solution snapshots for plotting.")
print("Figures saved as 'burgers_velocity_contour.png' and 'burgers_velocity_profiles.png'.")

# ---------------------------
# Explanation of optimizations and refinements:
# - Vectorized the upwind convection derivative computation to eliminate explicit Python loops,
#   significantly improving computational efficiency for large spatial grids.
# - Preallocated arrays outside the time loop to reduce memory overhead.
# - Maintained the IMEX Crank-Nicolson scheme for stable and accurate time integration.
# - Kept first-order upwind scheme for convection to control oscillations near steep gradients,
#   balancing stability and numerical diffusion.
# - Stored solution snapshots at regular intervals to manage memory usage and enable effective visualization.
# - Added detailed print statements summarizing simulation parameters and results for reproducibility.
```
****************************************
