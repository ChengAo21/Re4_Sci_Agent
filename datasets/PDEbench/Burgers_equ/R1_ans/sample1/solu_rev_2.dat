
****************************************
To address the numerical instability and NaN issues in the Burgers' equation solver, I've implemented significant improvements based on the teacher's feedback. The key enhancements include:

1. **Upwind scheme for convection term** - Replaces central differences to handle nonlinear steepening
2. **Reduced time step** - Doubles temporal resolution for stability (CFL from 0.12 → 0.06)
3. **Robust boundary handling** - Explicit zeroing of convection term at boundaries
4. **Runtime monitoring** - Added NaN detection and solution validation
5. **Vectorized operations** - Optimized upwind derivative computation

Here's the refined implementation:

```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as splinalg
import matplotlib.pyplot as plt

# ==============================================================================
# Parameters and Discretization
# ==============================================================================
nu = 0.01 / np.pi        # Viscosity coefficient
x_min, x_max = -1, 1     # Spatial domain
t_min, t_max = 0, 1      # Temporal domain
Nx = 256                 # Spatial grid points
Nt = 2048                # Increased temporal resolution (1024 → 2048)

# Discretization
x = np.linspace(x_min, x_max, Nx)
t = np.linspace(t_min, t_max, Nt)
dx = x[1] - x[0]
dt = t[1] - t[0]

# CFL stability check with safety factor
max_u0 = np.max(np.abs(-np.sin(np.pi * x)))
cfl = max_u0 * dt / dx
print(f"CFL number: {cfl:.6f} (Target < 0.5)")
if cfl > 0.5:
    print("Warning: CFL > 0.5 - consider further reducing dt")

# ==============================================================================
# Initial Condition
# ==============================================================================
u0 = -np.sin(np.pi * x)  # Initial velocity profile

# ==============================================================================
# Construct Diffusion Operator (Sparse Matrix)
# ==============================================================================
# Second derivative operator (central difference)
main_diag = -2 * np.ones(Nx) / dx**2
off_diag = np.ones(Nx-1) / dx**2
D2 = sp.diags([off_diag, main_diag, off_diag], [-1, 0, 1], format='lil')

# Apply Dirichlet BCs: u(-1)=0, u(1)=0
D2[0, :] = 0; D2[0, 0] = 1
D2[-1, :] = 0; D2[-1, -1] = 1
D2 = D2.tocsc()  # Convert to efficient format

# ==============================================================================
# Implicit System Matrix (Crank-Nicolson)
# ==============================================================================
I = sp.eye(Nx, format='lil')
A = I - (dt * nu / 2) * D2

# Apply BCs to system matrix
A[0, :] = 0; A[0, 0] = 1
A[-1, :] = 0; A[-1, -1] = 1
A = A.tocsc()

# ==============================================================================
# Upwind Derivative Function (Convection Term)
# ==============================================================================
def upwind_derivative(u, dx):
    """Computes upwind derivative with boundary handling"""
    du = np.zeros_like(u)
    # Interior points (vectorized)
    positive_u = u[1:-1] >= 0
    du[1:-1] = np.where(
        positive_u,
        (u[1:-1] - u[:-2]) / dx,  # Backward difference for u≥0
        (u[2:] - u[1:-1]) / dx     # Forward difference for u<0
    )
    # Boundary terms explicitly zeroed (since u=0 at boundaries)
    du[0] = 0
    du[-1] = 0
    return du

# ==============================================================================
# Time Integration (Semi-Implicit Scheme)
# ==============================================================================
u_solution = np.zeros((Nt, Nx))
u_solution[0, :] = u0
valid_steps = Nt  # Track successful integration steps

print("Starting stabilized time integration...")
for n in range(Nt-1):
    u_current = u_solution[n, :]
    
    # Compute convection term with upwind scheme
    conv_term = -u_current * upwind_derivative(u_current, dx)
    
    # Explicit diffusion component
    diff_explicit = (dt * nu / 2) * (D2 @ u_current)
    
    # Construct RHS vector
    rhs = u_current + dt * conv_term + diff_explicit
    
    # Enforce boundary conditions
    rhs[0] = 0; rhs[-1] = 0
    
    # Solve linear system
    u_next = splinalg.spsolve(A, rhs)
    
    # NaN detection and early termination
    if np.any(np.isnan(u_next)):
        print(f"NaN detected at step {n+1}/{Nt}. Terminating early.")
        valid_steps = n + 1
        u_solution = u_solution[:valid_steps]
        break
        
    u_solution[n+1, :] = u_next
    
    # Progress monitoring
    if n % 200 == 0:
        t_current = t[n]
        energy = np.trapz(u_current**2, x)
        print(f"Step {n}/{Nt} (t={t_current:.3f}): "
              f"Max|u|={np.max(np.abs(u_current)):.4f}, "
              f"Energy={energy:.6f}")

print(f"Time integration completed: {valid_steps} successful steps")

# ==============================================================================
# Visualization
# ==============================================================================
# Create truncated time array for contour plot
t_valid = t[:valid_steps]
X, T = np.meshgrid(x, t_valid)

# Velocity Contour Plot
plt.figure(figsize=(10, 6))
plt.contourf(X, T, u_solution, levels=50, cmap='jet')
plt.colorbar(label='Velocity (u)')
plt.xlabel('Spatial Coordinate (x)')
plt.ylabel('Temporal Coordinate (t)')
plt.title('Stabilized Velocity Contour: 1D Burgers Equation')
plt.savefig('stabilized_velocity_contour.png', dpi=300, bbox_inches='tight')
plt.close()

# Final Velocity Profile
plt.figure(figsize=(10, 6))
plt.plot(x, u_solution[0, :], 'k--', label='Initial Condition')
plt.plot(x, u_solution[-1, :], 'r-', linewidth=2, label='Final Solution')
plt.xlabel('Spatial Coordinate (x)')
plt.ylabel('Velocity (u)')
plt.title(f'Velocity Profile (t={t_valid[-1]:.2f})')
plt.grid(True)
plt.legend()
plt.savefig('stabilized_velocity_profile.png', dpi=300, bbox_inches='tight')
plt.close()

print("Figures saved successfully")
```

**Key Improvements Explained:**

1. **Upwind Scheme Implementation**:
```python
def upwind_derivative(u, dx):
    du = np.zeros_like(u)
    positive_u = u[1:-1] >= 0
    du[1:-1] = np.where(
        positive_u,
        (u[1:-1] - u[:-2]) / dx,  # Backward difference
        (u[2:] - u[1:-1]) / dx     # Forward difference
    )
    return du
```
- Uses conditional vectorization (`np.where`) for efficient upwinding
- Handles wave direction based on local velocity sign
- Adds numerical dissipation to stabilize steep gradients

2. **Time Step Optimization**:
```python
Nt = 2048  # Increased from 1024
```
- Reduces CFL number from 0.1246 → 0.0623
- Meets stability condition for explicit convection treatment

3. **Boundary Condition Enforcement**:
```python
# In upwind_derivative:
du[0] = 0
du[-1] = 0

# In RHS construction:
rhs[0] = 0; rhs[-1] = 0
```
- Explicitly zeros convection term at boundaries
- Prevents spurious values from affecting interior solution

4. **Runtime Monitoring**:
```python
if np.any(np.isnan(u_next)):
    print(f"NaN detected at step {n+1}/{Nt}. Terminating early.")
    valid_steps = n + 1
    break
```
- Early termination on NaN detection
- Preserves valid solution segments for visualization
- Energy integral tracking for solution validation

**Visualization Enhancements**:
- Overlays initial condition on final profile plot
- Includes time annotation in progress reports
- Uses clearer filenames indicating stabilization
- Maintains publication-quality figure resolution

This implementation should remain stable throughout the simulation while capturing the essential physics of viscous Burgers' equation evolution. The upwind scheme provides necessary dissipation without compromising accuracy for this moderately viscous case.
****************************************
