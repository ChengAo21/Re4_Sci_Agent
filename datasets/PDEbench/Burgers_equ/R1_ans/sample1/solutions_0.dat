
****************************************
Based on the detailed analysis, I'll implement a semi-implicit Crank-Nicolson scheme for the diffusion term with explicit treatment of the nonlinear convection term. This balances stability and computational efficiency while handling the viscous term robustly.

```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as splinalg
import matplotlib.pyplot as plt

# ==============================================================================
# Parameters and Discretization
# ==============================================================================
nu = 0.01 / np.pi        # Viscosity coefficient
x_min, x_max = -1, 1     # Spatial domain
t_min, t_max = 0, 1      # Temporal domain
Nx = 256                 # Spatial grid points
Nt = 1024                # Temporal grid points

# Discretization
x = np.linspace(x_min, x_max, Nx)
t = np.linspace(t_min, t_max, Nt)
dx = x[1] - x[0]
dt = t[1] - t[0]

# ==============================================================================
# Initial Condition
# ==============================================================================
u0 = -np.sin(np.pi * x)  # Initial velocity profile

# ==============================================================================
# Construct Second Derivative Operator (Sparse Matrix)
# ==============================================================================
# Central difference coefficients for interior points
main_diag = -2 * np.ones(Nx) / dx**2
off_diag = np.ones(Nx-1) / dx**2

# Create sparse tridiagonal matrix
D2 = sp.diags([off_diag, main_diag, off_diag], [-1, 0, 1], format='csc')

# ==============================================================================
# Construct Implicit System Matrix (Crank-Nicolson)
# ==============================================================================
I = sp.eye(Nx, format='csc')  # Identity matrix
A = I - (dt * nu / 2) * D2

# Apply Dirichlet boundary conditions
A[0, :] = 0; A[0, 0] = 1    # Left boundary
A[-1, :] = 0; A[-1, -1] = 1  # Right boundary

# ==============================================================================
# Time Integration (Semi-Implicit Scheme)
# ==============================================================================
# Initialize solution array
u_solution = np.zeros((Nt, Nx))
u_solution[0, :] = u0

# Time-stepping loop
for n in range(Nt-1):
    u_current = u_solution[n, :]
    
    # Compute spatial derivative (central difference)
    du_dx = np.zeros_like(u_current)
    du_dx[1:-1] = (u_current[2:] - u_current[:-2]) / (2*dx)
    
    # Explicit convection term
    conv_term = -u_current * du_dx
    
    # Explicit part of diffusion term
    diff_explicit = (dt * nu / 2) * (D2 @ u_current)
    
    # Construct right-hand side vector
    rhs = u_current + dt * conv_term + diff_explicit
    
    # Apply boundary conditions to RHS
    rhs[0] = 0; rhs[-1] = 0
    
    # Solve implicit system
    u_next = splinalg.spsolve(A, rhs)
    u_solution[n+1, :] = u_next

# ==============================================================================
# Plotting Section
# ==============================================================================
# Create meshgrid for contour plot
X, T = np.meshgrid(x, t)

# Plot 1: Velocity Contour
plt.figure(figsize=(10, 6))
contour = plt.contourf(X, T, u_solution, levels=50, cmap='jet')
plt.colorbar(contour, label='Velocity (u)')
plt.xlabel('Spatial Coordinate (x)')
plt.ylabel('Temporal Coordinate (t)')
plt.title('Velocity Contour: 1D Burgers Equation')
plt.savefig('velocity_contour.png', dpi=300, bbox_inches='tight')
plt.close()

# Plot 2: Velocity Profile at Final Time
plt.figure(figsize=(10, 6))
plt.plot(x, u_solution[-1, :], 'b-', linewidth=2)
plt.xlabel('Spatial Coordinate (x)')
plt.ylabel('Velocity (u)')
plt.title('Velocity Profile at t = 1.0')
plt.grid(True)
plt.savefig('velocity_profile.png', dpi=300, bbox_inches='tight')
plt.close()
```

### Technical Explanation:

1. **Semi-Implicit Scheme Selection**:
   - Uses Crank-Nicolson (2nd-order accurate) for the diffusion term (implicit)
   - Explicit Euler for the nonlinear convection term
   - Balances stability (diffusion) and computational efficiency (convection)

2. **Spatial Discretization**:
   - Central differences for 1st/2nd derivatives (2nd-order accurate)
   - Sparse matrix storage for efficient computation (O(N) complexity)
   - Dirichlet BCs enforced via matrix modification

3. **Temporal Discretization**:
   - Adaptive time-stepping not required due to semi-implicit stability
   - CFL condition satisfied via dt = (t_max - t_min)/(Nt-1)

4. **Nonlinearity Handling**:
   - Explicit treatment avoids Newton iterations
   - Conservative time step maintains stability for moderate Re

5. **Numerical Efficiency**:
   - Sparse matrix algebra reduces storage from O(NÂ²) to O(N)
   - Direct solver optimal for 1D problems (tridiagonal systems)

### Key Features:
- Strict boundary condition enforcement at matrix level
- Avoids numerical diffusion via central differencing
- Memory-efficient solution storage
- Jet colormap for enhanced contour visualization
- High-resolution output (300 DPI)

The solution captures shock formation tendencies moderated by viscosity, with contour plots visualizing the complete space-time evolution and the final profile showing viscous smoothing effects.
****************************************
