
****************************************
```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from scipy.ndimage import binary_dilation

# ---------------------------
# Technical explanation:
# We solve the 2D Poisson-Boltzmann (Helmholtz) equation:
#   -Δu + k^2 u = f(x,y)
# on the domain Ω = [-1,1]^2 with four circular holes removed.
# Dirichlet boundary conditions:
#   u = 0.2 on the outer square boundary ∂Ω_rec,
#   u = 1.0 on the boundaries of the holes ∂Ω_circle.
#
# Approach:
# - Use Finite Difference Method (FDM) on a uniform Cartesian grid.
# - Represent holes as boolean masks on the grid.
# - Identify hole boundaries using binary dilation.
# - Apply 5-point stencil for Laplacian on unknown interior points.
# - Incorporate k^2 u term into the diagonal of the system matrix.
# - Enforce Dirichlet BCs by fixing u at boundary points and modifying RHS.
# - Assemble sparse linear system and solve with Conjugate Gradient (CG) solver.
# - Use Jacobi preconditioning to accelerate convergence.
#
# Optimizations:
# - Vectorized mask operations for hole and boundary detection.
# - Sparse matrix assembled efficiently using COO format.
# - Solver call uses atol and rtol for compatibility.
# - Detailed printing of problem size and solver info for reliability.
# - Modular code structure for clarity and reusability.
# ---------------------------

def generate_grid(Lx, Ly, Nx, Ny):
    """Generate uniform Cartesian grid on [-Lx/2, Lx/2] x [-Ly/2, Ly/2]."""
    x = np.linspace(-Lx/2, Lx/2, Nx)
    y = np.linspace(-Ly/2, Ly/2, Ny)
    hx = x[1] - x[0]
    hy = y[1] - y[0]
    X, Y = np.meshgrid(x, y, indexing='ij')
    return X, Y, hx, hy

def inside_circle(xc, yc, r, X, Y):
    """Return boolean mask of points inside circle centered at (xc,yc) with radius r."""
    return (X - xc)**2 + (Y - yc)**2 <= r**2

def build_masks(X, Y, circles):
    """Build masks for holes, hole boundaries, outer boundary, domain, Dirichlet, unknown points."""
    Nx, Ny = X.shape

    # Mask points inside any circle (holes)
    mask_holes = np.zeros_like(X, dtype=bool)
    for (xc, yc, r) in circles:
        mask_holes |= inside_circle(xc, yc, r, X, Y)

    # Outer boundary mask (edges of the rectangular domain)
    mask_outer_boundary = np.zeros_like(X, dtype=bool)
    mask_outer_boundary[0, :] = True
    mask_outer_boundary[-1, :] = True
    mask_outer_boundary[:, 0] = True
    mask_outer_boundary[:, -1] = True

    # Hole boundary points: dilation of holes minus holes themselves
    mask_hole_boundary = binary_dilation(mask_holes) & (~mask_holes)

    # Domain points: points not inside holes
    mask_domain = ~mask_holes

    # Dirichlet boundary points: outer boundary + hole boundaries
    mask_dirichlet = mask_outer_boundary | mask_hole_boundary

    # Unknown interior points: domain points excluding Dirichlet boundary points
    mask_unknown = mask_domain & (~mask_dirichlet)

    return mask_holes, mask_outer_boundary, mask_hole_boundary, mask_dirichlet, mask_unknown

def assemble_system(X, Y, hx, hy, k, A, mu1, mu2,
                    mask_holes, mask_outer_boundary, mask_hole_boundary,
                    mask_dirichlet, mask_unknown):
    """Assemble sparse linear system A u = b for unknown points using 5-point stencil."""
    Nx, Ny = X.shape
    num_unknowns = np.sum(mask_unknown)

    # Map 2D indices to 1D indices for unknowns
    idx_map = -np.ones_like(X, dtype=int)
    idx_map[mask_unknown] = np.arange(num_unknowns)

    # Define source term f(x,y)
    f = A * (mu1**2 + mu2**2 + X**2 + Y**2) * \
        np.sin(mu1 * np.pi * X) * np.sin(mu2 * np.pi * Y)

    # Finite difference coefficients
    inv_hx2 = 1.0 / hx**2
    inv_hy2 = 1.0 / hy**2
    center_coef = 2 * (inv_hx2 + inv_hy2) + k**2

    data = []
    rows = []
    cols = []
    b = np.zeros(num_unknowns)

    # Precompute neighbor offsets for 5-point stencil
    neighbors_offsets = [ (1,0), (-1,0), (0,1), (0,-1) ]

    # Assemble matrix and RHS
    for i in range(1, Nx-1):
        for j in range(1, Ny-1):
            if mask_unknown[i, j]:
                row_idx = idx_map[i, j]

                # Center coefficient
                rows.append(row_idx)
                cols.append(row_idx)
                data.append(center_coef)

                # RHS from source term
                b[row_idx] = f[i, j]

                # Loop over neighbors
                for di, dj in neighbors_offsets:
                    ni, nj = i + di, j + dj

                    if mask_unknown[ni, nj]:
                        # Neighbor unknown: off-diagonal entry
                        rows.append(row_idx)
                        cols.append(idx_map[ni, nj])
                        if di != 0:
                            data.append(-inv_hx2)
                        else:
                            data.append(-inv_hy2)
                    else:
                        # Neighbor is Dirichlet boundary or hole interior
                        if mask_dirichlet[ni, nj]:
                            # Dirichlet BC value
                            if mask_outer_boundary[ni, nj]:
                                u_bc = 0.2
                            elif mask_hole_boundary[ni, nj]:
                                u_bc = 1.0
                            else:
                                # Should not happen, fallback
                                u_bc = 0.0
                            # Add contribution to RHS
                            if di != 0:
                                b[row_idx] += inv_hx2 * u_bc
                            else:
                                b[row_idx] += inv_hy2 * u_bc
                        else:
                            # Neighbor inside hole interior (excluded)
                            # Implicit zero Neumann flux (no contribution)
                            pass

    # Build sparse matrix in CSR format
    A_matrix = sp.csr_matrix((data, (rows, cols)), shape=(num_unknowns, num_unknowns))

    return A_matrix, b, idx_map

def solve_system(A_matrix, b):
    """Solve linear system using Conjugate Gradient with Jacobi preconditioning."""
    # Jacobi preconditioner (inverse of diagonal)
    M_diag = A_matrix.diagonal()
    # Avoid division by zero
    M_diag[M_diag == 0] = 1.0
    M_inv = sp.diags(1.0 / M_diag)

    print("Solving linear system with Conjugate Gradient solver...")
    try:
        # Use atol and rtol for compatibility with SciPy versions
        u_unknown, info = spla.cg(A_matrix, b, atol=1e-8, rtol=1e-8, maxiter=1000, M=M_inv)
    except TypeError:
        # Fallback if atol/rtol not supported
        u_unknown, info = spla.cg(A_matrix, b, tol=1e-8, maxiter=1000, M=M_inv)

    # Interpret solver info
    if info == 0:
        print("Conjugate Gradient solver converged successfully.")
    elif info > 0:
        print(f"Conjugate Gradient solver did NOT converge after {info} iterations.")
    else:
        print("Conjugate Gradient solver failed with illegal input or breakdown.")

    # Compute residual norm ||A u - b||
    residual = A_matrix.dot(u_unknown) - b
    res_norm = np.linalg.norm(residual)
    print(f"Residual norm ||A u - b|| = {res_norm:.3e}")

    return u_unknown

def construct_full_solution(u_unknown, idx_map,
                            mask_outer_boundary, mask_hole_boundary,
                            mask_holes):
    """Construct full solution array including Dirichlet BCs and NaNs inside holes."""
    u = np.zeros_like(idx_map, dtype=float)

    # Set Dirichlet BCs
    u[mask_outer_boundary] = 0.2
    u[mask_hole_boundary] = 1.0

    # Set unknown interior points
    u[idx_map >= 0] = u_unknown

    # Set NaN inside holes for visualization clarity
    u[mask_holes] = np.nan

    return u

def plot_solution(X, Y, u, circles, filename='poisson_boltzmann_solution.png'):
    """Plot contour of solution u with holes marked as circles."""
    fig, ax = plt.subplots(figsize=(8, 8))

    # Mask NaNs for contourf
    u_masked = np.ma.masked_invalid(u)

    # Contour plot with 50 levels and jet colormap
    cont = ax.contourf(X, Y, u_masked, levels=50, cmap='jet')

    # Colorbar with label
    cbar = fig.colorbar(cont, ax=ax)
    cbar.set_label('Solution u(x,y)')

    # Overlay circles representing holes
    for (xc, yc, r) in circles:
        circle_patch = Circle((xc, yc), r, edgecolor='black', facecolor='none', linewidth=2)
        ax.add_patch(circle_patch)

    # Set plot limits, aspect ratio, labels, and title
    ax.set_xlim(X.min(), X.max())
    ax.set_ylim(Y.min(), Y.max())
    ax.set_aspect('equal')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title('Solution u of Poisson-Boltzmann equation with holes')

    plt.tight_layout()
    fig.savefig(filename, dpi=300)
    print(f"Contour plot saved as '{filename}'.")

def main():
    # Parameters
    mu1, mu2 = 1, 4
    k = 8
    A = 10

    # Domain and grid parameters
    Lx, Ly = 2.0, 2.0  # domain size [-1,1]^2
    Nx, Ny = 201, 201  # grid points (odd for symmetry)

    # Generate grid
    X, Y, hx, hy = generate_grid(Lx, Ly, Nx, Ny)

    # Circles definitions (centers and radii)
    circles = [
        (0.5,  0.5, 0.2),
        (0.4, -0.4, 0.4),
        (-0.2, -0.7, 0.1),
        (-0.6,  0.5, 0.3)
    ]

    # Build masks for holes, boundaries, domain, unknowns
    mask_holes, mask_outer_boundary, mask_hole_boundary, mask_dirichlet, mask_unknown = \
        build_masks(X, Y, circles)

    # Print problem size information
    print(f"Grid size: {Nx} x {Ny} = {Nx*Ny} points")
    print(f"Number of hole points (excluded): {np.sum(mask_holes)}")
    print(f"Number of Dirichlet boundary points: {np.sum(mask_dirichlet)}")
    print(f"Number of unknown interior points: {np.sum(mask_unknown)}")

    # Assemble linear system
    A_matrix, b, idx_map = assemble_system(
        X, Y, hx, hy, k, A, mu1, mu2,
        mask_holes, mask_outer_boundary, mask_hole_boundary,
        mask_dirichlet, mask_unknown
    )

    # Solve linear system
    u_unknown = solve_system(A_matrix, b)

    # Construct full solution including Dirichlet BCs and NaNs inside holes
    u = construct_full_solution(u_unknown, idx_map,
                                mask_outer_boundary, mask_hole_boundary,
                                mask_holes)

    # Plot solution with holes marked
    plot_solution(X, Y, u, circles)

if __name__ == "__main__":
    main()
```

****************************************
