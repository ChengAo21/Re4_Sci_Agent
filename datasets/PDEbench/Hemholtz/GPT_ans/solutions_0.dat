
****************************************
```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt
from matplotlib.patches import Circle

# ---------------------------
# Technical explanation:
# We solve the 2D Poisson-Boltzmann (Helmholtz) equation:
#   -Î”u + k^2 u = f(x,y)
# on the domain [-1,1]^2 with four circular holes removed.
# Dirichlet BCs: u=0.2 on outer square boundary, u=1 on hole boundaries.
#
# Approach:
# - Use Finite Difference Method (FDM) on a uniform Cartesian grid.
# - Mask points inside holes (excluded from domain).
# - Apply 5-point stencil for Laplacian on interior points.
# - Incorporate k^2 u term.
# - Enforce Dirichlet BCs by fixing u at boundary points.
# - Assemble sparse linear system and solve with SciPy sparse solver.
#
# This approach balances simplicity and reasonable accuracy.
# The holes are approximated by masking grid points inside circles,
# resulting in a "staircase" boundary approximation.
# ---------------------------

# Parameters
mu1, mu2 = 1, 4
k = 8
A = 10

# Domain and grid parameters
Lx, Ly = 2.0, 2.0  # domain size [-1,1]^2
Nx, Ny = 201, 201   # grid points in x and y (odd for symmetry)
x = np.linspace(-1, 1, Nx)
y = np.linspace(-1, 1, Ny)
hx = x[1] - x[0]
hy = y[1] - y[0]

X, Y = np.meshgrid(x, y, indexing='ij')  # shape (Nx, Ny)

# Define holes as boolean mask arrays
def inside_circle(xc, yc, r, X, Y):
    return (X - xc)**2 + (Y - yc)**2 <= r**2

# Circles definitions
circles = [
    (0.5,  0.5, 0.2),
    (0.4, -0.4, 0.4),
    (-0.2, -0.7, 0.1),
    (-0.6,  0.5, 0.3)
]

# Mask points inside any circle (holes)
mask_holes = np.zeros_like(X, dtype=bool)
for (xc, yc, r) in circles:
    mask_holes |= inside_circle(xc, yc, r, X, Y)

# Mask for outer boundary points (on domain edges)
mask_outer_boundary = np.zeros_like(X, dtype=bool)
mask_outer_boundary[0, :] = True
mask_outer_boundary[-1, :] = True
mask_outer_boundary[:, 0] = True
mask_outer_boundary[:, -1] = True

# Identify hole boundary points:
# Points inside domain but adjacent to hole points
# We define hole boundary as points not inside hole but with at least one neighbor inside hole
mask_hole_boundary = np.zeros_like(X, dtype=bool)
for i in range(1, Nx-1):
    for j in range(1, Ny-1):
        if not mask_holes[i,j]:
            # Check 4 neighbors
            neighbors = [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]
            for (ni,nj) in neighbors:
                if mask_holes[ni,nj]:
                    mask_hole_boundary[i,j] = True
                    break

# Domain points: points not inside holes
mask_domain = ~mask_holes

# Unknown points: domain points excluding Dirichlet boundary points
# Dirichlet BCs are applied on outer boundary and hole boundaries
mask_dirichlet = mask_outer_boundary | mask_hole_boundary
mask_unknown = mask_domain & (~mask_dirichlet)

# Count unknowns
num_unknowns = np.sum(mask_unknown)
print(f"Grid size: {Nx} x {Ny} = {Nx*Ny} points")
print(f"Number of hole points (excluded): {np.sum(mask_holes)}")
print(f"Number of Dirichlet boundary points: {np.sum(mask_dirichlet)}")
print(f"Number of unknown interior points: {num_unknowns}")

# Map 2D indices to 1D indices for unknowns
idx_map = -np.ones_like(X, dtype=int)
idx_map[mask_unknown] = np.arange(num_unknowns)

# Define source term f(x,y)
# f(x,y) = A * (mu1^2 + mu2^2 + x^2 + y^2) * sin(mu1*pi*x) * sin(mu2*pi*y)
f = A * (mu1**2 + mu2**2 + X**2 + Y**2) * \
    np.sin(mu1 * np.pi * X) * np.sin(mu2 * np.pi * Y)

# Initialize sparse matrix data for A and right-hand side b
data = []
rows = []
cols = []
b = np.zeros(num_unknowns)

# Finite difference coefficients for 5-point Laplacian
# Using uniform grid spacing hx=hy
inv_hx2 = 1.0 / hx**2
inv_hy2 = 1.0 / hy**2
center_coef = 2 * (inv_hx2 + inv_hy2) + k**2

# Assemble linear system A u = b
for i in range(1, Nx-1):
    for j in range(1, Ny-1):
        if mask_unknown[i,j]:
            row_idx = idx_map[i,j]
            # Center coefficient
            rows.append(row_idx)
            cols.append(row_idx)
            data.append(center_coef)

            # Right-hand side
            b[row_idx] = f[i,j]

            # Neighbor points: (i+1,j), (i-1,j), (i,j+1), (i,j-1)
            neighbors = [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]
            for (ni,nj) in neighbors:
                if mask_unknown[ni,nj]:
                    # Neighbor unknown: add off-diagonal -1/h^2
                    rows.append(row_idx)
                    cols.append(idx_map[ni,nj])
                    if ni != i:
                        data.append(-inv_hx2)
                    else:
                        data.append(-inv_hy2)
                else:
                    # Neighbor is Dirichlet boundary or hole point
                    # Enforce Dirichlet BC by moving known u to RHS
                    if mask_dirichlet[ni,nj]:
                        # Dirichlet value:
                        if mask_outer_boundary[ni,nj]:
                            u_bc = 0.2
                        elif mask_hole_boundary[ni,nj]:
                            u_bc = 1.0
                        else:
                            # Should not happen, but fallback
                            u_bc = 0.0
                        if ni != i:
                            b[row_idx] += inv_hx2 * u_bc
                        else:
                            b[row_idx] += inv_hy2 * u_bc
                    else:
                        # Neighbor is hole interior (excluded) - no contribution
                        # This corresponds to Neumann zero flux implicitly
                        # We do nothing here (equivalent to zero flux)
                        pass

# Build sparse matrix
A = sp.csr_matrix((data, (rows, cols)), shape=(num_unknowns, num_unknowns))

# Solve linear system
print("Solving linear system...")
u_unknown, info = spla.cg(A, b, tol=1e-8, maxiter=1000)
if info == 0:
    print("Conjugate Gradient solver converged successfully.")
elif info > 0:
    print(f"Conjugate Gradient solver did NOT converge after {info} iterations.")
else:
    print("Conjugate Gradient solver failed with illegal input or breakdown.")

# Compute residual norm ||A u - b||
residual = A.dot(u_unknown) - b
res_norm = np.linalg.norm(residual)
print(f"Residual norm ||A u - b|| = {res_norm:.3e}")

# Construct full solution array including Dirichlet points
u = np.zeros_like(X)
# Set Dirichlet BCs
u[mask_outer_boundary] = 0.2
u[mask_hole_boundary] = 1.0
# Unknown interior points
u[mask_unknown] = u_unknown

# For points inside holes (excluded), set NaN for visualization clarity
u[mask_holes] = np.nan

# ---------------------------
# Visualization
# ---------------------------
fig, ax = plt.subplots(figsize=(8,8))

# Contour plot of solution u
# Mask NaNs for contourf by using np.ma.masked_invalid
u_masked = np.ma.masked_invalid(u)
cont = ax.contourf(X, Y, u_masked, levels=50, cmap='jet')

# Add colorbar
cbar = fig.colorbar(cont, ax=ax)
cbar.set_label('Solution u(x,y)')

# Overlay circles representing holes
for (xc, yc, r) in circles:
    circle_patch = Circle((xc, yc), r, edgecolor='black', facecolor='none', linewidth=2)
    ax.add_patch(circle_patch)

# Set plot limits and labels
ax.set_xlim(-1,1)
ax.set_ylim(-1,1)
ax.set_aspect('equal')
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_title('Solution u of Poisson-Boltzmann equation with holes')

# Save figure
fig.savefig('poisson_boltzmann_solution.png', dpi=300)
print("Contour plot saved as 'poisson_boltzmann_solution.png'.")

# No plt.show() as per instructions
```
****************************************
