
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt

# Technical explanation for the solving algorithm
# The problem involves solving the 2D steady incompressible Navier-Stokes equations,
# which are a set of coupled non-linear partial differential equations for velocity (u, v)
# and pressure (p). The incompressibility constraint (divergence-free velocity) makes
# the system challenging to solve directly due to the lack of a time derivative for pressure.
#
# The Artificial Compressibility Method (ACM) is employed here to overcome this challenge.
# This method introduces a pseudo-time derivative of pressure into the continuity equation,
# effectively transforming the steady incompressible system into a time-dependent,
# compressible-like system that can be marched in pseudo-time (tau) until a steady state
# is reached. As the solution converges to a steady state (i.e., the pseudo-time derivatives
# approach zero), the original incompressible Navier-Stokes equations are recovered.
#
# The modified system of equations solved iteratively in pseudo-time is:
# 1. Momentum in x-direction:
#    ∂u/∂τ = - (u ∂u/∂x + v ∂u/∂y) - ∂p/∂x + (1/Re) (∂²u/∂x² + ∂²u/∂y²)
# 2. Momentum in y-direction:
#    ∂v/∂τ = - (u ∂v/∂x + v ∂v/∂y) - ∂p/∂y + (1/Re) (∂²v/∂x² + ∂²v/∂y²)
# 3. Artificial Continuity (Pressure Evolution):
#    ∂p/∂τ = - β (∂u/∂x + ∂v/∂y)
#
# Here, 'τ' is the artificial time, and 'β' is the artificial compressibility parameter,
# which controls the rate at which the pressure field adjusts to satisfy the continuity
# equation. A common choice for β is 1.0.
#
# Spatial discretization is performed using second-order central finite differences
# for all derivatives (convection, diffusion, and pressure gradients) on a uniform
# Cartesian grid. This approach is straightforward to implement but can introduce
# numerical oscillations for convection-dominated flows if the grid is not fine enough
# or if upwinding schemes are not used for convection terms. For Re=100, central
# differences are often acceptable with a sufficiently small pseudo-time step.
#
# The time marching is done using an explicit Euler scheme for simplicity. At each
# pseudo-time step, the momentum equations are updated first using the current
# velocity and pressure fields. Then, the pressure equation is updated using the
# newly computed (intermediate) velocity field to enforce the incompressibility
# constraint. Boundary conditions are applied after each update step for the
# respective fields.
#
# Convergence is monitored by tracking the maximum absolute change in the velocity
# and pressure fields between successive pseudo-time steps. The iteration stops
# when this change falls below a predefined tolerance or a maximum number of iterations
# is reached.
#
# Boundary conditions are applied as follows:
# - Velocity: No-slip conditions (u=0, v=0) are enforced on the left, right, and
#   bottom boundaries. On the top boundary, a parabolic velocity profile
#   (u = αx(1-x), v = 0) is imposed, where α=2.
# - Pressure: A reference pressure p(0,0)=0 is set to fix the absolute pressure level.
#   Zero normal pressure gradient (∂p/∂n=0) is applied on all boundaries. This is
#   implemented by setting the pressure at a boundary grid point equal to the
#   pressure at its adjacent interior grid point.

# --- Parameters ---
Nx = 51  # Number of grid points in x-direction
Ny = 51  # Number of grid points in y-direction
Re = 100.0  # Reynolds number
alpha = 2.0  # Parameter for top boundary velocity profile
beta = 1.0  # Artificial compressibility parameter

dx = 1.0 / (Nx - 1)  # Grid spacing in x
dy = 1.0 / (Ny - 1)  # Grid spacing in y

# Pseudo-time step (dt_tau) selection is crucial for stability and convergence speed.
# A small constant value is chosen here. For more robust or faster simulations,
# adaptive time stepping or CFL-based criteria might be used.
dt_tau = 0.001

max_iter = 100000  # Maximum number of pseudo-time iterations
tol = 1e-5  # Convergence tolerance for the maximum absolute change in fields

# --- Grid Generation ---
x = np.linspace(0, 1, Nx)
y = np.linspace(0, 1, Ny)
X, Y = np.meshgrid(x, y) # For plotting

# --- Initialize Fields ---
u = np.zeros((Ny, Nx))  # u-velocity component
v = np.zeros((Ny, Nx))  # v-velocity component
p = np.zeros((Ny, Nx))  # Pressure

# --- Apply Initial Boundary Conditions for Velocity ---
# Top boundary (y=1, j=Ny-1): u = alpha*x*(1-x), v = 0
u[Ny - 1, :] = alpha * x * (1 - x)
v[Ny - 1, :] = 0.0
# Other boundaries (left, right, bottom): u = 0, v = 0 (already initialized to zero)

# --- Functions for applying boundary conditions ---
def apply_velocity_bcs(u_field, v_field, x_coords, alpha_val, Nx_grid, Ny_grid):
    # Top boundary (y=1, j=Ny-1)
    u_field[Ny_grid - 1, :] = alpha_val * x_coords * (1 - x_coords)
    v_field[Ny_grid - 1, :] = 0.0
    # Bottom boundary (y=0, j=0)
    u_field[0, :] = 0.0
    v_field[0, :] = 0.0
    # Left boundary (x=0, i=0)
    u_field[:, 0] = 0.0
    v_field[:, 0] = 0.0
    # Right boundary (x=1, i=Nx-1)
    u_field[:, Nx_grid - 1] = 0.0
    v_field[:, Nx_grid - 1] = 0.0

def apply_pressure_bcs(p_field, Nx_grid, Ny_grid):
    # Zero normal pressure gradient (dp/dn = 0)
    # This is implemented by setting pressure at boundary equal to pressure at adjacent interior point.
    # Bottom boundary (j=0)
    p_field[0, :] = p_field[1, :]
    # Top boundary (j=Ny-1)
    p_field[Ny_grid - 1, :] = p_field[Ny_grid - 2, :]
    # Left boundary (i=0)
    p_field[:, 0] = p_field[:, 1]
    # Right boundary (i=Nx-1)
    p_field[:, Nx_grid - 1] = p_field[:, Nx_grid - 2]
    
    # Reference pressure: p(x=0,y=0) = 0
    # This must be applied after other pressure BCs to ensure it's fixed.
    p_field[0, 0] = 0.0

# --- Main Iteration Loop (Artificial Compressibility Method) ---
print("Starting Artificial Compressibility Method iterations...")
print(f"Grid: {Nx}x{Ny}, Re: {Re}, dt_tau: {dt_tau}, Tolerance: {tol:.1e}")

# Store residuals for plotting convergence history
residuals = []

for it in range(max_iter):
    u_old = u.copy()
    v_old = v.copy()
    p_old = p.copy()

    # Calculate spatial derivatives for interior points (i from 1 to Nx-2, j from 1 to Ny-2)
    # Convection terms (u * du/dx + v * du/dy)
    u_dudx = u_old[1:-1, 1:-1] * (u_old[1:-1, 2:] - u_old[1:-1, 0:-2]) / (2 * dx)
    u_dvdx = u_old[1:-1, 1:-1] * (v_old[1:-1, 2:] - v_old[1:-1, 0:-2]) / (2 * dx)
    v_dudy = v_old[1:-1, 1:-1] * (u_old[2:, 1:-1] - u_old[0:-2, 1:-1]) / (2 * dy)
    v_dvdy = v_old[1:-1, 1:-1] * (v_old[2:, 1:-1] - v_old[0:-2, 1:-1]) / (2 * dy)

    # Pressure gradient terms (dp/dx, dp/dy)
    dpdx = (p_old[1:-1, 2:] - p_old[1:-1, 0:-2]) / (2 * dx)
    dpdy = (p_old[2:, 1:-1] - p_old[0:-2, 1:-1]) / (2 * dy)

    # Diffusion terms (Laplacian: d^2/dx^2 + d^2/dy^2)
    laplacian_u = (u_old[1:-1, 2:] - 2 * u_old[1:-1, 1:-1] + u_old[1:-1, 0:-2]) / dx**2 + \
                  (u_old[2:, 1:-1] - 2 * u_old[1:-1, 1:-1] + u_old[0:-2, 1:-1]) / dy**2
    laplacian_v = (v_old[1:-1, 2:] - 2 * v_old[1:-1, 1:-1] + v_old[0:-2, 1:-1]) / dx**2 + \
                  (v_old[2:, 1:-1] - 2 * v_old[1:-1, 1:-1] + v_old[0:-2, 1:-1]) / dy**2

    # --- Update Momentum Equations (u and v) using Explicit Euler ---
    # RHS of u-momentum equation (convection + pressure gradient + diffusion)
    u_rhs = - (u_dudx + v_dudy) - dpdx + (1 / Re) * laplacian_u
    # RHS of v-momentum equation
    v_rhs = - (u_dvdx + v_dvdy) - dpdy + (1 / Re) * laplacian_v

    # Create new arrays for updated velocities to avoid modifying in-place during calculations
    u_new = u_old.copy()
    v_new = v_old.copy()
    u_new[1:-1, 1:-1] = u_old[1:-1, 1:-1] + dt_tau * u_rhs
    v_new[1:-1, 1:-1] = v_old[1:-1, 1:-1] + dt_tau * v_rhs

    # Apply velocity boundary conditions to u_new and v_new
    apply_velocity_bcs(u_new, v_new, x, alpha, Nx, Ny)

    # --- Update Pressure Equation using Explicit Euler ---
    # Calculate divergence (continuity residual) using the *updated* velocities (u_new, v_new)
    # This ensures the pressure correction drives the new velocity field towards incompressibility.
    div_u = (u_new[1:-1, 2:] - u_new[1:-1, 0:-2]) / (2 * dx)
    div_v = (v_new[2:, 1:-1] - v_new[0:-2, 1:-1]) / (2 * dy)
    divergence = div_u + div_v

    # Create new array for updated pressure
    p_new = p_old.copy()
    p_new[1:-1, 1:-1] = p_old[1:-1, 1:-1] - dt_tau * beta * divergence

    # Apply pressure boundary conditions to p_new
    apply_pressure_bcs(p_new, Nx, Ny)

    # --- Check for Convergence ---
    # Calculate maximum absolute change in u, v, p fields between current and previous step
    max_change_u = np.max(np.abs(u_new - u_old))
    max_change_v = np.max(np.abs(v_new - v_old))
    max_change_p = np.max(np.abs(p_new - p_old))
    max_residual = max(max_change_u, max_change_v, max_change_p)
    residuals.append(max_residual)

    # Update fields for the next iteration
    u = u_new
    v = v_new
    p = p_new

    # Print progress periodically
    if it % 1000 == 0 or it == max_iter - 1:
        print(f"Iteration {it:5d}, Max Residual: {max_residual:.8e}")

    # Check if convergence criterion is met
    if max_residual < tol:
        print(f"\nConverged at iteration {it} with Max Residual: {max_residual:.8e}")
        break
else:
    # This block executes if the loop completes without breaking (i.e., did not converge)
    print(f"\nDid not converge within {max_iter} iterations. Final Max Residual: {max_residual:.8e}")

# --- Detailed Result Printing ---
print("\n--- Simulation Summary ---")
print(f"Final Max Residual: {max_residual:.8e}")
print(f"Total Iterations: {it + 1}")

# Calculate velocity magnitude for post-processing
velocity_magnitude = np.sqrt(u**2 + v**2)
print(f"Maximum Velocity Magnitude: {np.max(velocity_magnitude):.4f}")
print(f"Minimum Velocity Magnitude: {np.min(velocity_magnitude):.4f}")
print(f"Maximum Pressure: {np.max(p):.4f}")
print(f"Minimum Pressure: {np.min(p):.4f}")

# --- Plotting Results ---
# Plot convergence history
plt.figure(figsize=(10, 6))
plt.semilogy(residuals)
plt.title('Convergence History (Max Absolute Change vs. Iteration)')
plt.xlabel('Iteration')
plt.ylabel('Max Absolute Change (log scale)')
plt.grid(True)
plt.savefig('convergence_history.png', dpi=300)
plt.close() # Close the plot to free memory

# Plot contours of velocity magnitude with streamlines
plt.figure(figsize=(10, 8))
# Contour plot of velocity magnitude
contour = plt.contourf(X, Y, velocity_magnitude, levels=50, cmap='jet')
plt.colorbar(contour, label='Velocity Magnitude')
# Streamlines of the velocity field
plt.streamplot(X, Y, u, v, color='k', linewidth=0.8, density=1.5, arrowsize=1.5)
plt.title('Velocity Magnitude Contours and Streamlines (Re=100)')
plt.xlabel('x')
plt.ylabel('y')
plt.gca().set_aspect('equal', adjustable='box') # Ensure aspect ratio is 1:1
plt.savefig('velocity_magnitude_streamlines.png', dpi=300)
plt.close()

# Plot pressure contours (optional, but useful for visualizing the pressure field)
plt.figure(figsize=(10, 8))
pressure_contour = plt.contourf(X, Y, p, levels=50, cmap='jet')
plt.colorbar(pressure_contour, label='Pressure')
plt.title('Pressure Contours (Re=100)')
plt.xlabel('x')
plt.ylabel('y')
plt.gca().set_aspect('equal', adjustable='box')
plt.savefig('pressure_contours.png', dpi=300)
plt.close()

print("\nPlots saved: convergence_history.png, velocity_magnitude_streamlines.png, pressure_contours.png")
```
****************************************
