
****************************************
```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt

# -------------------------------
# Technical Explanation of the Solving Algorithm (Plan 1: FDM + SIMPLE)
# -------------------------------
# We solve the 2D steady incompressible Navier-Stokes equations on a unit square domain
# using a finite difference discretization on a uniform grid and the SIMPLE algorithm
# for pressure-velocity coupling.
#
# The SIMPLE algorithm iteratively:
# 1. Solves the momentum equations for tentative velocities (u*, v*) using the current pressure.
# 2. Solves a pressure correction Poisson equation derived from the continuity equation.
# 3. Updates pressure and velocity fields using the pressure correction.
# 4. Applies boundary conditions.
# 5. Repeats until residuals converge below a tolerance.
#
# The velocity boundary conditions are:
# - On the top boundary (y=1): u = alpha * x * (1 - x), v = 0 (lid-driven flow)
# - On other boundaries: u = v = 0 (no-slip walls)
#
# Pressure is fixed at the bottom-left corner (0,0) to remove the arbitrary constant.
#
# Discretization:
# - Central differences for diffusion terms.
# - Hybrid upwind-central scheme for convection terms to enhance stability.
# - Collocated grid arrangement for simplicity.
#
# Linear systems are solved using sparse matrix solvers from scipy.
#
# Postprocessing:
# - Compute velocity magnitude.
# - Plot contours of velocity magnitude and streamlines.
# - Save figure to file.

# -------------------------------
# Parameters and Grid Setup
# -------------------------------
Re = 100.0          # Reynolds number
alpha = 2.0         # Lid velocity parameter
Lx, Ly = 1.0, 1.0   # Domain size
Nx, Ny = 64, 64     # Number of grid points in x and y (including boundaries)
dx = Lx / (Nx - 1)
dy = Ly / (Ny - 1)

# Create grid points
x = np.linspace(0, Lx, Nx)
y = np.linspace(0, Ly, Ny)

# Initialize fields: u, v, p
# All defined on collocated grid points (Nx x Ny)
u = np.zeros((Ny, Nx))
v = np.zeros((Ny, Nx))
p = np.zeros((Ny, Nx))

# -------------------------------
# Boundary Conditions Function
# -------------------------------
def apply_boundary_conditions(u, v):
    # Top boundary (y=1): u = alpha * x * (1 - x), v = 0
    u[-1, :] = alpha * x * (1 - x)
    v[-1, :] = 0.0

    # Left boundary (x=0): u = v = 0
    u[:, 0] = 0.0
    v[:, 0] = 0.0

    # Right boundary (x=1): u = v = 0
    u[:, -1] = 0.0
    v[:, -1] = 0.0

    # Bottom boundary (y=0): u = v = 0
    u[0, :] = 0.0
    v[0, :] = 0.0

# -------------------------------
# Helper Functions for Derivatives
# -------------------------------
def ddx(f):
    # Compute ∂f/∂x using central differences (Neumann BCs handled by one-sided)
    dfdx = np.zeros_like(f)
    dfdx[:, 1:-1] = (f[:, 2:] - f[:, :-2]) / (2 * dx)
    # Forward/backward difference at boundaries
    dfdx[:, 0] = (f[:, 1] - f[:, 0]) / dx
    dfdx[:, -1] = (f[:, -1] - f[:, -2]) / dx
    return dfdx

def ddy(f):
    # Compute ∂f/∂y using central differences
    dfdy = np.zeros_like(f)
    dfdy[1:-1, :] = (f[2:, :] - f[:-2, :]) / (2 * dy)
    # Forward/backward difference at boundaries
    dfdy[0, :] = (f[1, :] - f[0, :]) / dy
    dfdy[-1, :] = (f[-1, :] - f[-2, :]) / dy
    return dfdy

def laplacian(f):
    # Compute Laplacian ∆f using central differences
    lap = np.zeros_like(f)
    lap[1:-1,1:-1] = (
        (f[1:-1,2:] - 2*f[1:-1,1:-1] + f[1:-1,:-2]) / dx**2 +
        (f[2:,1:-1] - 2*f[1:-1,1:-1] + f[:-2,1:-1]) / dy**2
    )
    # For boundaries, use one-sided differences (Neumann zero laplacian approx)
    # Here we simply set lap=0 at boundaries (Dirichlet BCs override)
    return lap

# -------------------------------
# SIMPLE Algorithm Implementation
# -------------------------------
max_iter = 5000
tolerance = 1e-6
under_relax_u = 0.7
under_relax_v = 0.7
under_relax_p = 0.3

# Pressure correction coefficients for Poisson eqn
# We will build a sparse matrix for the pressure correction equation

# Number of internal points (excluding boundaries)
Ni = (Nx - 2) * (Ny - 2)

# Index mapping from 2D to 1D for internal points
def idx(i, j):
    # i: y index (1 to Ny-2), j: x index (1 to Nx-2)
    return (i - 1) * (Nx - 2) + (j - 1)

# Build sparse matrix for pressure correction Poisson equation
data = []
rows = []
cols = []

for i in range(1, Ny-1):
    for j in range(1, Nx-1):
        row = idx(i, j)
        # Center coefficient
        coeff = -2.0 / dx**2 - 2.0 / dy**2
        rows.append(row)
        cols.append(row)
        data.append(coeff)
        # Left neighbor
        if j > 1:
            rows.append(row)
            cols.append(idx(i, j-1))
            data.append(1.0 / dx**2)
        # Right neighbor
        if j < Nx-2:
            rows.append(row)
            cols.append(idx(i, j+1))
            data.append(1.0 / dx**2)
        # Bottom neighbor
        if i > 1:
            rows.append(row)
            cols.append(idx(i-1, j))
            data.append(1.0 / dy**2)
        # Top neighbor
        if i < Ny-2:
            rows.append(row)
            cols.append(idx(i+1, j))
            data.append(1.0 / dy**2)

A_p = sp.csr_matrix((data, (rows, cols)), shape=(Ni, Ni))

# Fix pressure at (0,0) by setting p[0,0] = 0 after each update

# -------------------------------
# Main Iteration Loop
# -------------------------------
print_interval = 200

for it in range(1, max_iter+1):
    # Save old values for residual calculation
    u_old = u.copy()
    v_old = v.copy()
    p_old = p.copy()

    # Apply boundary conditions to velocity
    apply_boundary_conditions(u, v)

    # Compute convection terms with hybrid scheme (upwind-central)
    # For u-momentum:
    du_dx = ddx(u)
    du_dy = ddy(u)
    dv_dx = ddx(v)
    dv_dy = ddy(v)

    # Hybrid scheme for convection terms (u*du/dx + v*du/dy)
    # Upwind weights
    def hybrid_conv(f, df_dx, df_dy, u_vel, v_vel):
        conv = np.zeros_like(f)
        # x-direction
        conv_x = np.where(u_vel >= 0,
                          u_vel * (f - np.roll(f, 1, axis=1)) / dx,
                          u_vel * (np.roll(f, -1, axis=1) - f) / dx)
        # y-direction
        conv_y = np.where(v_vel >= 0,
                          v_vel * (f - np.roll(f, 1, axis=0)) / dy,
                          v_vel * (np.roll(f, -1, axis=0) - f) / dy)
        conv = conv_x + conv_y
        return conv

    conv_u = hybrid_conv(u, du_dx, du_dy, u, v)
    conv_v = hybrid_conv(v, dv_dx, dv_dy, u, v)

    # Diffusion terms
    diff_u = laplacian(u) / Re
    diff_v = laplacian(v) / Re

    # Pressure gradients
    dp_dx = ddx(p)
    dp_dy = ddy(p)

    # Tentative velocities (u*, v*) from momentum equations (explicit convection, implicit diffusion)
    # Here we do a simple explicit step for convection and implicit for diffusion:
    # (I - dt/Re * Laplacian) u* = u_old - dt * (conv_u + dp_dx)
    # We choose dt small enough for stability (pseudo time stepping)
    dt = 0.001

    # Build linear system for u* and v*:
    # For simplicity, solve diffusion implicitly with sparse matrix, convection and pressure explicitly

    # Construct diffusion matrix for u and v (same matrix)
    # 5-point Laplacian stencil with Dirichlet BCs zero velocity on boundaries
    data_u = []
    rows_u = []
    cols_u = []

    for i in range(Ny):
        for j in range(Nx):
            row = i * Nx + j
            if i == 0 or i == Ny-1 or j == 0 or j == Nx-1:
                # Boundary point: u = prescribed, so diagonal=1
                data_u.append(1.0)
                rows_u.append(row)
                cols_u.append(row)
            else:
                # Internal point: implicit diffusion
                diag = 1 + 2*dt/(Re*dx**2) + 2*dt/(Re*dy**2)
                data_u.append(diag)
                rows_u.append(row)
                cols_u.append(row)
                # Left neighbor
                data_u.append(-dt/(Re*dx**2))
                rows_u.append(row)
                cols_u.append(row - 1)
                # Right neighbor
                data_u.append(-dt/(Re*dx**2))
                rows_u.append(row)
                cols_u.append(row + 1)
                # Bottom neighbor
                data_u.append(-dt/(Re*dy**2))
                rows_u.append(row)
                cols_u.append(row - Nx)
                # Top neighbor
                data_u.append(-dt/(Re*dy**2))
                rows_u.append(row)
                cols_u.append(row + Nx)

    A_uv = sp.csr_matrix((data_u, (rows_u, cols_u)), shape=(Nx*Ny, Nx*Ny))

    # Right hand side for u and v
    rhs_u = (u - dt * (conv_u + dp_dx)).flatten()
    rhs_v = (v - dt * (conv_v + dp_dy)).flatten()

    # Enforce boundary conditions in rhs (u,v at boundaries fixed)
    # So at boundary points, rhs = prescribed velocity
    for i in range(Ny):
        for j in range(Nx):
            idx_uv = i * Nx + j
            if i == 0 or i == Ny-1 or j == 0 or j == Nx-1:
                rhs_u[idx_uv] = u[i, j]
                rhs_v[idx_uv] = v[i, j]

    # Solve linear systems for tentative velocities
    u_star_flat = spla.spsolve(A_uv, rhs_u)
    v_star_flat = spla.spsolve(A_uv, rhs_v)

    u_star = u_star_flat.reshape((Ny, Nx))
    v_star = v_star_flat.reshape((Ny, Nx))

    # Compute divergence of tentative velocity (for pressure correction)
    div_u_star = (u_star[:, 1:] - u_star[:, :-1]) / dx + (v_star[1:, :] - v_star[:-1, :]) / dy
    # div_u_star shape: (Ny-1, Nx-1)

    # Build RHS for pressure correction Poisson eqn: divergence / dt
    b_p = div_u_star.flatten() / dt

    # Solve pressure correction equation A_p * p_prime = b_p
    p_prime_flat = spla.spsolve(A_p, b_p)
    p_prime = np.zeros_like(p)
    # Map p_prime_flat back to internal points
    for i in range(1, Ny-1):
        for j in range(1, Nx-1):
            p_prime[i, j] = p_prime_flat[idx(i, j)]

    # Update pressure and velocities with under-relaxation
    p += under_relax_p * p_prime
    u = u_star - dt * ddx(p_prime)
    v = v_star - dt * ddy(p_prime)

    # Apply velocity boundary conditions again after correction
    apply_boundary_conditions(u, v)

    # Fix pressure reference at (0,0)
    p -= p[0, 0]

    # Compute residuals for convergence check
    res_u = np.linalg.norm(u - u_old) / np.sqrt(Nx*Ny)
    res_v = np.linalg.norm(v - v_old) / np.sqrt(Nx*Ny)
    res_p = np.linalg.norm(p - p_old) / np.sqrt(Nx*Ny)
    res = max(res_u, res_v, res_p)

    if it % print_interval == 0 or it == 1:
        print(f"Iteration {it:5d}: Residual = {res:.3e}")

    if res < tolerance:
        print(f"Converged after {it} iterations with residual {res:.3e}")
        break

else:
    print(f"Did not converge after {max_iter} iterations, residual = {res:.3e}")

# -------------------------------
# Postprocessing and Plotting
# -------------------------------
# Compute velocity magnitude
vel_mag = np.sqrt(u**2 + v**2)

# Create meshgrid for plotting
X, Y = np.meshgrid(x, y)

# Plot contours of velocity magnitude and streamlines
plt.figure(figsize=(8, 6))
contour = plt.contourf(X, Y, vel_mag, levels=50, cmap='jet')
plt.colorbar(contour, label='Velocity magnitude')

# Stream function approximation by integrating velocity field
# We approximate stream function psi by solving ∂ψ/∂y = u, ∂ψ/∂x = -v
# Here we integrate u along y and subtract integral of v along x to get psi approx

psi = np.zeros_like(u)
for j in range(1, Nx):
    psi[:, j] = psi[:, j-1] - v[:, j-1] * dx
for i in range(1, Ny):
    psi[i, :] += np.cumsum(u[i-1, :] * dy)

# Plot streamlines (contours of psi)
streamlines = plt.contour(X, Y, psi, levels=30, colors='k', linewidths=0.7)

plt.title('Velocity Magnitude Contours and Streamlines (Lid-driven cavity)')
plt.xlabel('x')
plt.ylabel('y')
plt.tight_layout()
plt.savefig('navier_stokes_lid_driven_cavity.png')
# plt.show() is intentionally omitted as per instructions
```
****************************************
