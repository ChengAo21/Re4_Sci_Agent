
****************************************
```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt

# -------------------------------
# Technical Explanation of the Solving Algorithm (FDM + SIMPLE)
# -------------------------------
# We solve the 2D steady incompressible Navier-Stokes equations on a unit square domain
# using a finite difference discretization on a uniform collocated grid and the SIMPLE algorithm
# for pressure-velocity coupling.
#
# The SIMPLE algorithm iteratively:
# 1. Solves the momentum equations for tentative velocities (u*, v*) using the current pressure.
# 2. Solves a pressure correction Poisson equation derived from the continuity equation.
# 3. Updates pressure and velocity fields using the pressure correction.
# 4. Applies boundary conditions.
# 5. Repeats until residuals converge below a tolerance.
#
# The velocity boundary conditions are:
# - On the top boundary (y=1): u = alpha * x * (1 - x), v = 0 (lid-driven flow)
# - On other boundaries: u = v = 0 (no-slip walls)
#
# Pressure is fixed at the bottom-left corner (0,0) to remove the arbitrary constant.
#
# Discretization:
# - Central differences for diffusion terms.
# - Hybrid upwind-central scheme for convection terms to enhance stability.
# - Collocated grid arrangement for simplicity.
#
# Linear systems are solved using sparse matrix solvers from scipy.
#
# Postprocessing:
# - Compute velocity magnitude.
# - Plot contours of velocity magnitude and streamlines.
# - Save figure to file.

# -------------------------------
# Parameters and Grid Setup
# -------------------------------
Re = 100.0          # Reynolds number
alpha = 2.0         # Lid velocity parameter
Lx, Ly = 1.0, 1.0   # Domain size
Nx, Ny = 64, 64     # Number of grid points in x and y (including boundaries)
dx = Lx / (Nx - 1)
dy = Ly / (Ny - 1)

# Create grid points
x = np.linspace(0, Lx, Nx)
y = np.linspace(0, Ly, Ny)

# Initialize fields: u, v, p
# All defined on collocated grid points (Ny x Nx)
u = np.zeros((Ny, Nx))
v = np.zeros((Ny, Nx))
p = np.zeros((Ny, Nx))

# -------------------------------
# Boundary Conditions Function
# -------------------------------
def apply_boundary_conditions(u, v):
    # Top boundary (y=1): u = alpha * x * (1 - x), v = 0
    u[-1, :] = alpha * x * (1 - x)
    v[-1, :] = 0.0

    # Left boundary (x=0): u = v = 0
    u[:, 0] = 0.0
    v[:, 0] = 0.0

    # Right boundary (x=1): u = v = 0
    u[:, -1] = 0.0
    v[:, -1] = 0.0

    # Bottom boundary (y=0): u = v = 0
    u[0, :] = 0.0
    v[0, :] = 0.0

# -------------------------------
# Helper Functions for Derivatives
# -------------------------------
def ddx(f):
    # Compute ∂f/∂x using central differences with one-sided at boundaries
    dfdx = np.zeros_like(f)
    dfdx[:, 1:-1] = (f[:, 2:] - f[:, :-2]) / (2 * dx)
    dfdx[:, 0] = (f[:, 1] - f[:, 0]) / dx
    dfdx[:, -1] = (f[:, -1] - f[:, -2]) / dx
    return dfdx

def ddy(f):
    # Compute ∂f/∂y using central differences with one-sided at boundaries
    dfdy = np.zeros_like(f)
    dfdy[1:-1, :] = (f[2:, :] - f[:-2, :]) / (2 * dy)
    dfdy[0, :] = (f[1, :] - f[0, :]) / dy
    dfdy[-1, :] = (f[-1, :] - f[-2, :]) / dy
    return dfdy

def laplacian(f):
    # Compute Laplacian ∆f using central differences
    lap = np.zeros_like(f)
    lap[1:-1,1:-1] = (
        (f[1:-1,2:] - 2*f[1:-1,1:-1] + f[1:-1,:-2]) / dx**2 +
        (f[2:,1:-1] - 2*f[1:-1,1:-1] + f[:-2,1:-1]) / dy**2
    )
    # For boundaries, set lap=0 (Dirichlet BCs override)
    return lap

# -------------------------------
# Hybrid Upwind-Central Convection Scheme (Explicit)
# -------------------------------
def hybrid_conv(f, u_vel, v_vel):
    # Compute convection term: u * ∂f/∂x + v * ∂f/∂y
    # Use upwind differencing depending on velocity sign to avoid non-physical oscillations
    conv = np.zeros_like(f)

    # x-direction convection
    conv_x = np.zeros_like(f)
    # For interior points (avoid wrap-around)
    conv_x[:, 1:-1] = np.where(
        u_vel[:, 1:-1] >= 0,
        u_vel[:, 1:-1] * (f[:, 1:-1] - f[:, :-2]) / dx,
        u_vel[:, 1:-1] * (f[:, 2:] - f[:, 1:-1]) / dx
    )
    # Boundaries: use one-sided differences
    # Left boundary (j=0)
    conv_x[:, 0] = u_vel[:, 0] * (f[:, 0] - f[:, 0]) / dx  # zero gradient (no convection)
    # Right boundary (j=-1)
    conv_x[:, -1] = u_vel[:, -1] * (f[:, -1] - f[:, -2]) / dx

    # y-direction convection
    conv_y = np.zeros_like(f)
    # For interior points
    conv_y[1:-1, :] = np.where(
        v_vel[1:-1, :] >= 0,
        v_vel[1:-1, :] * (f[1:-1, :] - f[:-2, :]) / dy,
        v_vel[1:-1, :] * (f[2:, :] - f[1:-1, :]) / dy
    )
    # Boundaries: use one-sided differences
    # Bottom boundary (i=0)
    conv_y[0, :] = v_vel[0, :] * (f[0, :] - f[0, :]) / dy  # zero gradient
    # Top boundary (i=-1)
    conv_y[-1, :] = v_vel[-1, :] * (f[-1, :] - f[-2, :]) / dy

    conv = conv_x + conv_y
    return conv

# -------------------------------
# Index Mapping for Pressure Correction (Internal Points)
# -------------------------------
def idx(i, j):
    # Map 2D internal pressure grid indices (i,j) to 1D index
    # i: y index in [1, Ny-2], j: x index in [1, Nx-2]
    return (i - 1) * (Nx - 2) + (j - 1)

# -------------------------------
# Build Sparse Matrix for Pressure Correction Poisson Equation
# -------------------------------
Ni = (Nx - 2) * (Ny - 2)  # Number of internal pressure points

data_p = []
rows_p = []
cols_p = []

for i in range(1, Ny-1):
    for j in range(1, Nx-1):
        row = idx(i, j)
        # Center coefficient
        coeff_center = -2.0 / dx**2 - 2.0 / dy**2
        rows_p.append(row)
        cols_p.append(row)
        data_p.append(coeff_center)

        # Left neighbor
        if j > 1:
            rows_p.append(row)
            cols_p.append(idx(i, j-1))
            data_p.append(1.0 / dx**2)
        # Right neighbor
        if j < Nx-2:
            rows_p.append(row)
            cols_p.append(idx(i, j+1))
            data_p.append(1.0 / dx**2)
        # Bottom neighbor
        if i > 1:
            rows_p.append(row)
            cols_p.append(idx(i-1, j))
            data_p.append(1.0 / dy**2)
        # Top neighbor
        if i < Ny-2:
            rows_p.append(row)
            cols_p.append(idx(i+1, j))
            data_p.append(1.0 / dy**2)

# Convert to CSR sparse matrix
A_p = sp.csr_matrix((data_p, (rows_p, cols_p)), shape=(Ni, Ni))

# To fix pressure correction at (0,0) (which corresponds to i=1,j=1 in internal grid),
# we enforce Dirichlet condition p_prime=0 by modifying matrix and RHS:
# This avoids singularity in pressure Poisson matrix.
fix_i, fix_j = 1, 1
fix_idx = idx(fix_i, fix_j)
# Modify row fix_idx to identity
A_p.data[A_p.indptr[fix_idx]:A_p.indptr[fix_idx+1]] = 0.0  # zero out row
A_p[fix_idx, fix_idx] = 1.0

# -------------------------------
# Build Diffusion Matrix for Velocity (Implicit Diffusion)
# -------------------------------
# 5-point Laplacian stencil with Dirichlet BCs (velocity fixed at boundaries)
Nuv = Nx * Ny  # total velocity points

data_uv = []
rows_uv = []
cols_uv = []

coef_dx2 = 1.0 / dx**2
coef_dy2 = 1.0 / dy**2

dt = 0.001  # pseudo time step for iteration stability

for i in range(Ny):
    for j in range(Nx):
        row = i * Nx + j
        if i == 0 or i == Ny-1 or j == 0 or j == Nx-1:
            # Boundary point: velocity fixed, diagonal=1
            data_uv.append(1.0)
            rows_uv.append(row)
            cols_uv.append(row)
        else:
            # Internal point: implicit diffusion
            diag = 1 + 2*dt/(Re*dx**2) + 2*dt/(Re*dy**2)
            data_uv.append(diag)
            rows_uv.append(row)
            cols_uv.append(row)

            # Left neighbor
            data_uv.append(-dt/(Re*dx**2))
            rows_uv.append(row)
            cols_uv.append(row - 1)

            # Right neighbor
            data_uv.append(-dt/(Re*dx**2))
            rows_uv.append(row)
            cols_uv.append(row + 1)

            # Bottom neighbor
            data_uv.append(-dt/(Re*dy**2))
            rows_uv.append(row)
            cols_uv.append(row - Nx)

            # Top neighbor
            data_uv.append(-dt/(Re*dy**2))
            rows_uv.append(row)
            cols_uv.append(row + Nx)

A_uv = sp.csr_matrix((data_uv, (rows_uv, cols_uv)), shape=(Nuv, Nuv))

# -------------------------------
# Main SIMPLE Iteration Loop
# -------------------------------
max_iter = 5000
tolerance = 1e-6
under_relax_u = 0.7
under_relax_v = 0.7
under_relax_p = 0.3

print_interval = 200

for it in range(1, max_iter + 1):
    # Save old values for residual calculation
    u_old = u.copy()
    v_old = v.copy()
    p_old = p.copy()

    # Apply velocity boundary conditions
    apply_boundary_conditions(u, v)

    # Compute convection terms with hybrid upwind-central scheme
    conv_u = hybrid_conv(u, u, v)
    conv_v = hybrid_conv(v, u, v)

    # Diffusion terms (implicit handled in linear system)
    # Pressure gradients
    dp_dx = ddx(p)
    dp_dy = ddy(p)

    # Right hand side for tentative velocity equations (explicit convection and pressure gradient)
    rhs_u = (u - dt * (conv_u + dp_dx)).flatten()
    rhs_v = (v - dt * (conv_v + dp_dy)).flatten()

    # Enforce velocity boundary conditions in RHS (fixed velocity at boundaries)
    for i in range(Ny):
        for j in range(Nx):
            idx_uv = i * Nx + j
            if i == 0 or i == Ny - 1 or j == 0 or j == Nx - 1:
                rhs_u[idx_uv] = u[i, j]
                rhs_v[idx_uv] = v[i, j]

    # Solve linear systems for tentative velocities u_star and v_star
    u_star_flat = spla.spsolve(A_uv, rhs_u)
    v_star_flat = spla.spsolve(A_uv, rhs_v)

    u_star = u_star_flat.reshape((Ny, Nx))
    v_star = v_star_flat.reshape((Ny, Nx))

    # Compute divergence of tentative velocity at internal pressure points (1:Ny-1,1:Nx-1)
    # Corrected shape to match pressure correction grid (Ny-2, Nx-2)
    div_u_star = ((u_star[1:-1, 1:] - u_star[1:-1, :-1]) / dx) + ((v_star[1:, 1:-1] - v_star[:-1, 1:-1]) / dy)

    # Build RHS for pressure correction Poisson equation: divergence / dt
    b_p = div_u_star.flatten()
    # Enforce pressure correction at reference point (0,0) = 0
    b_p[fix_idx] = 0.0

    # Solve pressure correction equation A_p * p_prime = b_p
    p_prime_flat = spla.spsolve(A_p, b_p)

    # Map p_prime_flat back to internal pressure grid
    p_prime = np.zeros_like(p)
    for i in range(1, Ny-1):
        for j in range(1, Nx-1):
            p_prime[i, j] = p_prime_flat[idx(i, j)]

    # Update pressure and velocities with under-relaxation
    p += under_relax_p * p_prime
    u = u_star - dt * ddx(p_prime)
    v = v_star - dt * ddy(p_prime)

    # Apply velocity boundary conditions again after correction
    apply_boundary_conditions(u, v)

    # Fix pressure reference at (0,0)
    p -= p[0, 0]

    # Compute residuals for convergence check
    res_u = np.linalg.norm(u - u_old) / np.sqrt(Nx * Ny)
    res_v = np.linalg.norm(v - v_old) / np.sqrt(Nx * Ny)
    res_p = np.linalg.norm(p - p_old) / np.sqrt(Nx * Ny)
    res_continuity = np.linalg.norm(div_u_star) / np.sqrt(Ni)
    res = max(res_u, res_v, res_p, res_continuity)

    if it % print_interval == 0 or it == 1:
        print(f"Iteration {it:5d}: Residual = {res:.3e} (u: {res_u:.3e}, v: {res_v:.3e}, p: {res_p:.3e}, continuity: {res_continuity:.3e})")

    if res < tolerance:
        print(f"Converged after {it} iterations with residual {res:.3e}")
        break
else:
    print(f"Did not converge after {max_iter} iterations, residual = {res:.3e}")

# -------------------------------
# Postprocessing and Plotting
# -------------------------------
# Compute velocity magnitude
vel_mag = np.sqrt(u**2 + v**2)

# Create meshgrid for plotting
X, Y = np.meshgrid(x, y)

# Plot contours of velocity magnitude and streamlines
plt.figure(figsize=(8, 6))
contour = plt.contourf(X, Y, vel_mag, levels=50, cmap='jet')
plt.colorbar(contour, label='Velocity magnitude')

# Stream function calculation by solving Poisson equation:
# ∇²ψ = - (∂v/∂x - ∂u/∂y)
# Discretize and solve with zero stream function at boundaries

# Compute vorticity (curl of velocity)
dvdx = ddx(v)
dudy = ddy(u)
omega = dvdx - dudy  # vorticity

# Build Laplacian matrix for stream function ψ on internal points
data_psi = []
rows_psi = []
cols_psi = []

for i in range(1, Ny-1):
    for j in range(1, Nx-1):
        row = idx(i, j)
        # Center coefficient
        rows_psi.append(row)
        cols_psi.append(row)
        data_psi.append(-2.0 / dx**2 - 2.0 / dy**2)

        # Left neighbor
        if j > 1:
            rows_psi.append(row)
            cols_psi.append(idx(i, j-1))
            data_psi.append(1.0 / dx**2)
        # Right neighbor
        if j < Nx-2:
            rows_psi.append(row)
            cols_psi.append(idx(i, j+1))
            data_psi.append(1.0 / dx**2)
        # Bottom neighbor
        if i > 1:
            rows_psi.append(row)
            cols_psi.append(idx(i-1, j))
            data_psi.append(1.0 / dy**2)
        # Top neighbor
        if i < Ny-2:
            rows_psi.append(row)
            cols_psi.append(idx(i+1, j))
            data_psi.append(1.0 / dy**2)

A_psi = sp.csr_matrix((data_psi, (rows_psi, cols_psi)), shape=(Ni, Ni))

# Right hand side: -omega at internal points
b_psi = -omega[1:-1, 1:-1].flatten()

# Enforce zero stream function at bottom-left corner (reference)
# Modify matrix row corresponding to (1,1) to identity and RHS=0
A_psi.data[A_psi.indptr[fix_idx]:A_psi.indptr[fix_idx+1]] = 0.0
A_psi[fix_idx, fix_idx] = 1.0
b_psi[fix_idx] = 0.0

# Solve for stream function ψ
psi_flat = spla.spsolve(A_psi, b_psi)

# Map back to 2D grid
psi = np.zeros_like(u)
for i in range(1, Ny-1):
    for j in range(1, Nx-1):
        psi[i, j] = psi_flat[idx(i, j)]

# Plot streamlines (contours of ψ)
streamlines = plt.contour(X, Y, psi, levels=30, colors='k', linewidths=0.7)

plt.title('Velocity Magnitude Contours and Streamlines (Lid-driven cavity)')
plt.xlabel('x')
plt.ylabel('y')
plt.tight_layout()
plt.savefig('navier_stokes_lid_driven_cavity.png')
# plt.show() is intentionally omitted as per instructions
```

****************************************
