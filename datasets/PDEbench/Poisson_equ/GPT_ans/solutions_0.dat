
****************************************
```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt

# ---------------------------
# Technical explanation:
# We solve the Laplace equation -Î”u = 0 on a square domain with four circular holes.
# The domain is discretized on a uniform Cartesian grid.
# Points inside holes are excluded from the computational domain.
# We use a 5-point finite difference stencil for the Laplacian.
# Dirichlet boundary conditions:
#   u=1 on outer square boundary,
#   u=0 on boundaries of the four circles (holes).
# The linear system is assembled as a sparse matrix and solved with a direct sparse solver.
# The solution is then reshaped and plotted with contours and circles.
# ---------------------------

# Domain parameters
L = 0.5  # half-length of square domain [-L, L]^2
r = 0.1  # radius of holes
centers = np.array([[0.3, 0.3],
                    [-0.3, 0.3],
                    [0.3, -0.3],
                    [-0.3, -0.3]])

# Grid parameters
N = 101  # number of points per dimension (odd for symmetry)
x = np.linspace(-L, L, N)
y = np.linspace(-L, L, N)
h = x[1] - x[0]  # grid spacing

X, Y = np.meshgrid(x, y, indexing='ij')

# Mask points inside holes
def inside_any_circle(x, y, centers, radius):
    for cx, cy in centers:
        if (x - cx)**2 + (y - cy)**2 <= radius**2:
            return True
    return False

# Vectorized mask for holes
dist_sq = np.min((X[..., None] - centers[:, 0])**2 + (Y[..., None] - centers[:, 1])**2, axis=2)
hole_mask = dist_sq <= r**2  # True inside holes

# Identify boundary points
# Outer boundary: points on edges of the square
outer_boundary_mask = np.zeros_like(X, dtype=bool)
outer_boundary_mask[0, :] = True
outer_boundary_mask[-1, :] = True
outer_boundary_mask[:, 0] = True
outer_boundary_mask[:, -1] = True

# Hole boundary points: points adjacent to hole_mask True points but themselves outside holes
# We define hole boundary as points outside holes but with at least one neighbor inside hole
hole_boundary_mask = np.zeros_like(X, dtype=bool)
for i in range(1, N-1):
    for j in range(1, N-1):
        if not hole_mask[i, j]:
            # Check 4 neighbors
            neighbors = [hole_mask[i+1, j], hole_mask[i-1, j], hole_mask[i, j+1], hole_mask[i, j-1]]
            if any(neighbors):
                hole_boundary_mask[i, j] = True

# Active computational domain points: outside holes and not on hole boundary or outer boundary
# We solve for interior points only (excluding all Dirichlet boundaries)
interior_mask = (~hole_mask) & (~outer_boundary_mask) & (~hole_boundary_mask)

# Number of unknowns
num_unknowns = np.sum(interior_mask)

print(f"Grid size: {N}x{N} = {N*N} points")
print(f"Number of points inside holes: {np.sum(hole_mask)}")
print(f"Number of outer boundary points: {np.sum(outer_boundary_mask)}")
print(f"Number of hole boundary points: {np.sum(hole_boundary_mask)}")
print(f"Number of unknown interior points: {num_unknowns}")

# Map 2D indices of interior points to 1D indices for linear system
index_map = -np.ones_like(X, dtype=int)
index_map[interior_mask] = np.arange(num_unknowns)

# Assemble sparse matrix A and right-hand side b
data = []
rows = []
cols = []
b = np.zeros(num_unknowns)

# Helper function to check if a point is Dirichlet boundary and get its value
def dirichlet_value(i, j):
    if outer_boundary_mask[i, j]:
        return 1.0
    elif hole_boundary_mask[i, j]:
        return 0.0
    else:
        return None  # Not Dirichlet

# Build matrix row by row for each interior unknown
for i in range(1, N-1):
    for j in range(1, N-1):
        if interior_mask[i, j]:
            row_idx = index_map[i, j]
            # Center coefficient
            diag = 0
            # Neighbors: (i+1,j), (i-1,j), (i,j+1), (i,j-1)
            neighbors = [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]
            for ni, nj in neighbors:
                if interior_mask[ni, nj]:
                    # Neighbor is unknown: add -1 to off-diagonal
                    rows.append(row_idx)
                    cols.append(index_map[ni, nj])
                    data.append(-1.0)
                    diag += 1
                else:
                    # Neighbor is Dirichlet boundary: add its value to RHS
                    val = dirichlet_value(ni, nj)
                    if val is None:
                        # Neighbor inside hole (masked), treat as Dirichlet zero (hole boundary)
                        val = 0.0
                    b[row_idx] += val
                    diag += 1
            # Diagonal entry
            rows.append(row_idx)
            cols.append(row_idx)
            data.append(diag)

# Construct sparse matrix A
A = sp.csr_matrix((data, (rows, cols)), shape=(num_unknowns, num_unknowns))

print("Sparse matrix A assembled.")
print(f"Matrix shape: {A.shape}")
print(f"Number of nonzeros in A: {A.nnz}")

# Solve linear system Au = b
print("Solving linear system...")
u_vec = spla.spsolve(A, b)
print("Linear system solved.")

# Compute residual norm ||Au - b||
residual = A.dot(u_vec) - b
res_norm = np.linalg.norm(residual)
print(f"Residual norm ||Au - b|| = {res_norm:.3e}")

# Reconstruct full solution grid including boundaries
U = np.zeros_like(X)
# Set Dirichlet boundaries
U[outer_boundary_mask] = 1.0
U[hole_boundary_mask] = 0.0
U[hole_mask] = np.nan  # Mark holes as NaN for plotting
# Set interior solution
U[interior_mask] = u_vec

# Plotting
fig, ax = plt.subplots(figsize=(7,7))
# Contour plot of solution u
# Mask holes for plotting by setting NaN
contour = ax.contourf(X, Y, U, levels=50, cmap='jet', extend='both')

# Plot circles representing holes
theta = np.linspace(0, 2*np.pi, 200)
for cx, cy in centers:
    x_circ = cx + r * np.cos(theta)
    y_circ = cy + r * np.sin(theta)
    ax.plot(x_circ, y_circ, 'k-', linewidth=1.5)

ax.set_aspect('equal')
ax.set_title('Solution u of Laplace equation with four circular holes')
ax.set_xlabel('x')
ax.set_ylabel('y')
cbar = fig.colorbar(contour, ax=ax)
cbar.set_label('u')

plt.tight_layout()
plt.savefig('laplace_2d_circles_solution.png')
# plt.show() is omitted as per instructions

# Print summary of solution values
print(f"Solution u statistics (excluding holes):")
print(f"  min u = {np.nanmin(U):.4f}")
print(f"  max u = {np.nanmax(U):.4f}")
print(f"  mean u = {np.nanmean(U):.4f}")
```

****************************************
