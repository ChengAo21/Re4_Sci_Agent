
****************************************
```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt
from scipy.ndimage import binary_dilation

# ---------------------------
# Technical explanation:
# We solve the 2D Laplace equation -Î”u = 0 on a square domain [-0.5,0.5]^2 with four circular holes removed.
# Dirichlet boundary conditions:
#   u = 1 on the outer square boundary,
#   u = 0 on the boundaries of the four circular holes.
#
# The domain is discretized on a uniform Cartesian grid.
# Points inside holes are excluded from the computational domain.
# The hole boundaries are identified by morphological dilation to efficiently find boundary points.
# A 5-point finite difference stencil is used to discretize the Laplacian.
# The linear system is assembled as a sparse matrix and solved with a direct sparse solver.
# The solution is reconstructed on the full grid and visualized with contour plots.
# Circles representing holes are overlaid on the plot.
# ---------------------------

def create_domain_and_masks(L, r, centers, N):
    # Create uniform grid
    x = np.linspace(-L, L, N)
    y = np.linspace(-L, L, N)
    h = x[1] - x[0]
    X, Y = np.meshgrid(x, y, indexing='ij')

    # Vectorized mask for points inside any hole
    dist_sq = np.min((X[..., None] - centers[:, 0])**2 + (Y[..., None] - centers[:, 1])**2, axis=2)
    hole_mask = dist_sq <= r**2  # True inside holes

    # Outer boundary mask: points on edges of the square
    outer_boundary_mask = np.zeros_like(X, dtype=bool)
    outer_boundary_mask[0, :] = True
    outer_boundary_mask[-1, :] = True
    outer_boundary_mask[:, 0] = True
    outer_boundary_mask[:, -1] = True

    # Hole boundary mask: points outside holes but adjacent to hole points
    # Use binary dilation to find neighbors of hole points
    hole_dilated = binary_dilation(hole_mask, structure=np.array([[0,1,0],[1,1,1],[0,1,0]]))
    hole_boundary_mask = hole_dilated & (~hole_mask)

    # Interior points: not in holes, not on outer boundary, not on hole boundary
    interior_mask = (~hole_mask) & (~outer_boundary_mask) & (~hole_boundary_mask)

    return X, Y, h, hole_mask, outer_boundary_mask, hole_boundary_mask, interior_mask

def assemble_system(interior_mask, hole_boundary_mask, outer_boundary_mask, N):
    # Map 2D indices of interior points to 1D indices for linear system
    num_unknowns = np.sum(interior_mask)
    index_map = -np.ones((N, N), dtype=int)
    index_map[interior_mask] = np.arange(num_unknowns)

    data = []
    rows = []
    cols = []
    b = np.zeros(num_unknowns)

    # Helper function to get Dirichlet value at boundary points
    def dirichlet_value(i, j):
        if outer_boundary_mask[i, j]:
            return 1.0
        elif hole_boundary_mask[i, j]:
            return 0.0
        else:
            return None  # Not Dirichlet

    # Assemble matrix A and RHS vector b
    for i in range(1, N-1):
        for j in range(1, N-1):
            if interior_mask[i, j]:
                row_idx = index_map[i, j]
                diag = 0
                neighbors = [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]
                for ni, nj in neighbors:
                    if interior_mask[ni, nj]:
                        # Neighbor is unknown: off-diagonal -1
                        rows.append(row_idx)
                        cols.append(index_map[ni, nj])
                        data.append(-1.0)
                        diag += 1
                    else:
                        # Neighbor is Dirichlet boundary or inside hole (treated as zero)
                        val = dirichlet_value(ni, nj)
                        if val is None:
                            val = 0.0
                        b[row_idx] += val
                        diag += 1
                # Diagonal entry
                rows.append(row_idx)
                cols.append(row_idx)
                data.append(diag)

    A = sp.csr_matrix((data, (rows, cols)), shape=(num_unknowns, num_unknowns))
    return A, b, index_map, num_unknowns

def solve_laplace(A, b):
    print("Solving linear system...")
    u_vec = spla.spsolve(A, b)
    print("Linear system solved.")
    residual = A.dot(u_vec) - b
    res_norm = np.linalg.norm(residual)
    print(f"Residual norm ||Au - b|| = {res_norm:.3e}")
    return u_vec, res_norm

def reconstruct_solution(u_vec, index_map, outer_boundary_mask, hole_boundary_mask, hole_mask, N):
    U = np.zeros((N, N))
    # Set Dirichlet boundaries
    U[outer_boundary_mask] = 1.0
    U[hole_boundary_mask] = 0.0
    U[hole_mask] = np.nan  # Mark holes as NaN for plotting
    # Set interior solution
    interior_indices = np.where(index_map >= 0)
    U[interior_indices] = u_vec[index_map[interior_indices]]
    return U

def plot_solution(X, Y, U, centers, r, L):
    fig, ax = plt.subplots(figsize=(7,7))
    contour = ax.contourf(X, Y, U, levels=50, cmap='jet', extend='both')
    # Overlay circles representing holes
    theta = np.linspace(0, 2*np.pi, 200)
    for cx, cy in centers:
        x_circ = cx + r * np.cos(theta)
        y_circ = cy + r * np.sin(theta)
        ax.plot(x_circ, y_circ, 'k-', linewidth=1.5)
    ax.set_aspect('equal')
    ax.set_xlim(-L, L)
    ax.set_ylim(-L, L)
    ax.set_title('Solution u of Laplace equation with four circular holes')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    cbar = fig.colorbar(contour, ax=ax)
    cbar.set_label('u')
    plt.tight_layout()
    plt.savefig('laplace_2d_circles_solution.png')
    # plt.show() omitted as per instructions

def print_solution_statistics(U):
    print("Solution u statistics (excluding holes):")
    print(f"  min u = {np.nanmin(U):.4f}")
    print(f"  max u = {np.nanmax(U):.4f}")
    print(f"  mean u = {np.nanmean(U):.4f}")

def main():
    # Domain parameters
    L = 0.5  # half-length of square domain [-L, L]^2
    r = 0.1  # radius of holes
    centers = np.array([[0.3, 0.3],
                        [-0.3, 0.3],
                        [0.3, -0.3],
                        [-0.3, -0.3]])
    # Grid parameters
    N = 101  # number of points per dimension (odd for symmetry)

    print(f"Grid size: {N}x{N} = {N*N} points")

    # Create domain and masks
    X, Y, h, hole_mask, outer_boundary_mask, hole_boundary_mask, interior_mask = create_domain_and_masks(L, r, centers, N)

    print(f"Number of points inside holes: {np.sum(hole_mask)}")
    print(f"Number of outer boundary points: {np.sum(outer_boundary_mask)}")
    print(f"Number of hole boundary points: {np.sum(hole_boundary_mask)}")
    print(f"Number of unknown interior points: {np.sum(interior_mask)}")

    # Assemble linear system
    A, b, index_map, num_unknowns = assemble_system(interior_mask, hole_boundary_mask, outer_boundary_mask, N)

    print("Sparse matrix A assembled.")
    print(f"Matrix shape: {A.shape}")
    print(f"Number of nonzeros in A: {A.nnz}")

    # Solve system
    u_vec, res_norm = solve_laplace(A, b)

    # Reconstruct full solution grid
    U = reconstruct_solution(u_vec, index_map, outer_boundary_mask, hole_boundary_mask, hole_mask, N)

    # Print solution statistics
    print_solution_statistics(U)

    # Plot solution
    plot_solution(X, Y, U, centers, r, L)

if __name__ == "__main__":
    main()
```

****************************************
