
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from scipy.sparse import lil_matrix
from scipy.sparse.linalg import cg # Using cg as it's suitable for SPD systems and allows atol
import time

# Technical explanation for the solving algorithm.
# The problem involves solving the 2D Laplace equation, -Δu = 0, on a complex domain
# which is a square with four circular holes. Dirichlet boundary conditions are
# specified: u=1 on the outer square boundary and u=0 on the boundaries of the holes.
#
# Algorithm: Finite Difference Method (FDM) on a Cartesian Grid with Masking
#
# 1. Discretization:
#    The continuous domain [-0.5, 0.5]^2 is discretized into a uniform Cartesian grid
#    with (N+1)x(N+1) points. The grid spacing is h = 1.0 / N.
#
# 2. Grid Point Classification:
#    Each grid point (x_i, y_j) is classified into one of three categories:
#    a. Outer Boundary Points: Points lying on the perimeter of the square [-0.5, 0.5]^2.
#       For these points, the solution u is fixed to 1, as per the Dirichlet boundary condition.
#    b. Hole Points: Points lying inside or exactly on the boundary of any of the four
#       circular holes. These points are considered "removed" from the computational domain.
#       However, in the FDM implementation, we treat them as points with fixed Dirichlet
#       values (u=0), effectively imposing the boundary condition on the staircase
#       approximation of the circular boundaries.
#    c. Unknown (Interior) Points: All other points that are neither on the outer boundary
#       nor inside a hole. These are the points for which the solution u needs to be found.
#
# 3. Finite Difference Stencil:
#    For each unknown point (i, j), the Laplace equation -Δu = 0 is approximated using
#    the standard 5-point central difference stencil:
#    - (u_{i+1,j} - 2u_{i,j} + u_{i-1,j}) / h^2 - (u_{i,j+1} - 2u_{i,j} + u_{i,j-1}) / h^2 = 0
#    Multiplying by -h^2 and rearranging, we get:
#    4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = 0
#
# 4. System Assembly:
#    This equation is applied to every unknown point. This generates a system of linear
#    equations of the form Au = b, where:
#    - A is a sparse matrix representing the discretized Laplacian operator.
#    - u is a vector containing the unknown values of u at the interior grid points.
#    - b is a vector containing contributions from the known boundary conditions (outer
#      square boundary and hole boundaries).
#    Specifically, for each unknown point (i, j) mapped to a 1D index k:
#    - The diagonal element A[k, k] is 4.
#    - For each neighbor (ni, nj) of (i, j):
#      - If (ni, nj) is also an unknown point, A[k, map_to_1D_index(ni, nj)] is -1.
#      - If (ni, nj) is a known boundary point (outer or hole), its value (1 or 0)
#        is moved to the right-hand side vector b[k].
#    The matrix A is highly sparse, making sparse matrix solvers efficient.
#
# 5. Solving the Linear System:
#    The sparse linear system Au = b is solved using an iterative solver from `scipy.sparse.linalg`.
#    The Conjugate Gradient (CG) method is chosen because the matrix A resulting from the
#    discretized Laplace operator is symmetric and positive definite. CG is an efficient
#    iterative method for such systems.
#    The `tol` and `atol` parameters are used to control the convergence criteria of the
#    iterative solver. `atol` is explicitly used as requested to avoid potential `TypeError`
#    issues with `tol` in some contexts, although `cg` supports both.
#
# 6. Post-processing and Visualization:
#    The 1D solution vector is reshaped back into the 2D grid structure.
#    The solution u is then visualized using `matplotlib.pyplot.contourf` to show the
#    potential distribution. The circular holes are overlaid on the plot for clarity.
#    The 'jet' colormap is used as requested.
#
# Advantages of FDM for this problem:
# - Simplicity: Relatively straightforward to implement compared to FEM or BIM.
# - Standard Libraries: Leverages `numpy` for array operations and `scipy.sparse.linalg`
#   for efficient sparse linear system solving.
#
# Limitations:
# - Staircase Approximation: The circular boundaries are approximated by the grid lines,
#   leading to a "staircase" effect. This can reduce accuracy near the boundaries
#   compared to methods that use body-fitted meshes (like FEM).
# - Grid Resolution: Higher accuracy requires finer grids, which increases the number
#   of unknowns and computational cost.

def solve_poisson_2d_with_holes(N=100):
    # Problem parameters
    x_min, x_max = -0.5, 0.5
    y_min, y_max = -0.5, 0.5
    radius = 0.1
    circle_centers = [
        (0.3, 0.3),
        (-0.3, 0.3),
        (0.3, -0.3),
        (-0.3, -0.3)
    ]

    # Grid setup
    h = (x_max - x_min) / N  # Grid spacing
    x = np.linspace(x_min, x_max, N + 1)
    y = np.linspace(y_min, y_max, N + 1)
    X, Y = np.meshgrid(x, y)

    # Initialize solution array
    # u will store the solution values on the grid.
    # Known boundary conditions will be set directly.
    u = np.zeros((N + 1, N + 1))

    # Identify grid points and apply boundary conditions
    # is_outer_boundary: True for points on the square's perimeter, using np.isclose for float comparison.
    is_outer_boundary = (np.isclose(X, x_min) | np.isclose(X, x_max) |
                         np.isclose(Y, y_min) | np.isclose(Y, y_max))
    u[is_outer_boundary] = 1.0  # u = 1 on outer boundary

    # is_inside_hole: True for points inside or on the boundary of any of the four circles.
    is_inside_hole = np.zeros((N + 1, N + 1), dtype=bool)
    for cx, cy in circle_centers:
        is_inside_hole |= ((X - cx)**2 + (Y - cy)**2 <= radius**2)
    u[is_inside_hole] = 0.0  # u = 0 inside holes (effectively on hole boundaries)

    # is_unknown: True for points where u needs to be solved for.
    # These are points not on the outer boundary and not inside any hole.
    is_unknown = ~(is_outer_boundary | is_inside_hole)

    # Map 2D (i, j) indices of unknown points to a 1D index k for the linear system.
    # unknown_coords: List of (i, j) tuples for unknown points.
    # idx_map: Dictionary mapping (i, j) -> k.
    idx_map = {}
    unknown_coords = []
    k = 0
    for i in range(N + 1):
        for j in range(N + 1):
            if is_unknown[i, j]:
                idx_map[(i, j)] = k
                unknown_coords.append((i, j))
                k += 1

    num_unknowns = len(unknown_coords)

    # Print solving information
    print("--- Problem Setup Information ---")
    print(f"Grid resolution (N): {N}")
    print(f"Grid spacing (h): {h:.4f}")
    print(f"Total grid points: {(N+1)*(N+1)}")
    print(f"Number of unknown points (equations): {num_unknowns}")
    print(f"Number of outer boundary points: {np.sum(is_outer_boundary)}")
    print(f"Number of hole points: {np.sum(is_inside_hole)}")
    print("---------------------------------")

    # Assemble the linear system Au = b
    # A: Sparse matrix for the discretized Laplacian operator.
    # b: Right-hand side vector containing boundary condition contributions.
    start_assembly_time = time.time()
    A = lil_matrix((num_unknowns, num_unknowns))
    b = np.zeros(num_unknowns)

    # Define neighbors for 5-point stencil (relative indices)
    neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1)] # (di, dj) for (i+di, j+dj)

    for k_1d, (i, j) in enumerate(unknown_coords):
        A[k_1d, k_1d] = 4.0  # Diagonal term for 4u_ij

        for di, dj in neighbors:
            ni, nj = i + di, j + dj  # Neighbor coordinates

            # Check if neighbor is within grid bounds (should always be true for neighbors of unknown points)
            # and if it's an unknown point or a known boundary point.
            if is_unknown[ni, nj]:
                # Neighbor is also an unknown point, add to matrix A
                A[k_1d, idx_map[(ni, nj)]] = -1.0
            else:
                # Neighbor is a known boundary point (outer or hole), add its value to RHS b
                b[k_1d] += u[ni, nj]

    A = A.tocsr()  # Convert to CSR format for efficient matrix-vector products (for CG)
    end_assembly_time = time.time()
    assembly_time = end_assembly_time - start_assembly_time

    print("\n--- Solver Information ---")
    print(f"Matrix A dimensions: {A.shape[0]}x{A.shape[1]}")
    print(f"Matrix A non-zero elements: {A.nnz}")
    print(f"Matrix A sparsity: {A.nnz / (A.shape[0] * A.shape[1]) * 100:.2f}%")
    print(f"Time taken for system assembly: {assembly_time:.4f} seconds")

    # Solve the linear system using Conjugate Gradient (CG)
    start_solve_time = time.time()
    # Using 'atol' as requested. 'tol' is for relative tolerance, 'atol' for absolute.
    # The solver stops when norm(residual) <= max(tol * norm(b), atol).
    # Setting atol to a small positive value ensures convergence even if norm(b) is very small.
    u_flat, info = cg(A, b, tol=1e-6, atol=1e-8)
    end_solve_time = time.time()
    solve_time = end_solve_time - start_solve_time

    # Check solver convergence
    if info == 0:
        print("CG solver converged successfully.")
    else:
        print(f"CG solver did NOT converge. Exit code: {info} (number of iterations).")

    # Calculate residual norm for reliability check
    residual_norm = np.linalg.norm(A @ u_flat - b)
    print(f"Time taken for solving: {solve_time:.4f} seconds")
    print(f"Final residual norm (||Au - b||): {residual_norm:.2e}")
    print("--------------------------")

    # Map the 1D solution vector back to the 2D grid
    for k_1d, (i, j) in enumerate(unknown_coords):
        u[i, j] = u_flat[k_1d]

    # Print solution statistics
    print("\n--- Solution Statistics ---")
    print(f"Minimum value of u: {np.min(u):.4f}")
    print(f"Maximum value of u: {np.max(u):.4f}")
    print("---------------------------")

    # Plotting the results
    plt.figure(figsize=(10, 8))
    # Contour plot of u
    # Use 50 levels for smoother contours, and 'jet' colormap as requested.
    contour_levels = np.linspace(0, 1, 50)
    contourf_plot = plt.contourf(X, Y, u, levels=contour_levels, cmap='jet', extend='both')
    plt.colorbar(contourf_plot, label='Potential u')

    # Mark the circles
    for cx, cy in circle_centers:
        # Draw the circle boundary
        circle_boundary = Circle((cx, cy), radius, color='black', fill=False, linestyle='--', linewidth=2)
        plt.gca().add_patch(circle_boundary)
        # Fill the interior of the circles with a distinct color (e.g., lightgrey)
        # to visually represent the removed domain/fixed zero potential.
        circle_fill = Circle((cx, cy), radius, color='lightgrey', alpha=0.7)
        plt.gca().add_patch(circle_fill)

    plt.title('2D Laplace Equation Solution with Holes')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.gca().set_aspect('equal', adjustable='box') # Ensure aspect ratio is equal
    plt.xlim(x_min, x_max)
    plt.ylim(y_min, y_max)
    
    # Create a custom legend entry for the circles to avoid multiple entries
    circle_legend_patch = Circle((0,0), 0, color='black', fill=False, linestyle='--', linewidth=2)
    plt.legend([circle_legend_patch], ['Hole Boundary'], loc='upper right')
    plt.grid(True, linestyle=':', alpha=0.7)

    # Save the figure
    plt.savefig('poisson_2d_solution.png', dpi=300, bbox_inches='tight')
    # Do not use plt.show() as requested.

# Main execution block
if __name__ == "__main__":
    # Set grid resolution. N=100 means 101x101 grid points.
    # Higher N leads to more accurate results but longer computation times.
    solve_poisson_2d_with_holes(N=100)
```
****************************************
