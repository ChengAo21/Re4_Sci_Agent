
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt

# Technical explanation:
# This code solves the 1D Euler equations for the Sod shock tube problem using a first-order
# Godunov-type Finite Volume Method (FVM) with the HLL approximate Riemann solver.
# The conserved variables are updated explicitly in time with a forward Euler scheme.
# Zero-gradient (outflow) boundary conditions are applied via ghost cells.
# The CFL condition dynamically controls the time step for stability.
# Positivity checks ensure physical consistency of density and pressure.
# The code is modularized with clear state conversions and flux computations.
# Detailed diagnostics are printed after the simulation.
# The HLL flux computation is done in a loop due to conditional logic complexity.
# The code is optimized by vectorizing all other operations and careful array handling.

gamma = 1.4  # Ratio of specific heats

def U_to_W(U):
    # Convert conserved variables U = [rho, rho*u, rho*E] to primitive variables W = [rho, u, p]
    rho = U[0]
    # Avoid division by zero by enforcing a small floor on density
    rho_safe = np.maximum(rho, 1e-12)
    u = U[1] / rho_safe
    E = U[2] / rho_safe
    p = (gamma - 1.0) * rho * (E - 0.5 * u**2)
    # Enforce small floor on pressure to avoid numerical issues
    p = np.maximum(p, 1e-12)
    return np.array([rho, u, p])

def W_to_U(W):
    # Convert primitive variables W = [rho, u, p] to conserved variables U = [rho, rho*u, rho*E]
    rho, u, p = W
    E = 0.5 * u**2 + p / ((gamma - 1.0) * rho)
    return np.array([rho, rho * u, rho * E])

def flux(U):
    # Compute physical flux F(U) = [rho*u, rho*u^2 + p, (rho*E + p)*u]
    W = U_to_W(U)
    rho, u, p = W
    return np.array([
        rho * u,
        rho * u**2 + p,
        (U[2] + p) * u
    ])

def HLL_flux(U_L, U_R):
    # Compute HLL approximate Riemann flux between left and right states U_L and U_R
    W_L = U_to_W(U_L)
    W_R = U_to_W(U_R)

    rho_L, u_L, p_L = W_L
    rho_R, u_R, p_R = W_R

    c_L = np.sqrt(gamma * p_L / rho_L)
    c_R = np.sqrt(gamma * p_R / rho_R)

    s_L = min(u_L - c_L, u_R - c_R, 0.0)
    s_R = max(u_L + c_L, u_R + c_R, 0.0)

    F_L = flux(U_L)
    F_R = flux(U_R)

    if s_L >= 0:
        return F_L
    elif s_R <= 0:
        return F_R
    else:
        return (s_R * F_L - s_L * F_R + s_L * s_R * (U_R - U_L)) / (s_R - s_L)

def initialize(N):
    # Initialize grid and conserved variables for Sod shock tube initial condition
    x_start, x_end = 0.0, 1.0
    dx = (x_end - x_start) / N
    x = (np.arange(N) + 0.5) * dx  # cell centers

    U = np.zeros((3, N))  # conserved variables array

    # Vectorized initialization of primitive variables
    rho = np.where(x <= 0.5, 1.0, 0.125)
    u = np.zeros_like(x)
    p = np.where(x <= 0.5, 1.0, 0.1)

    for i in range(N):
        U[:, i] = W_to_U(np.array([rho[i], u[i], p[i]]))
    return x, dx, U

def apply_boundary(U):
    # Apply zero-gradient (outflow) boundary conditions using ghost cells
    # U shape: (3, N)
    U_ext = np.zeros((3, U.shape[1] + 2))
    U_ext[:, 1:-1] = U
    U_ext[:, 0] = U[:, 0]      # left ghost cell = first cell
    U_ext[:, -1] = U[:, -1]    # right ghost cell = last cell
    return U_ext

def max_wave_speed(U):
    # Compute maximum wave speed max(|u| + c) over all cells for CFL condition
    rho = U[0, :]
    rho_safe = np.maximum(rho, 1e-12)
    u = U[1, :] / rho_safe
    E = U[2, :] / rho_safe
    p = (gamma - 1.0) * rho * (E - 0.5 * u**2)
    p = np.maximum(p, 1e-12)
    c = np.sqrt(gamma * p / rho_safe)
    return np.max(np.abs(u) + c)

def positivity_check(U):
    # Check positivity of density and pressure; raise error if violated
    rho = U[0, :]
    u = U[1, :] / np.maximum(rho, 1e-12)
    E = U[2, :] / np.maximum(rho, 1e-12)
    p = (gamma - 1.0) * rho * (E - 0.5 * u**2)
    if np.any(rho <= 0):
        raise ValueError("Non-positive density detected!")
    if np.any(p <= 0):
        raise ValueError("Non-positive pressure detected!")

def solve_euler(N=200, t_final=0.2, CFL=0.9):
    # Main solver function for Euler equations using first-order Godunov + HLL flux
    x, dx, U = initialize(N)
    t = 0.0

    while t < t_final:
        U_ext = apply_boundary(U)

        # Prepare left and right states at interfaces
        U_L = U_ext[:, :-1]  # shape (3, N+1)
        U_R = U_ext[:, 1:]   # shape (3, N+1)

        # Compute fluxes at all interfaces using HLL flux in a loop
        fluxes = np.zeros_like(U_L)
        for i in range(U_L.shape[1]):
            fluxes[:, i] = HLL_flux(U_L[:, i], U_R[:, i])

        max_speed = max_wave_speed(U)
        dt = CFL * dx / max_speed
        if t + dt > t_final:
            dt = t_final - t

        # Update conserved variables using finite volume update
        U = U - (dt / dx) * (fluxes[:, 1:] - fluxes[:, :-1])

        # Positivity check for physical consistency
        positivity_check(U)

        t += dt

    # Convert final conserved variables to primitive variables for plotting
    rho = U[0, :]
    u = U[1, :] / rho
    E = U[2, :] / rho
    p = (gamma - 1.0) * rho * (E - 0.5 * u**2)

    # Detailed diagnostics printing
    print(f"Final simulation time: t = {t:.5f}")
    print(f"Density: min = {rho.min():.5f}, max = {rho.max():.5f}")
    print(f"Velocity: min = {u.min():.5f}, max = {u.max():.5f}")
    print(f"Pressure: min = {p.min():.5f}, max = {p.max():.5f}")

    return x, rho, u, p

# Run solver and plot results
x, rho, u, p = solve_euler()

plt.figure(figsize=(10, 6))
plt.plot(x, rho, label='Density $\\rho$', color='blue')
plt.plot(x, u, label='Velocity $u$', color='red')
plt.plot(x, p, label='Pressure $p$', color='green')
plt.xlabel('x')
plt.title('Sod Shock Tube Solution at $t=0.2$ (First-order Godunov with HLL)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
```
****************************************
