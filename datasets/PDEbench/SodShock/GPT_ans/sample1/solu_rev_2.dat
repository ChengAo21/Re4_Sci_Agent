
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt

# Technical explanation:
# This code solves the 1D Euler equations for compressible gas dynamics using a Finite Volume Method (FVM)
# with the HLLC approximate Riemann solver. The Euler equations represent conservation of mass, momentum,
# and energy. The HLLC solver accurately captures shocks, contact discontinuities, and rarefactions,
# which are characteristic features of the Sod shock tube problem.
#
# The spatial domain [0,1] is discretized into uniform cells. Conserved variables are updated explicitly
# in time using flux differences at cell interfaces. The time step is dynamically computed based on the CFL
# condition and maximum wave speeds to ensure stability.
#
# Transmissive (zero-gradient) boundary conditions are applied via ghost cells.
#
# The code is modular, with clear functions for variable conversions, flux computations, boundary conditions,
# and time stepping. The flux computation loop remains explicit due to conditional logic in the HLLC solver.
#
# The final solution at t=0.2 is plotted showing density, velocity, and pressure profiles.

# Physical constants and parameters
gamma = 1.4  # Ratio of specific heats for ideal diatomic gas
nx = 400    # Number of spatial cells
x_start, x_end = 0.0, 1.0  # Domain limits
CFL = 0.6   # CFL number for stability
t_final = 0.2  # Final simulation time

# Spatial discretization
dx = (x_end - x_start) / nx
x = np.linspace(x_start + 0.5*dx, x_end - 0.5*dx, nx)  # Cell centers

# Initialize primitive variables according to Sod shock tube initial condition
rho_init = np.where(x <= 0.5, 1.0, 0.125)
u_init = np.zeros_like(x)
p_init = np.where(x <= 0.5, 1.0, 0.1)

def primitive_to_conserved(rho, u, p):
    # Convert primitive variables (rho, u, p) to conserved variables U = [rho, rho*u, rho*E].
    # E = total energy per unit mass = internal + kinetic energy.
    E = p / (gamma - 1) / rho + 0.5 * u**2
    U = np.empty((3, rho.size))
    U[0] = rho
    U[1] = rho * u
    U[2] = rho * E
    return U

def conserved_to_primitive(U):
    # Convert conserved variables U = [rho, rho*u, rho*E] to primitive variables (rho, u, p).
    rho = U[0]
    u = U[1] / rho
    E = U[2] / rho
    p = (gamma - 1) * rho * (E - 0.5 * u**2)
    return rho, u, p

def flux(U):
    # Compute flux vector F(U) for Euler equations given conserved variables U.
    # F = [rho*u, rho*u^2 + p, u*(rho*E + p)]
    rho, u, p = conserved_to_primitive(U)
    F = np.empty_like(U)
    F[0] = rho * u
    F[1] = rho * u**2 + p
    F[2] = u * (U[2] + p)
    return F

def sound_speed(p, rho):
    # Compute local sound speed a = sqrt(gamma * p / rho).
    return np.sqrt(gamma * p / rho)

def HLLC_flux(UL, UR):
    # Compute the HLLC flux at the interface between left state UL and right state UR.
    # UL, UR: conserved variables arrays of shape (3,)
    # Returns flux vector of shape (3,).

    # Left state primitives and sound speed
    rhoL, uL, pL = conserved_to_primitive(UL)
    aL = sound_speed(pL, rhoL)
    HL = (UL[2] + pL) / rhoL  # total enthalpy

    # Right state primitives and sound speed
    rhoR, uR, pR = conserved_to_primitive(UR)
    aR = sound_speed(pR, rhoR)
    HR = (UR[2] + pR) / rhoR

    # Estimate wave speeds SL and SR using Davis' estimates
    SL = min(uL - aL, uR - aR)
    SR = max(uL + aL, uR + aR)

    # Compute contact wave speed S_star
    numerator = pR - pL + rhoL * uL * (SL - uL) - rhoR * uR * (SR - uR)
    denominator = rhoL * (SL - uL) - rhoR * (SR - uR)
    S_star = numerator / denominator

    # Fluxes for left and right states
    FL = flux(UL)
    FR = flux(UR)

    def U_star(U, S, S_star):
        # Compute star region conserved variables given state U, wave speed S, and contact speed S_star.
        rho, u, p = conserved_to_primitive(U)
        factor = rho * (S - u) / (S - S_star)
        E = U[2] / rho
        U_s = np.empty(3)
        U_s[0] = factor
        U_s[1] = factor * S_star
        U_s[2] = factor * (E + (S_star - u) * (S_star + p / (rho * (S - u))))
        return U_s

    # HLLC flux selection based on wave speeds
    if 0 <= SL:
        return FL
    elif SL <= 0 <= S_star:
        U_starL = U_star(UL, SL, S_star)
        return FL + SL * (U_starL - UL)
    elif S_star <= 0 <= SR:
        U_starR = U_star(UR, SR, S_star)
        return FR + SR * (U_starR - UR)
    else:
        return FR

def apply_boundary_conditions(U):
    # Apply transmissive (zero-gradient) boundary conditions by extending U with ghost cells.
    # Returns extended array U_ext of shape (3, nx+2).
    U_ext = np.zeros((3, nx + 2))
    U_ext[:, 1:-1] = U
    U_ext[:, 0] = U[:, 0]      # Left ghost cell copies first interior cell
    U_ext[:, -1] = U[:, -1]    # Right ghost cell copies last interior cell
    return U_ext

def compute_time_step(U):
    # Compute time step dt based on CFL condition and maximum wave speed in the domain.
    rho, u, p = conserved_to_primitive(U)
    a = sound_speed(p, rho)
    max_speed = np.max(np.abs(u) + a)
    dt = CFL * dx / max_speed
    return dt

def solve_euler():
    # Main solver function: initializes variables, performs time integration,
    # and returns primitive variables at final time.

    # Initialize conserved variables
    U = primitive_to_conserved(rho_init, u_init, p_init)

    t = 0.0
    U_curr = U.copy()

    # Time integration loop
    while t < t_final:
        # Apply boundary conditions
        U_ext = apply_boundary_conditions(U_curr)

        # Compute fluxes at interfaces
        F_half = np.zeros((3, nx + 1))
        for i in range(nx + 1):
            UL = U_ext[:, i]
            UR = U_ext[:, i + 1]
            F_half[:, i] = HLLC_flux(UL, UR)

        # Compute time step
        dt = compute_time_step(U_curr)
        if t + dt > t_final:
            dt = t_final - t

        # Update conserved variables using finite volume update
        U_next = U_curr - dt / dx * (F_half[:, 1:] - F_half[:, :-1])

        # Update time and solution
        t += dt
        U_curr = U_next

    # Recover primitive variables at final time
    rho, u, p = conserved_to_primitive(U_curr)
    return rho, u, p, x, t

def plot_results(rho, u, p, x, t):
    # Plot density, velocity, and pressure profiles at time t.
    plt.figure(figsize=(10, 6))
    plt.plot(x, rho, label=r'Density $\rho$', linewidth=1.5)
    plt.plot(x, u, label=r'Velocity $u$', linewidth=1.5)
    plt.plot(x, p, label=r'Pressure $p$', linewidth=1.5)
    plt.xlabel('x')
    plt.title(f'Sod Shock Tube Solution at t = {t:.3f}')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

def print_summary(rho, u, p, t):
    # Print summary statistics of the solution at final time.
    print(f"Solution summary at t = {t:.3f}:")
    print(f"Density: min = {rho.min():.4f}, max = {rho.max():.4f}")
    print(f"Velocity: min = {u.min():.4f}, max = {u.max():.4f}")
    print(f"Pressure: min = {p.min():.4f}, max = {p.max():.4f}")

if __name__ == "__main__":
    # Run solver
    rho, u, p, x, t = solve_euler()

    # Print solution summary
    print_summary(rho, u, p, t)

    # Plot results
    plot_results(rho, u, p, x, t)
```

****************************************
