
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt

# Technical explanation:
# We solve the 1D Euler equations using a Finite Volume Method (FVM) with the HLLC approximate Riemann solver.
# This approach balances accuracy and computational efficiency, capturing shocks and contact discontinuities well.
# The domain [0,1] is discretized into cells; conservative variables are updated explicitly in time.
# MUSCL reconstruction with minmod slope limiter is used for second-order spatial accuracy.
# Time integration uses a CFL-based adaptive timestep with forward Euler.
# Boundary conditions are transmissive (zero-gradient).
# At final time t=0.2, density, velocity, and pressure are plotted.

# --- Parameters ---
gamma = 1.4  # Ratio of specific heats
nx = 400     # Number of spatial cells
x_start, x_end = 0.0, 1.0
CFL = 0.6    # CFL number for stability
t_final = 0.2

# --- Discretization ---
dx = (x_end - x_start) / nx
x = np.linspace(x_start + 0.5*dx, x_end - 0.5*dx, nx)  # cell centers

# --- Initial Conditions ---
def initial_conditions(x):
    rho = np.where(x <= 0.5, 1.0, 0.125)
    u = np.zeros_like(x)
    p = np.where(x <= 0.5, 1.0, 0.1)
    return rho, u, p

rho0, u0, p0 = initial_conditions(x)

# --- Convert primitive to conservative variables ---
def prim_to_cons(rho, u, p):
    E = p/(gamma - 1) / rho + 0.5 * u**2
    return np.array([rho, rho*u, rho*E])  # shape (3, nx)

# --- Convert conservative to primitive variables ---
def cons_to_prim(U):
    rho = U[0]
    u = U[1]/rho
    E = U[2]/rho
    p = (gamma - 1) * rho * (E - 0.5 * u**2)
    return rho, u, p

# --- Compute flux vector from conservative variables ---
def flux(U):
    rho, u, p = cons_to_prim(U)
    F = np.zeros_like(U)
    F[0] = rho * u
    F[1] = rho * u**2 + p
    F[2] = (U[2] + p) * u
    return F

# --- Minmod slope limiter ---
def minmod(a, b):
    cond = (a*b) > 0
    result = np.where(cond, np.where(np.abs(a) < np.abs(b), a, b), 0.0)
    return result

# --- MUSCL reconstruction with minmod limiter ---
def muscl_reconstruction(U):
    # U shape: (3, nx)
    UL = np.zeros_like(U)
    UR = np.zeros_like(U)
    for i in range(3):
        delta_plus = np.roll(U[i], -1) - U[i]
        delta_minus = U[i] - np.roll(U[i], 1)
        slope = minmod(delta_minus, delta_plus)
        UL[i] = U[i] + 0.5 * slope
        UR[i] = U[i] - 0.5 * slope
    # At boundaries, use first order (no slope)
    UL[:,0] = U[:,0]
    UR[:,0] = U[:,0]
    UL[:,-1] = U[:,-1]
    UR[:,-1] = U[:,-1]
    return UL, UR

# --- HLLC Riemann solver ---
def hllc_flux(UL, UR):
    # UL, UR shape: (3, n_interfaces)
    # Compute primitive variables left and right
    rhoL, uL, pL = cons_to_prim(UL)
    rhoR, uR, pR = cons_to_prim(UR)

    # Compute sound speeds
    aL = np.sqrt(gamma * pL / rhoL)
    aR = np.sqrt(gamma * pR / rhoR)

    # Compute fluxes
    FL = flux(UL)
    FR = flux(UR)

    # Compute wave speeds (Toro 2009)
    SL = np.minimum(uL - aL, uR - aR)
    SR = np.maximum(uL + aL, uR + aR)

    # Pressure estimate in star region (Toro eq 10.58)
    rho_bar = 0.5 * (rhoL + rhoR)
    a_bar = 0.5 * (aL + aR)
    p_pvrs = 0.5 * (pL + pR) - 0.5 * (uR - uL) * rho_bar * a_bar
    p_star = np.maximum(0, p_pvrs)

    # Compute star region speeds
    qL = np.where(p_star <= pL, 1.0, np.sqrt(1 + (gamma + 1)/(2*gamma) * (p_star/pL - 1)))
    qR = np.where(p_star <= pR, 1.0, np.sqrt(1 + (gamma + 1)/(2*gamma) * (p_star/pR - 1)))
    SL = uL - aL * qL
    SR = uR + aR * qR

    # Compute SM (speed of contact wave)
    numerator = pR - pL + rhoL * uL * (SL - uL) - rhoR * uR * (SR - uR)
    denominator = rhoL * (SL - uL) - rhoR * (SR - uR)
    SM = numerator / denominator

    # Compute star states
    def star_state(U, S, S_star):
        rho = U[0]
        u = U[1]/rho
        E = U[2]/rho
        p = (gamma - 1) * rho * (E - 0.5 * u**2)
        rho_star = rho * (S - u) / (S - S_star)
        mom_star = rho_star * S_star
        E_star = ((S - u) * E - p * u + p * S_star) / (S - S_star)
        return np.array([rho_star, mom_star, rho_star * E_star])

    n = UL.shape[1]
    flux_hllc = np.zeros_like(UL)

    for i in range(n):
        if 0 <= SL[i]:
            flux_hllc[:, i] = FL[:, i]
        elif SL[i] <= 0 <= SM[i]:
            U_starL = star_state(UL[:, i], SL[i], SM[i])
            flux_hllc[:, i] = FL[:, i] + SL[i] * (U_starL - UL[:, i])
        elif SM[i] <= 0 <= SR[i]:
            U_starR = star_state(UR[:, i], SR[i], SM[i])
            flux_hllc[:, i] = FR[:, i] + SR[i] * (U_starR - UR[:, i])
        else:
            flux_hllc[:, i] = FR[:, i]

    return flux_hllc

# --- Apply transmissive boundary conditions ---
def apply_boundary(U):
    # U shape: (3, nx)
    # Extend with ghost cells for reconstruction
    U_ext = np.zeros((3, nx + 4))
    U_ext[:, 2:-2] = U
    # Transmissive BC: copy boundary values into ghost cells
    U_ext[:, 0] = U[:, 0]
    U_ext[:, 1] = U[:, 0]
    U_ext[:, -2] = U[:, -1]
    U_ext[:, -1] = U[:, -1]
    return U_ext

# --- Main solver ---
def solve_euler():
    # Initialize conservative variables
    U = prim_to_cons(rho0, u0, p0)

    t = 0.0
    while t < t_final:
        # Apply boundary conditions
        U_ext = apply_boundary(U)

        # Reconstruct left and right states at interfaces
        UL = np.zeros((3, nx + 1))
        UR = np.zeros((3, nx + 1))
        for i in range(3):
            # Extract extended array for variable i
            Ui = U_ext[i]
            # Compute slopes with minmod limiter
            delta_plus = Ui[2+1:] - Ui[2:-1]
            delta_minus = Ui[2:-1] - Ui[1:-2]
            slope = minmod(delta_minus, delta_plus)
            # Left state at interface i+1/2 is cell i plus half slope
            UL[i,1:-1] = Ui[2:-2] + 0.5 * slope[:-1]
            # Right state at interface i+1/2 is cell i+1 minus half slope
            UR[i,1:-1] = Ui[3:-1] - 0.5 * slope[1:]
            # For boundaries, use first order (no slope)
            UL[i,0] = Ui[2]
            UR[i,0] = Ui[2]
            UL[i,-1] = Ui[-3]
            UR[i,-1] = Ui[-3]

        # Compute numerical fluxes at interfaces
        F = hllc_flux(UL, UR)

        # Compute maximum wave speed for CFL condition
        rho, u, p = cons_to_prim(U)
        a = np.sqrt(gamma * p / rho)
        max_speed = np.max(np.abs(u) + a)
        dt = CFL * dx / max_speed
        if t + dt > t_final:
            dt = t_final - t

        # Update conservative variables with finite volume update
        U = U - dt/dx * (F[:,1:] - F[:,:-1])

        t += dt

    # Compute final primitive variables
    rho, u, p = cons_to_prim(U)
    return x, rho, u, p

# --- Run solver ---
x, rho, u, p = solve_euler()

# --- Plot results ---
plt.figure(figsize=(10,6))
plt.plot(x, rho, label='Density $\u03C1$', color='blue')
plt.plot(x, u, label='Velocity $u$', color='green')
plt.plot(x, p, label='Pressure $p$', color='red')
plt.xlabel('x')
plt.title('Solution of 1D Euler Equations at t=0.2 (HLLC solver)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
```
****************************************
