
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt

# Technical explanation:
# This code solves the 1D Euler equations for compressible flow (Sod shock tube problem)
# using a Finite Volume Method (FVM) with second-order MUSCL reconstruction and the HLLC approximate Riemann solver.
# To improve temporal accuracy over the previous first-order explicit Euler method,
# a strong stability preserving third-order Runge-Kutta (SSP-RK3) time integrator is implemented.
# The minmod slope limiter is retained for robustness, but the code structure is modularized,
# and small positive floors are added to density and pressure during primitive variable recovery
# to prevent rare numerical instabilities.
# Detailed progress printing is included every 20 steps.
# The solver outputs density, velocity, and pressure at t=0.2 and plots them in one figure.

# --- Physical and numerical parameters ---
gamma = 1.4          # Ratio of specific heats
nx = 400             # Number of spatial cells
x_start, x_end = 0.0, 1.0
CFL = 0.6            # CFL number for stability
t_final = 0.2        # Final simulation time

# --- Spatial discretization ---
dx = (x_end - x_start) / nx
x = np.linspace(x_start + 0.5*dx, x_end - 0.5*dx, nx)  # Cell centers

# --- Initial conditions ---
def initial_conditions(x):
    # Sod shock tube initial condition
    rho = np.where(x <= 0.5, 1.0, 0.125)
    u = np.zeros_like(x)
    p = np.where(x <= 0.5, 1.0, 0.1)
    return rho, u, p

rho0, u0, p0 = initial_conditions(x)

# --- Conversion between primitive and conservative variables ---
def prim_to_cons(rho, u, p):
    # Total energy per unit mass E = internal + kinetic
    E = p / ((gamma - 1) * rho) + 0.5 * u**2
    return np.array([rho, rho * u, rho * E])  # shape (3, nx)

def cons_to_prim(U):
    # Add small floors to avoid negative or zero density/pressure due to round-off
    rho_floor = 1e-12
    p_floor = 1e-12

    rho = np.maximum(U[0], rho_floor)
    u = U[1] / rho
    E = U[2] / rho
    p = (gamma - 1) * rho * (E - 0.5 * u**2)
    p = np.maximum(p, p_floor)
    return rho, u, p

# --- Compute physical flux vector from conservative variables ---
def flux(U):
    rho, u, p = cons_to_prim(U)
    F = np.zeros_like(U)
    F[0] = rho * u
    F[1] = rho * u**2 + p
    F[2] = (U[2] + p) * u
    return F

# --- Minmod slope limiter ---
def minmod(a, b):
    cond = (a * b) > 0
    result = np.where(cond, np.where(np.abs(a) < np.abs(b), a, b), 0.0)
    return result

# --- MUSCL reconstruction with minmod limiter ---
def muscl_reconstruction(U_ext):
    # U_ext shape: (3, nx + 4) including 2 ghost cells on each side
    # Returns left and right states at interfaces: shape (3, nx+1)
    UL = np.zeros((3, nx + 1))
    UR = np.zeros((3, nx + 1))

    for i in range(3):
        Ui = U_ext[i]

        # Compute slopes for physical cells only (length nx)
        delta_plus = Ui[3:nx+3] - Ui[2:nx+2]    # Ui[i+1] - Ui[i], length nx
        delta_minus = Ui[2:nx+2] - Ui[1:nx+1]   # Ui[i] - Ui[i-1], length nx
        slope = minmod(delta_minus, delta_plus) # length nx

        # Left state at interface i+1/2 is cell i + 0.5 * slope[i]
        UL[i,1:nx] = Ui[2:nx+1] + 0.5 * slope[0:nx-1]   # length nx-1

        # Right state at interface i+1/2 is cell i+1 - 0.5 * slope[i+1]
        UR[i,1:nx] = Ui[3:nx+2] - 0.5 * slope[1:nx]     # length nx-1

        # For boundaries (interfaces 0 and nx), use first order (no slope)
        UL[i,0] = Ui[2]
        UR[i,0] = Ui[2]
        UL[i,-1] = Ui[nx+1]
        UR[i,-1] = Ui[nx+1]

    return UL, UR

# --- HLLC Riemann solver ---
def hllc_flux(UL, UR):
    # UL, UR shape: (3, n_interfaces)
    # Vectorized implementation for efficiency

    # Primitive variables left and right
    rhoL, uL, pL = cons_to_prim(UL)
    rhoR, uR, pR = cons_to_prim(UR)

    # Sound speeds
    aL = np.sqrt(gamma * pL / rhoL)
    aR = np.sqrt(gamma * pR / rhoR)

    # Fluxes left and right
    FL = flux(UL)
    FR = flux(UR)

    # Wave speed estimates (Toro 2009)
    SL = np.minimum(uL - aL, uR - aR)
    SR = np.maximum(uL + aL, uR + aR)

    # Pressure estimate in star region (PVRS Riemann solver)
    rho_bar = 0.5 * (rhoL + rhoR)
    a_bar = 0.5 * (aL + aR)
    p_pvrs = 0.5 * (pL + pR) - 0.5 * (uR - uL) * rho_bar * a_bar
    p_star = np.maximum(0, p_pvrs)

    # Compute q factors for wave speed correction
    qL = np.where(p_star <= pL, 1.0, np.sqrt(1 + (gamma + 1) / (2 * gamma) * (p_star / pL - 1)))
    qR = np.where(p_star <= pR, 1.0, np.sqrt(1 + (gamma + 1) / (2 * gamma) * (p_star / pR - 1)))

    SL = uL - aL * qL
    SR = uR + aR * qR

    # Contact wave speed SM
    numerator = pR - pL + rhoL * uL * (SL - uL) - rhoR * uR * (SR - uR)
    denominator = rhoL * (SL - uL) - rhoR * (SR - uR)
    SM = numerator / denominator

    # Star region states function (vectorized)
    def star_state(U, S, S_star):
        rho = U[0]
        u = U[1] / rho
        E = U[2] / rho
        p = (gamma - 1) * rho * (E - 0.5 * u**2)
        rho_star = rho * (S - u) / (S - S_star)
        mom_star = rho_star * S_star
        E_star = ((S - u) * E - p * u + p * S_star) / (S - S_star)
        return np.array([rho_star, mom_star, rho_star * E_star])

    flux_hllc = np.zeros_like(UL)

    # Masks for wave speed regions
    mask_SL = (0 <= SL)
    mask_SL_SM = (SL <= 0) & (0 <= SM)
    mask_SM_SR = (SM <= 0) & (0 <= SR)
    mask_SR = (SR <= 0)

    # Case 1: 0 <= SL
    flux_hllc[:, mask_SL] = FL[:, mask_SL]

    # Case 2: SL <= 0 <= SM
    idx = np.where(mask_SL_SM)[0]
    if idx.size > 0:
        U_starL = star_state(UL[:, idx], SL[idx], SM[idx])
        flux_hllc[:, idx] = FL[:, idx] + SL[idx] * (U_starL - UL[:, idx])

    # Case 3: SM <= 0 <= SR
    idx = np.where(mask_SM_SR)[0]
    if idx.size > 0:
        U_starR = star_state(UR[:, idx], SR[idx], SM[idx])
        flux_hllc[:, idx] = FR[:, idx] + SR[idx] * (U_starR - UR[:, idx])

    # Case 4: SR <= 0
    flux_hllc[:, mask_SR] = FR[:, mask_SR]

    return flux_hllc

# --- Apply transmissive boundary conditions ---
def apply_boundary(U):
    # U shape: (3, nx)
    # Extend with 2 ghost cells on each side for reconstruction
    U_ext = np.zeros((3, nx + 4))
    U_ext[:, 2:-2] = U
    # Transmissive BC: copy boundary values into ghost cells
    U_ext[:, 0] = U[:, 0]
    U_ext[:, 1] = U[:, 0]
    U_ext[:, -2] = U[:, -1]
    U_ext[:, -1] = U[:, -1]
    return U_ext

# --- SSP-RK3 time integration step ---
def ssp_rk3_step(U, dt, dx):
    # Stage 1
    U1 = U + dt * rhs(U, dx)
    # Stage 2
    U2 = 0.75 * U + 0.25 * (U1 + dt * rhs(U1, dx))
    # Stage 3
    U_new = (1.0 / 3.0) * U + (2.0 / 3.0) * (U2 + dt * rhs(U2, dx))
    return U_new

# --- Compute right-hand side (finite volume update) ---
def rhs(U, dx):
    # Apply boundary conditions
    U_ext = apply_boundary(U)
    # MUSCL reconstruction
    UL, UR = muscl_reconstruction(U_ext)
    # Compute numerical fluxes at interfaces
    F = hllc_flux(UL, UR)
    # Compute residual (flux difference)
    res = -(F[:, 1:] - F[:, :-1]) / dx
    return res

# --- Main solver function ---
def solve_euler():
    U = prim_to_cons(rho0, u0, p0)
    t = 0.0
    step = 0
    print(f"Starting simulation with {nx} cells, CFL={CFL}, final time={t_final}")

    while t < t_final:
        # Compute maximum wave speed for CFL condition
        rho, u, p = cons_to_prim(U)
        a = np.sqrt(gamma * p / rho)
        max_speed = np.max(np.abs(u) + a)
        dt = CFL * dx / max_speed
        if t + dt > t_final:
            dt = t_final - t

        # SSP-RK3 time integration step
        U_new = ssp_rk3_step(U, dt, dx)

        # Check for non-physical states after update
        rho_new, u_new, p_new = cons_to_prim(U_new)
        if np.any(rho_new <= 0):
            raise ValueError(f"Non-physical state detected: negative density at step {step+1}")
        if np.any(p_new <= 0):
            raise ValueError(f"Non-physical state detected: negative pressure at step {step+1}")

        U = U_new
        t += dt
        step += 1

        # Detailed progress printing every 20 steps or at final step
        if step % 20 == 0 or t >= t_final:
            print(f"Step {step:4d}, Time {t:.5f}, dt {dt:.5e}, Max wave speed {max_speed:.5f}")

    print("Simulation completed successfully.")
    rho, u, p = cons_to_prim(U)
    return x, rho, u, p

# --- Run solver ---
x, rho, u, p = solve_euler()

# --- Plot results ---
plt.figure(figsize=(10, 6))
plt.plot(x, rho, label='Density $\\rho$', color='blue')
plt.plot(x, u, label='Velocity $u$', color='green')
plt.plot(x, p, label='Pressure $p$', color='red')
plt.axvline(0.5, color='k', linestyle='--', linewidth=0.8, label='Initial discontinuity')
plt.xlabel('x')
plt.title('Solution of 1D Euler Equations at t=0.2 (HLLC solver with MUSCL + SSP-RK3)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
```

****************************************
