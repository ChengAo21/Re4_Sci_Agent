
****************************************
To solve the Euler equations for the Sod shock tube problem, we implement a finite volume method with the HLLC (Harten-Lax-van Leer-Contact) approximate Riemann solver. This approach balances accuracy and computational efficiency, capturing shocks and contact discontinuities effectively. The solution involves discretizing the domain, initializing conserved variables, computing fluxes at cell interfaces using HLLC, and updating the solution with a first-order time integration scheme.

### Technical Explanation:
1. **Finite Volume Discretization**: The domain is divided into cells where conserved variables (mass, momentum, energy) are stored as averages.
2. **HLLC Riemann Solver**: Approximates fluxes at cell interfaces by:
   - Estimating wave speeds (SL, SR, S*) to partition the solution into four possible states.
   - Computing star-state variables to handle contact discontinuities.
   - Ensuring flux continuity across waves.
3. **Time Integration**: Explicit Euler method with CFL condition for stability, where the time step adapts to the maximum wave speed.
4. **Boundary Conditions**: Transmissive (zero-gradient) boundaries to allow waves to pass without reflection.
5. **Post-processing**: Convert conserved variables back to primitive variables (density, velocity, pressure) for visualization.

### Code Implementation:
```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
gamma = 1.4
CFL = 0.5
N = 200
xmin, xmax = 0.0, 1.0
t_end = 0.2

# Grid setup
dx = (xmax - xmin) / N
x = np.linspace(xmin + dx/2, xmax - dx/2, N)  # Cell centers

# Initialize primitive variables
rho = np.where(x <= 0.5, 1.0, 0.125)
u = np.zeros_like(x)
p = np.where(x <= 0.5, 1.0, 0.1)

# Compute conserved variables (mass, momentum, energy)
E = p / ((gamma - 1) * rho) + 0.5 * u**2  # Specific total energy
U = np.zeros((N, 3))
U[:, 0] = rho              # Density
U[:, 1] = rho * u          # Momentum
U[:, 2] = rho * E          # Total energy per unit volume

# HLLC flux function
def hllc_flux(rhoL, uL, pL, rhoR, uR, pR, gamma):
    # Sound speeds
    cL = np.sqrt(gamma * pL / rhoL)
    cR = np.sqrt(gamma * pR / rhoR)
    
    # Wave speed estimates (Batten et al. 1997)
    SL = min(uL - cL, uR - cR)
    SR = max(uL + cL, uR + cR)
    
    # Contact wave speed
    denom = rhoL * (SL - uL) - rhoR * (SR - uR)
    if abs(denom) < 1e-10:
        S_star = 0.5 * (uL + uR)
    else:
        num = pR - pL + rhoL * uL * (SL - uL) - rhoR * uR * (SR - uR)
        S_star = num / denom
    
    # Star-state pressure
    p_star = pL + rhoL * (SL - uL) * (S_star - uL)
    
    # Conserved variables for left and right states
    UL = np.array([rhoL, rhoL * uL, pL/(gamma-1) + 0.5 * rhoL * uL**2])
    UR = np.array([rhoR, rhoR * uR, pR/(gamma-1) + 0.5 * rhoR * uR**2])
    
    # Fluxes for left and right states
    FL = np.array([
        UL[1],
        UL[1] * uL + pL,
        uL * (UL[2] + pL)
    ])
    FR = np.array([
        UR[1],
        UR[1] * uR + pR,
        uR * (UR[2] + pR)
    ])
    
    # Star-state conserved variables
    rho_star_L = rhoL * (SL - uL) / (SL - S_star)
    E_star_L = UL[2]/rhoL + (S_star - uL) * (S_star + pL/(rhoL * (SL - uL)))
    U_star_L = np.array([rho_star_L, rho_star_L * S_star, rho_star_L * E_star_L])
    
    rho_star_R = rhoR * (SR - uR) / (SR - S_star)
    E_star_R = UR[2]/rhoR + (S_star - uR) * (S_star + pR/(rhoR * (SR - uR)))
    U_star_R = np.array([rho_star_R, rho_star_R * S_star, rho_star_R * E_star_R])
    
    # Select flux based on wave positions
    if SL >= 0:
        return FL
    elif SR <= 0:
        return FR
    elif S_star >= 0:
        return FL + SL * (U_star_L - UL)
    else:
        return FR + SR * (U_star_R - UR)

# Time integration
t = 0.0
while t < t_end:
    # Compute max wave speed for CFL condition
    rho_curr = U[:, 0]
    u_curr = U[:, 1] / rho_curr
    p_curr = (gamma - 1) * (U[:, 2] - 0.5 * rho_curr * u_curr**2)
    c = np.sqrt(gamma * p_curr / rho_curr)
    max_speed = np.max(np.abs(u_curr) + c)
    dt = CFL * dx / max_speed
    if t + dt > t_end:
        dt = t_end - t
    
    # Extend domain with ghost cells (transmissive boundaries)
    U_ext = np.vstack([U[0], U, U[-1]])
    
    # Compute fluxes at all interfaces
    F = np.zeros((N+1, 3))
    for i in range(N+1):
        # Left and right states at interface i
        UL = U_ext[i]
        UR = U_ext[i+1]
        
        # Convert to primitive variables
        rhoL, uL = UL[0], UL[1] / UL[0]
        pL = (gamma - 1) * (UL[2] - 0.5 * rhoL * uL**2)
        
        rhoR, uR = UR[0], UR[1] / UR[0]
        pR = (gamma - 1) * (UR[2] - 0.5 * rhoR * uR**2)
        
        # Compute HLLC flux
        F[i] = hllc_flux(rhoL, uL, pL, rhoR, uR, pR, gamma)
    
    # Update conserved variables
    for i in range(N):
        U[i] -= dt / dx * (F[i+1] - F[i])
    
    t += dt

# Convert to primitive variables for output
rho_final = U[:, 0]
u_final = U[:, 1] / rho_final
p_final = (gamma - 1) * (U[:, 2] - 0.5 * rho_final * u_final**2)

# Plot results
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(x, rho_final, 'b-', linewidth=1.5)
plt.ylabel('Density $\\rho$')
plt.grid(linestyle='--', alpha=0.7)
plt.title('Solution at t = 0.2')

plt.subplot(3, 1, 2)
plt.plot(x, u_final, 'r-', linewidth=1.5)
plt.ylabel('Velocity $u$')
plt.grid(linestyle='--', alpha=0.7)

plt.subplot(3, 1, 3)
plt.plot(x, p_final, 'g-', linewidth=1.5)
plt.ylabel('Pressure $p$')
plt.xlabel('Position $x$')
plt.grid(linestyle='--', alpha=0.7)

plt.tight_layout()
plt.savefig('euler_solution.png')
plt.show()
```

### Key Features:
1. **Robust Flux Calculation**: HLLC solver accurately captures shocks and contact discontinuities.
2. **Dynamic Time Stepping**: CFL condition ensures stability by adapting to the maximum wave speed.
3. **Efficient Implementation**: Vectorized operations and minimal memory usage.
4. **Visualization**: Integrated plotting of density, velocity, and pressure at the final time.

This implementation produces the characteristic Sod shock tube solution, showing a left rarefaction wave, contact discontinuity, and right shock wave at \( t = 0.2 \). The results are saved as `euler_solution.png`.
****************************************
