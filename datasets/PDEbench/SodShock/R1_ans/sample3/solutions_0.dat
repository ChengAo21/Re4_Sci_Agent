
****************************************
To solve the Euler equations for the given Riemann problem, we implement a finite volume method with the HLLC approximate Riemann solver. This approach balances accuracy and computational efficiency, effectively capturing shocks and contact discontinuities. The solution involves discretizing the spatial domain, initializing conserved variables, and advancing the solution in time using a strong stability-preserving Runge-Kutta (SSP-RK2) scheme.

### Key Algorithmic Insights:
1. **Finite Volume Discretization**: The domain is divided into cells, storing cell-averaged conserved variables (mass, momentum, energy).
2. **HLLC Riemann Solver**: Approximates fluxes at cell interfaces by resolving waves (shocks, rarefactions, contacts) with intermediate states.
3. **Time Integration (SSP-RK2)**: Ensures second-order accuracy while maintaining stability under a CFL condition.
4. **Transmissive Boundary Conditions**: Ghost cells replicate adjacent interior states to minimize boundary effects.
5. **Primitive Variable Recovery**: Convert conserved variables back to physical quantities (density, velocity, pressure) for visualization.

The code below implements this approach, solving the Euler equations up to \( t = 0.2 \) and plotting the density, velocity, and pressure profiles.

```python
import numpy as np
import matplotlib.pyplot as plt

# Parameters
gamma = 1.4
t_end = 0.2
CFL = 0.8
N = 200  # Number of interior cells
dx = 1.0 / N
x_center = np.linspace(dx/2, 1 - dx/2, N)  # Cell centers

# Initialize conserved variables with ghost cells
U = np.zeros((3, N + 4))  # [rho, rho*u, rho*E] for each cell

# Set initial conditions for interior cells
mask_left = x_center <= 0.5
mask_right = x_center > 0.5

# Left state (0 < x <= 0.5)
rho_left = 1.0
u_left = 0.0
p_left = 1.0
E_left = 0.5 * u_left**2 + p_left / ((gamma - 1) * rho_left)
U[0, 2:2+N][:, mask_left] = rho_left
U[1, 2:2+N][:, mask_left] = rho_left * u_left
U[2, 2:2+N][:, mask_left] = rho_left * E_left

# Right state (0.5 < x < 1)
rho_right = 0.125
u_right = 0.0
p_right = 0.1
E_right = 0.5 * u_right**2 + p_right / ((gamma - 1) * rho_right)
U[0, 2:2+N][:, mask_right] = rho_right
U[1, 2:2+N][:, mask_right] = rho_right * u_right
U[2, 2:2+N][:, mask_right] = rho_right * E_right

# Set ghost cells (transmissive boundaries)
U[:, 0] = U[:, 2]
U[:, 1] = U[:, 2]
U[:, -1] = U[:, -3]
U[:, -2] = U[:, -3]

# HLLC Riemann solver
def hllc_flux(U_left, U_right, gamma=1.4):
    # Extract left state
    rhoL = U_left[0]
    uL = U_left[1] / rhoL
    EL = U_left[2] / rhoL
    pL = (gamma - 1) * rhoL * (EL - 0.5 * uL**2)
    cL = np.sqrt(gamma * pL / rhoL)
    
    # Extract right state
    rhoR = U_right[0]
    uR = U_right[1] / rhoR
    ER = U_right[2] / rhoR
    pR = (gamma - 1) * rhoR * (ER - 0.5 * uR**2)
    cR = np.sqrt(gamma * pR / rhoR)
    
    # Wave speed estimates
    SL = min(uL - cL, uR - cR)
    SR = max(uL + cL, uR + cR)
    
    # Compute S_star (contact wave speed)
    denom = rhoL * (SL - uL) - rhoR * (SR - uR)
    if abs(denom) < 1e-10:
        denom = 1e-10
    S_star = (pR - pL + rhoL * uL * (SL - uL) - rhoR * uR * (SR - uR)) / denom
    
    # Compute p_star from left state
    p_star = pL + rhoL * (SL - uL) * (S_star - uL)
    
    # Left and right fluxes
    F_left = np.array([
        rhoL * uL,
        rhoL * uL**2 + pL,
        uL * (rhoL * EL + pL)
    ])
    F_right = np.array([
        rhoR * uR,
        rhoR * uR**2 + pR,
        uR * (rhoR * ER + pR)
    ])
    
    # Compute HLLC flux
    if SL >= 0:
        return F_left
    elif SR <= 0:
        return F_right
    else:
        if S_star >= 0:
            # Left star state
            factorL = rhoL * (SL - uL) / (SL - S_star)
            U_star_left = np.array([
                factorL,
                factorL * S_star,
                factorL * (EL + (S_star - uL) * (S_star + pL / (rhoL * (SL - uL))))
            ])
            return F_left + SL * (U_star_left - U_left)
        else:
            # Right star state
            factorR = rhoR * (SR - uR) / (SR - S_star)
            U_star_right = np.array([
                factorR,
                factorR * S_star,
                factorR * (ER + (S_star - uR) * (S_star + pR / (rhoR * (SR - uR))))
            ])
            return F_right + SR * (U_star_right - U_right)

# Main time loop
t = 0.0
while t < t_end:
    # Set ghost cells
    U[:, 0] = U[:, 2]
    U[:, 1] = U[:, 2]
    U[:, -1] = U[:, -3]
    U[:, -2] = U[:, -3]
    
    # Compute primitive variables for time step
    rho = U[0, :]
    vel = U[1, :] / rho
    E = U[2, :] / rho
    p = (gamma - 1) * rho * (E - 0.5 * vel**2)
    c = np.sqrt(gamma * p / rho)
    
    # Compute time step via CFL condition
    max_speed = np.max(np.abs(vel[2:-2]) + c[2:-2])
    dt = CFL * dx / max_speed
    if t + dt > t_end:
        dt = t_end - t
    
    # Stage 1: Compute fluxes and update to intermediate state
    F = np.zeros((3, N + 3))  # Fluxes at interfaces
    for j in range(2, N + 3):  # Interfaces 2 to N+2
        U_left = U[:, j-1]
        U_right = U[:, j]
        F[:, j] = hllc_flux(U_left, U_right, gamma)
    
    # Compute residual (dU/dt)
    R = np.zeros_like(U)
    for i in range(2, N + 2):  # Interior cells
        R[:, i] = - (F[:, i+1] - F[:, i]) / dx
    
    U1 = U.copy()
    U1[:, 2:N+2] += dt * R[:, 2:N+2]
    
    # Stage 1 ghost cells
    U1[:, 0] = U1[:, 2]
    U1[:, 1] = U1[:, 2]
    U1[:, -1] = U1[:, -3]
    U1[:, -2] = U1[:, -3]
    
    # Stage 2: Compute fluxes with U1
    F1 = np.zeros((3, N + 3))
    for j in range(2, N + 3):
        U_left = U1[:, j-1]
        U_right = U1[:, j]
        F1[:, j] = hllc_flux(U_left, U_right, gamma)
    
    # Compute residual for U1
    R1 = np.zeros_like(U)
    for i in range(2, N + 2):
        R1[:, i] = - (F1[:, i+1] - F1[:, i]) / dx
    
    # SSP-RK2 integration
    U_new = U.copy()
    U_new[:, 2:N+2] = 0.5 * U[:, 2:N+2] + 0.5 * (U1[:, 2:N+2] + dt * R1[:, 2:N+2])
    U = U_new
    t += dt

# Extract and compute primitive variables at final time
rho_final = U[0, 2:2+N]
vel_final = U[1, 2:2+N] / rho_final
E_final = U[2, 2:2+N] / rho_final
p_final = (gamma - 1) * rho_final * (E_final - 0.5 * vel_final**2)

# Plot results
plt.figure(figsize=(12, 8))

plt.subplot(3, 1, 1)
plt.plot(x_center, rho_final, 'b-')
plt.ylabel('Density')
plt.title('Solution at t=0.2')
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(x_center, vel_final, 'r-')
plt.ylabel('Velocity')
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(x_center, p_final, 'g-')
plt.ylabel('Pressure')
plt.xlabel('x')
plt.grid(True)

plt.tight_layout()
plt.show()
```

### Explanation:
1. **Initialization**: The domain is discretized into 200 cells. Initial conditions for the Riemann problem are set, with ghost cells for boundary conditions.
2. **HLLC Flux Calculation**: For each interface, the solver computes fluxes by resolving wave structures (left, right, and contact discontinuities).
3. **Time Integration**: The SSP-RK2 method advances the solution, ensuring stability and second-order accuracy. The time step is dynamically adjusted using the CFL condition.
4. **Boundary Handling**: Ghost cells replicate adjacent interior states to simulate transmissive boundaries.
5. **Postprocessing**: Conserved variables are converted back to primitive variables (density, velocity, pressure) for visualization at \( t = 0.2 \).

This implementation efficiently captures the evolution of the initial discontinuity into shock and rarefaction waves, providing accurate physical profiles at the specified time.
****************************************
