
****************************************
```python
# Import necessary libraries
import numpy as np
import matplotlib.pyplot as plt
import os
import torch
import logging

# Configure logging for detailed output
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')

# Technical Explanation for the Solving Algorithm
# The refined algorithm is the Finite Volume Method (FVM) with a second-order MUSCL-Hancock
# scheme in space and a third-order Strong Stability Preserving Runge-Kutta (SSP-RK3)
# method in time. The HLLC (Harten-Lax-van Leer-Contact) approximate Riemann solver
# is used to compute numerical fluxes at cell interfaces. This combination provides
# a robust and more accurate solution for hyperbolic conservation laws like the Euler
# equations, especially for problems involving discontinuities such as the Sod shock tube.

# 1. Finite Volume Discretization:
#    The spatial domain [0,1] is divided into N_cells control volumes.
#    The conserved variables U = [rho, rho*u, rho*E]^T are stored as cell-averaged values.
#    The governing equations are integrated over each cell, leading to an update rule:
#    dU_i/dt = -(F_{i+1/2} - F_{i-1/2}) / dx, where F are numerical fluxes.

# 2. MUSCL-Hancock Scheme (Second-Order Spatial Accuracy):
#    To achieve second-order spatial accuracy, the piecewise constant reconstruction
#    of the first-order Godunov scheme is replaced by a piecewise linear reconstruction.
#    a. Primitive Variable Reconstruction: Instead of using cell-averaged conserved
#       variables directly, primitive variables (rho, u, p) are reconstructed to
#       the left and right edges of each cell. This involves calculating slopes
#       for each primitive variable within each cell.
#    b. Slope Limiting: To prevent spurious oscillations (Gibbs phenomenon) near
#       discontinuities (shocks, contact discontinuities), a slope limiter (Minmod)
#       is applied to the gradients used for reconstruction. This ensures that the
#       reconstructed states remain monotonic.
#    c. Interface States: For each cell interface (e.g., between cell i and cell i+1),
#       the left state (UL) for the Riemann problem is the right-extrapolated state
#       from cell i, and the right state (UR) is the left-extrapolated state from cell i+1.
#       These reconstructed states are then converted to conserved variables before
#       being passed to the Riemann solver.

# 3. HLLC Riemann Solver (Vectorized and PyTorch-optimized):
#    The HLLC solver computes the numerical flux F at each cell interface.
#    It is an approximate Riemann solver that accounts for the contact discontinuity.
#    The key improvement in this version is the **vectorization** of the HLLC solver
#    using NumPy array operations, and further **optimization by converting to PyTorch
#    tensors for potential GPU acceleration**. Instead of looping through each interface,
#    the solver now processes all interfaces simultaneously using PyTorch tensor operations.
#    This involves:
#    a. Batch Processing: Input states (UL, UR) are provided as tensors for all interfaces.
#    b. Parallel Calculation of Intermediate Values: All wave speeds (S_L, S_R, S_star),
#       star region pressures, and densities are computed for all interfaces in parallel
#       on the chosen device (CPU or GPU).
#    c. Conditional Flux Selection: PyTorch's `torch.where` function is used to select the
#       appropriate HLLC flux based on the wave speed conditions for each interface,
#       eliminating Python `if/elif/else` branching within a loop. This significantly
#       improves performance for large numbers of cells and leverages GPU capabilities.

# 4. SSP-RK3 Time Integration (Third-Order Temporal Accuracy and PyTorch-optimized):
#    An explicit third-order Strong Stability Preserving Runge-Kutta (SSP-RK3) method
#    is used for time integration. This method involves three stages:
#    U^(1) = U^n + dt * L(U^n)
#    U^(2) = (3/4) * U^n + (1/4) * (U^(1) + dt * L(U^(1)))
#    U^(n+1) = (1/3) * U^n + (2/3) * (U^(2) + dt * L(U^(2)))
#    where L(U) represents the spatial discretization operator (the right-hand side
#    of the semi-discrete equation, i.e., -(F_{i+1/2} - F_{i-1/2}) / dx).
#    This three-stage process improves temporal accuracy compared to first-order or
#    second-order methods, allowing for larger stable time steps while maintaining accuracy,
#    and is implemented using PyTorch tensors for performance.

# 5. Boundary Conditions:
#    Transmissive (outflow) boundary conditions are applied using ghost cells.
#    The values in the ghost cells are simply copied from the adjacent interior cells
#    for both cell-averaged values and reconstructed slopes/states.

# 6. Primitive and Conserved Variable Conversion:
#    Helper functions handle conversions between primitive (rho, u, p) and conserved
#    (rho, rho*u, rho*E) variables, which are essential for initialization,
#    reconstruction, flux computation, and post-processing. These are also
#    optimized to work with PyTorch tensors.

# The combination of MUSCL-Hancock with HLLC and SSP-RK3 provides a robust,
# third-order accurate scheme suitable for capturing complex wave structures
# in the Euler equations with reduced numerical diffusion compared to first-order methods,
# and is optimized for performance using PyTorch.

class EulerSolver:
    """
    A solver for the 1D Euler equations using the Finite Volume Method.
    It employs a second-order MUSCL-Hancock scheme with Minmod limiter for spatial
    reconstruction, the HLLC approximate Riemann solver for numerical fluxes,
    and a third-order SSP-RK3 method for time integration.
    Optimized using PyTorch for potential GPU acceleration.
    """
    def __init__(self, gamma=1.4, CFL=0.8, N_cells=200, x_min=0.0, x_max=1.0, t_final=0.2):
        """
        Initializes the EulerSolver with given parameters.

        Args:
            gamma (float): Adiabatic index.
            CFL (float): Courant-Friedrichs-Lewy number for time step control.
            N_cells (int): Number of computational cells.
            x_min (float): Minimum x-coordinate of the domain.
            x_max (float): Maximum x-coordinate of the domain.
            t_final (float): Final simulation time.
        """
        self.gamma = gamma
        self.CFL = CFL
        self.N_cells = N_cells
        self.x_min = x_min
        self.x_max = x_max
        self.t_final = t_final

        # Determine the device to use (GPU if available, else CPU)
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        logging.info(f"Using device: {self.device}")

        # Discretization
        self.dx = (self.x_max - self.x_min) / self.N_cells
        # x_centers are stored as NumPy array for plotting, and as PyTorch tensor for calculations
        self.x_centers_np = np.linspace(self.x_min + 0.5 * self.dx, self.x_max - 0.5 * self.dx, self.N_cells)
        self.x_centers = torch.tensor(self.x_centers_np, dtype=torch.float64, device=self.device)

        # Initialize conserved variables U = [rho, rho*u, rho*E] as a PyTorch tensor
        self.U = torch.zeros((3, self.N_cells), dtype=torch.float64, device=self.device)
        self._set_initial_conditions()

        self.t = 0.0
        self.iteration = 0

    def _primitive_to_conserved(self, rho, u, p):
        """
        Converts primitive variables (rho, u, p) to conserved variables (rho, rho*u, rho*E).
        Optimized for PyTorch tensors.

        Args:
            rho (torch.Tensor): Density.
            u (torch.Tensor): Velocity.
            p (torch.Tensor): Pressure.

        Returns:
            torch.Tensor: Conserved variables [rho, rho*u, rho*E].
        """
        # Conserved variables: U = [rho, rho*u, rho*E]
        # Total specific energy E = 0.5 * u^2 + p / ((gamma - 1) * rho)
        rho_u = rho * u
        rho_E = rho * (0.5 * u**2 + p / ((self.gamma - 1) * rho))
        return torch.stack([rho, rho_u, rho_E], dim=0)

    def _conserved_to_primitive(self, U_conserved):
        """
        Converts conserved variables (rho, rho*u, rho*E) to primitive variables (rho, u, p).
        Includes numerical safeguards for pressure positivity.
        Optimized for PyTorch tensors.

        Args:
            U_conserved (torch.Tensor): Conserved variables [rho, rho_u, rho_E].

        Returns:
            tuple: (rho, u, p) as torch.Tensors.
        """
        # Conserved variables: U = [rho, rho_u, rho_E]
        # Primitive variables: rho, u, p
        rho = U_conserved[0]
        u = U_conserved[1] / rho
        # Pressure calculation: p = (gamma - 1) * (rho_E - 0.5 * rho_u^2 / rho)
        p = (self.gamma - 1) * (U_conserved[2] - 0.5 * U_conserved[1]**2 / rho)
        # Numerical safeguard: ensure pressure is non-negative
        p = torch.max(p, torch.tensor(1e-12, dtype=torch.float64, device=self.device)) # Small positive value to prevent negative pressure
        return rho, u, p

    def _compute_flux(self, U_conserved):
        """
        Computes the physical flux vector F from conserved variables.
        F = [rho*u, rho*u^2 + p, (rho*E + p)*u].
        Optimized for PyTorch tensors.

        Args:
            U_conserved (torch.Tensor): Conserved variables [rho, rho*u, rho*E].

        Returns:
            torch.Tensor: Physical flux vector.
        """
        rho, u, p = self._conserved_to_primitive(U_conserved)
        rho_u = U_conserved[1] # Momentum (rho*u)
        rho_E = U_conserved[2] # Total energy (rho*E)
        
        flux_rho = rho_u
        flux_rho_u = rho_u * u + p
        flux_rho_E = (rho_E + p) * u
        return torch.stack([flux_rho, flux_rho_u, flux_rho_E], dim=0)

    def _minmod_limiter(self, a, b):
        """
        Minmod slope limiter function.
        minmod(a,b) = sign(a) * max(0, min(|a|, b*sign(a)))
        This implementation returns 0 if a and b have different signs,
        otherwise it returns the value with the smaller magnitude and the common sign.
        Optimized for PyTorch tensors.

        Args:
            a (torch.Tensor): First argument.
            b (torch.Tensor): Second argument.

        Returns:
            torch.Tensor: Limited value.
        """
        # Optimized Part: Vectorized Minmod Limiter using PyTorch
        return torch.where(a * b > 0, torch.sign(a) * torch.min(torch.abs(a), torch.abs(b)), torch.tensor(0.0, dtype=torch.float64, device=self.device))

    def _hllc_riemann_solver_vectorized(self, UL_batch, UR_batch):
        """
        Vectorized HLLC Riemann solver for computing numerical fluxes at cell interfaces.
        Takes batch inputs (arrays of states) and returns batch outputs (arrays of fluxes).
        Optimized for PyTorch tensors and GPU acceleration.

        Args:
            UL_batch (torch.Tensor): Left states (conserved variables) for all interfaces. Shape (3, N_interfaces).
            UR_batch (torch.Tensor): Right states (conserved variables) for all interfaces. Shape (3, N_interfaces).

        Returns:
            torch.Tensor: Numerical fluxes for all interfaces. Shape (3, N_interfaces).
        """
        # Optimized Part: Vectorized HLLC Riemann Solver using PyTorch
        # Convert conserved to primitive variables for both states (vectorized)
        rho_L, u_L, p_L = self._conserved_to_primitive(UL_batch)
        rho_R, u_R, p_R = self._conserved_to_primitive(UR_batch)

        # Calculate speed of sound for both states (vectorized)
        c_L = torch.sqrt(self.gamma * p_L / rho_L)
        c_R = torch.sqrt(self.gamma * p_R / rho_R)

        # Estimate pressure in the star region (p_star_guess) for wave speed estimation (vectorized)
        p_star_guess = 0.5 * (p_L + p_R) + 0.5 * (u_L - u_R) * (rho_L * c_L + rho_R * c_R)
        p_star_guess = torch.max(torch.tensor(1e-12, dtype=torch.float64, device=self.device), p_star_guess) # Ensure positive pressure

        # Calculate q_L and q_R factors for shock wave speed estimation (vectorized)
        q_L = torch.ones_like(p_L)
        mask_L_shock = p_star_guess > p_L
        q_L[mask_L_shock] = torch.sqrt(1 + (self.gamma + 1)/(2*self.gamma) * (p_star_guess[mask_L_shock]/p_L[mask_L_shock] - 1))
        
        q_R = torch.ones_like(p_R)
        mask_R_shock = p_star_guess > p_R
        q_R[mask_R_shock] = torch.sqrt(1 + (self.gamma + 1)/(2*self.gamma) * (p_star_guess[mask_R_shock]/p_R[mask_R_shock] - 1))

        # Estimate the fastest left (S_L) and right (S_R) wave speeds (vectorized)
        S_L = u_L - c_L * q_L
        S_R = u_R + c_R * q_R

        # Calculate the contact discontinuity speed (S_star) (vectorized)
        # Add a small epsilon to denominator to prevent division by zero in edge cases
        denominator = (rho_L * (S_L - u_L) - rho_R * (S_R - u_R))
        # Use torch.where to handle potential zero denominator gracefully
        S_star = torch.where(torch.abs(denominator) < 1e-12, 
                             (p_R - p_L + rho_L * u_L * (S_L - u_L) - rho_R * u_R * (S_R - u_R)) / (denominator + 1e-12 * torch.sign(denominator)),
                             (p_R - p_L + rho_L * u_L * (S_L - u_L) - rho_R * u_R * (S_R - u_R)) / denominator)

        # Compute the physical fluxes for the left and right states (vectorized)
        F_L = self._compute_flux(UL_batch)
        F_R = self._compute_flux(UR_batch)

        # Extract total specific energies for left and right states (vectorized)
        E_L = UL_batch[2] / UL_batch[0]
        E_R = UR_batch[2] / UR_batch[0]

        # Calculate the total specific energies in the star regions (E_star_L, E_star_R) (vectorized)
        E_star_L = E_L + (S_star - u_L) * (S_star + p_L / (rho_L * (S_L - u_L)))
        E_star_R = E_R + (S_star - u_R) * (S_star + p_R / (rho_R * (S_R - u_R)))

        # Calculate densities in the star regions (rho_star_L, rho_star_R) (vectorized)
        rho_star_L = rho_L * (S_L - u_L) / (S_L - S_star)
        rho_star_R = rho_R * (S_R - u_R) / (S_R - S_star)

        # Construct the conserved variable vectors for the star regions (U_star_L, U_star_R) (vectorized)
        U_star_L = torch.stack([rho_star_L, rho_star_L * S_star, rho_star_L * E_star_L], dim=0)
        U_star_R = torch.stack([rho_star_R, rho_star_R * S_star, rho_star_R * E_star_R], dim=0)

        # Determine the HLLC flux based on the wave speeds using torch.where (vectorized)
        F_HLLC = torch.zeros_like(F_L)

        # Define masks for each case
        mask1 = S_L >= 0
        mask2 = S_R <= 0
        mask3 = (S_L < 0) & (S_star >= 0)
        mask4 = (S_star < 0) & (S_R > 0)
        
        # Apply fluxes based on masks. torch.where allows for conditional assignment.
        # The order of application matters if masks overlap, but for HLLC, these are typically disjoint.
        # We use sequential assignment for clarity.
        
        # Case 1: All waves are moving to the right, so the flux is F_L
        F_HLLC = torch.where(mask1, F_L, F_HLLC)
        
        # Case 2: All waves are moving to the left, so the flux is F_R
        F_HLLC = torch.where(mask2, F_R, F_HLLC)
        
        # Case 3: Left wave moves left, contact and right wave move right or are stationary
        # The flux is determined by the left state and the left-star state
        F_HLLC = torch.where(mask3, F_L + S_L * (U_star_L - UL_batch), F_HLLC)
        
        # Case 4: Left wave and contact move left or are stationary, right wave moves right
        # The flux is determined by the right state and the right-star state
        F_HLLC = torch.where(mask4, F_R + S_R * (U_star_R - UR_batch), F_HLLC)
        
        # If any interface falls into an unhandled configuration (should not happen with correct wave speeds)
        # This check is for robustness, though the HLLC conditions should cover all cases.
        if torch.any(~(mask1 | mask2 | mask3 | mask4)):
             logging.error("HLLC solver encountered an unhandled wave configuration for some interfaces.")
             raise ValueError("HLLC solver encountered an unhandled wave configuration for some interfaces.")
             
        return F_HLLC

    def _compute_rhs(self, U_conserved):
        """
        Computes the right-hand side (RHS) of the semi-discrete ODE, L(U).
        It incorporates second-order spatial accuracy through MUSCL reconstruction
        and slope limiting, and applies transmissive boundary conditions.
        Optimized for PyTorch tensors.

        Args:
            U_conserved (torch.Tensor): Current conserved variables. Shape (3, N_cells).

        Returns:
            torch.Tensor: The computed RHS. Shape (3, N_cells).
        """
        # Optimized Part: MUSCL Reconstruction and Spatial Derivative Calculation using PyTorch
        # Prepare extended tensor with ghost cells for boundary conditions
        # U_ext will have N_cells + 2 columns (2 ghost cells + N_cells computational cells)
        U_ext = torch.zeros((3, self.N_cells + 2), dtype=torch.float64, device=self.device)
        U_ext[:, 1:-1] = U_conserved # Copy current U into the interior cells
        
        # Apply outflow boundary conditions to U_ext
        # Left ghost cell takes the value of the first computational cell
        U_ext[:, 0] = U_conserved[:, 0]
        # Right ghost cell takes the value of the last computational cell
        U_ext[:, -1] = U_conserved[:, -1]

        # Convert extended conserved variables to primitive variables for reconstruction (vectorized)
        rho_ext, u_ext, p_ext = self._conserved_to_primitive(U_ext) # (3, N_cells+2) -> (N_cells+2,) for each variable

        # Calculate slopes for primitive variables for all N_cells+2 cells (including ghost cells)
        # Slopes are calculated using central differences (phi_{i+1} - phi_{i-1}) / (2*dx) and then limited.
        # For boundary ghost cells, slopes are copied from adjacent interior cells (transmissive BCs for slopes).
        
        # Initialize full slope tensors (N_cells + 2)
        slopes_rho_full = torch.zeros_like(rho_ext)
        slopes_u_full = torch.zeros_like(u_ext)
        slopes_p_full = torch.zeros_like(p_ext)

        # Compute slopes for interior cells (indices 1 to N_cells in U_ext)
        # These correspond to computational cells 0 to N_cells-1
        # The minmod limiter is applied to the differences (phi_i - phi_{i-1}) and (phi_{i+1} - phi_i).
        slopes_rho_full[1:-1] = self._minmod_limiter(rho_ext[1:-1] - rho_ext[:-2], rho_ext[2:] - rho_ext[1:-1]) / self.dx
        slopes_u_full[1:-1] = self._minmod_limiter(u_ext[1:-1] - u_ext[:-2], u_ext[2:] - u_ext[1:-1]) / self.dx
        slopes_p_full[1:-1] = self._minmod_limiter(p_ext[1:-1] - p_ext[:-2], p_ext[2:] - p_ext[1:-1]) / self.dx

        # Apply transmissive boundary conditions for slopes: copy from adjacent interior cell's slope
        slopes_rho_full[0] = slopes_rho_full[1]
        slopes_rho_full[-1] = slopes_rho_full[-2]
        slopes_u_full[0] = slopes_u_full[1]
        slopes_u_full[-1] = slopes_u_full[-2]
        slopes_p_full[0] = slopes_p_full[1]
        slopes_p_full[-1] = slopes_p_full[-2]

        # Reconstruct left and right states at cell edges for all N_cells+2 cells (vectorized)
        # phi_L_rec_full[i] is the state at the left edge of cell i
        # phi_R_rec_full[i] is the state at the right edge of cell i
        rho_L_rec_full = rho_ext - 0.5 * slopes_rho_full * self.dx
        rho_R_rec_full = rho_ext + 0.5 * slopes_rho_full * self.dx
        u_L_rec_full = u_ext - 0.5 * slopes_u_full * self.dx
        u_R_rec_full = u_ext + 0.5 * slopes_u_full * self.dx
        p_L_rec_full = p_ext - 0.5 * slopes_p_full * self.dx
        p_R_rec_full = p_ext + 0.5 * slopes_p_full * self.dx

        # Ensure positivity of reconstructed density and pressure (numerical safeguard)
        rho_L_rec_full = torch.max(rho_L_rec_full, torch.tensor(1e-12, dtype=torch.float64, device=self.device))
        rho_R_rec_full = torch.max(rho_R_rec_full, torch.tensor(1e-12, dtype=torch.float64, device=self.device))
        p_L_rec_full = torch.max(p_L_rec_full, torch.tensor(1e-12, dtype=torch.float64, device=self.device))
        p_R_rec_full = torch.max(p_R_rec_full, torch.tensor(1e-12, dtype=torch.float64, device=self.device))

        # Construct UL and UR for the N_cells + 1 interfaces (vectorized)
        # For interface j (between cell j and cell j+1 in the U_ext array):
        # UL_interface_batch_prim[:, j] = R_rec from cell j (rho_R_rec_full[j])
        # UR_interface_batch_prim[:, j] = L_rec from cell j+1 (rho_L_rec_full[j+1])
        # These are primitive variables.
        
        # UL_interface_batch_prim will contain the right-extrapolated states of cells 0 to N_cells (N_cells+1 elements)
        UL_interface_batch_prim = torch.stack([rho_R_rec_full[:-1], u_R_rec_full[:-1], p_R_rec_full[:-1]], dim=0)
        # UR_interface_batch_prim will contain the left-extrapolated states of cells 1 to N_cells+1 (N_cells+1 elements)
        UR_interface_batch_prim = torch.stack([rho_L_rec_full[1:], u_L_rec_full[1:], p_L_rec_full[1:]], dim=0)

        # Convert reconstructed primitive states to conserved states for HLLC solver (vectorized)
        UL_interface_batch_cons = self._primitive_to_conserved(UL_interface_batch_prim[0], UL_interface_batch_prim[1], UL_interface_batch_prim[2])
        UR_interface_batch_cons = self._primitive_to_conserved(UR_interface_batch_prim[0], UR_interface_batch_prim[1], UR_interface_batch_prim[2])

        # Compute numerical fluxes at all N_cells + 1 interfaces using the vectorized HLLC solver
        F_numerical = self._hllc_riemann_solver_vectorized(UL_interface_batch_cons, UR_interface_batch_cons)

        # Compute the spatial derivative (RHS of the ODE) for the N_cells computational cells
        # RHS_i = -(F_{i+1/2} - F_{i-1/2}) / dx
        # F_numerical has N_cells + 1 fluxes.
        # F_numerical[:, 1:] corresponds to F_{i+1/2} for i=0 to N_cells-1
        # F_numerical[:, :-1] corresponds to F_{i-1/2} for i=0 to N_cells-1
        rhs = -(F_numerical[:, 1:] - F_numerical[:, :-1]) / self.dx
        return rhs

    def _set_initial_conditions(self):
        """
        Sets the initial conditions for the Sod Shock Tube Problem.
        U is a 3xN_cells tensor, where each row corresponds to a conserved variable
        (rho, rho*u, rho*E) and each column corresponds to a cell.
        Optimized for PyTorch tensors.
        """
        # Define the left state (0 < x <= 0.5)
        rho_L_init = 1.0
        u_L_init = 0.0
        p_L_init = 1.0
        U_L_init_conserved = self._primitive_to_conserved(
            torch.tensor(rho_L_init, dtype=torch.float64, device=self.device),
            torch.tensor(u_L_init, dtype=torch.float64, device=self.device),
            torch.tensor(p_L_init, dtype=torch.float64, device=self.device)
        )

        # Define the right state (0.5 < x < 1)
        rho_R_init = 0.125
        u_R_init = 0.0
        p_R_init = 0.1
        U_R_init_conserved = self._primitive_to_conserved(
            torch.tensor(rho_R_init, dtype=torch.float64, device=self.device),
            torch.tensor(u_R_init, dtype=torch.float64, device=self.device),
            torch.tensor(p_R_init, dtype=torch.float64, device=self.device)
        )

        # Apply initial conditions to the computational cells (vectorized)
        mask_left = self.x_centers <= 0.5
        # Use broadcasting to fill the masked regions
        self.U[:, mask_left] = U_L_init_conserved.unsqueeze(1) # unsqueeze to make it (3,1) for broadcasting
        self.U[:, ~mask_left] = U_R_init_conserved.unsqueeze(1)

    def solve(self):
        """
        Main simulation loop for solving the Euler equations.
        Uses SSP-RK3 time integration with dynamic time step control based on CFL condition.
        """
        logging.info("Starting Euler Equations Simulation (HLLC-MUSCL-SSP-RK3 Scheme)")
        logging.info(f"Domain: [{self.x_min}, {self.x_max}], Number of cells: {self.N_cells}, dx: {self.dx:.4f}")
        logging.info(f"Final time: {self.t_final}, CFL: {self.CFL}, Gamma: {self.gamma}")
        logging.info("\n--- Simulation Progress ---")

        while self.t < self.t_final:
            # Calculate time step (dt) based on the CFL condition
            # dt = CFL * dx / max_wave_speed
            # max_wave_speed = max(|u| + c), where c is the local speed of sound
            rho_current, u_current, p_current = self._conserved_to_primitive(self.U)
            c_current = torch.sqrt(self.gamma * p_current / rho_current)
            max_wave_speed = torch.max(torch.abs(u_current) + c_current)
            
            dt = self.CFL * self.dx / max_wave_speed.item() # .item() to get scalar from 0-dim tensor
            
            # Adjust dt to ensure we don't overshoot the final time
            if self.t + dt > self.t_final:
                dt = self.t_final - self.t
            
            # Optimized Part: Third-Order SSP-RK3 Time Integration using PyTorch
            # This three-stage Runge-Kutta method improves temporal accuracy.
            
            # Stage 1: Compute k1 = L(U^n) and U^(1) = U^n + dt * k1
            k1 = self._compute_rhs(self.U)
            U1 = self.U + dt * k1
            
            # Stage 2: Compute k2 = L(U^(1)) and U^(2) = (3/4) * U^n + (1/4) * (U^(1) + dt * k2)
            k2 = self._compute_rhs(U1)
            U2 = (3/4) * self.U + (1/4) * (U1 + dt * k2)
            
            # Stage 3: Compute k3 = L(U^(2)) and U^(n+1) = (1/3) * U^n + (2/3) * (U^(2) + dt * k3)
            k3 = self._compute_rhs(U2)
            U_new = (1/3) * self.U + (2/3) * (U2 + dt * k3)
            
            # Update the state and time
            self.U = U_new
            self.t += dt
            self.iteration += 1
            
            # Print progress periodically using logging
            if self.iteration % 50 == 0 or self.t >= self.t_final:
                logging.info(f"Time: {self.t:.4f}/{self.t_final:.4f}, dt: {dt:.6f}, Iteration: {self.iteration}")

        logging.info(f"\nSimulation finished at t = {self.t:.4f} after {self.iteration} iterations.")

    def plot_results(self, plot_filename="sod_shock_tube_hllc_muscl_ssp_rk3_pytorch.png"):
        """
        Plots the final density, velocity, and pressure profiles.
        Converts PyTorch tensors to NumPy arrays for plotting.

        Args:
            plot_filename (str): Name of the file to save the plot.
        """
        # Convert the final conserved variables back to primitive variables for plotting
        # Move tensor to CPU and convert to NumPy array for matplotlib
        rho_final, u_final, p_final = self._conserved_to_primitive(self.U.cpu())
        rho_final_np = rho_final.numpy()
        u_final_np = u_final.numpy()
        p_final_np = p_final.numpy()

        # Create a single figure with three subplots to display density, velocity, and pressure
        fig, axs = plt.subplots(3, 1, figsize=(10, 12), sharex=True)
        fig.suptitle(f'Sod Shock Tube Problem at t = {self.t_final:.2f}\n(HLLC-MUSCL-SSP-RK3 Scheme, N={self.N_cells}, PyTorch)', fontsize=16)

        # Plot Density (rho)
        axs[0].plot(self.x_centers_np, rho_final_np, 'b-', label='Density (rho)')
        axs[0].set_ylabel('Density (rho)')
        axs[0].grid(True)
        axs[0].legend()

        # Plot Velocity (u)
        axs[1].plot(self.x_centers_np, u_final_np, 'r-', label='Velocity (u)')
        axs[1].set_ylabel('Velocity (u)')
        axs[1].grid(True)
        axs[1].legend()

        # Plot Pressure (p)
        axs[2].plot(self.x_centers_np, p_final_np, 'g-', label='Pressure (p)')
        axs[2].set_xlabel('Position (x)')
        axs[2].set_ylabel('Pressure (p)')
        axs[2].grid(True)
        axs[2].legend()

        # Adjust layout to prevent titles/labels from overlapping
        plt.tight_layout(rect=[0, 0.03, 1, 0.96])

        # Save the plot to a file without displaying it
        plt.savefig(plot_filename)
        logging.info(f"Plot saved as {plot_filename}")

# Main execution block
if __name__ == "__main__":
    solver = EulerSolver()
    solver.solve()
    solver.plot_results()
```
****************************************
