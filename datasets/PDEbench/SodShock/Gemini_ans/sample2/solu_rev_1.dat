
****************************************
```python
# Import necessary libraries
import numpy as np
import matplotlib.pyplot as plt
import os # Used for saving the plot

# Technical Explanation for the Solving Algorithm
# The refined algorithm is the Finite Volume Method (FVM) with a second-order MUSCL-Hancock
# scheme in space and a second-order Strong Stability Preserving Runge-Kutta (SSP-RK2)
# method in time. The HLLC (Harten-Lax-van Leer-Contact) approximate Riemann solver
# is used to compute numerical fluxes at cell interfaces. This combination provides
# a robust and more accurate solution for hyperbolic conservation laws like the Euler
# equations, especially for problems involving discontinuities such as the Sod shock tube.

# 1. Finite Volume Discretization:
#    The spatial domain [0,1] is divided into N_cells control volumes.
#    The conserved variables U = [rho, rho*u, rho*E]^T are stored as cell-averaged values.
#    The governing equations are integrated over each cell, leading to an update rule:
#    dU_i/dt = -(F_{i+1/2} - F_{i-1/2}) / dx, where F are numerical fluxes.

# 2. MUSCL-Hancock Scheme (Second-Order Spatial Accuracy):
#    To achieve second-order spatial accuracy, the piecewise constant reconstruction
#    of the first-order Godunov scheme is replaced by a piecewise linear reconstruction.
#    a. Primitive Variable Reconstruction: Instead of using cell-averaged conserved
#       variables directly, primitive variables (rho, u, p) are reconstructed to
#       the left and right edges of each cell. This involves calculating slopes
#       for each primitive variable within each cell.
#    b. Slope Limiting: To prevent spurious oscillations (Gibbs phenomenon) near
#       discontinuities (shocks, contact discontinuities), a slope limiter (Minmod)
#       is applied to the gradients used for reconstruction. This ensures that the
#       reconstructed states remain monotonic.
#    c. Interface States: For each cell interface (e.g., between cell i and cell i+1),
#       the left state (UL) for the Riemann problem is the right-extrapolated state
#       from cell i, and the right state (UR) is the left-extrapolated state from cell i+1.
#       These reconstructed states are then converted to conserved variables before
#       being passed to the Riemann solver.

# 3. HLLC Riemann Solver (Vectorized):
#    The HLLC solver computes the numerical flux F at each cell interface.
#    It is an approximate Riemann solver that accounts for the contact discontinuity.
#    The key improvement in this version is the **vectorization** of the HLLC solver.
#    Instead of looping through each interface, the solver now processes all interfaces
#    simultaneously using NumPy array operations. This involves:
#    a. Batch Processing: Input states (UL, UR) are provided as arrays for all interfaces.
#    b. Parallel Calculation of Intermediate Values: All wave speeds (S_L, S_R, S_star),
#       star region pressures, and densities are computed for all interfaces in parallel.
#    c. Conditional Flux Selection: NumPy's `np.where` function is used to select the
#       appropriate HLLC flux based on the wave speed conditions for each interface,
#       eliminating the Python `if/elif/else` branching within a loop. This significantly
#       improves performance for large numbers of cells.

# 4. SSP-RK2 Time Integration (Second-Order Temporal Accuracy):
#    An explicit second-order Strong Stability Preserving Runge-Kutta (SSP-RK2) method
#    is used for time integration. This method involves two stages:
#    U^(1) = U^n + dt * L(U^n)
#    U^(n+1) = 0.5 * U^n + 0.5 * (U^(1) + dt * L(U^(1)))
#    where L(U) represents the spatial discretization operator (the right-hand side
#    of the semi-discrete equation, i.e., -(F_{i+1/2} - F_{i-1/2}) / dx).
#    This two-stage process improves temporal accuracy compared to the first-order
#    explicit Euler method, allowing for larger stable time steps while maintaining accuracy.

# 5. Boundary Conditions:
#    Transmissive (outflow) boundary conditions are applied using ghost cells.
#    The values in the ghost cells are simply copied from the adjacent interior cells
#    for both cell-averaged values and reconstructed slopes/states.

# 6. Primitive and Conserved Variable Conversion:
#    Helper functions handle conversions between primitive (rho, u, p) and conserved
#    (rho, rho*u, rho*E) variables, which are essential for initialization,
#    reconstruction, flux computation, and post-processing.

# The combination of MUSCL-Hancock with HLLC and SSP-RK2 provides a robust,
# second-order accurate scheme suitable for capturing complex wave structures
# in the Euler equations with reduced numerical diffusion compared to first-order methods.

class EulerSolver:
    # Constants and Parameters
    def __init__(self, gamma=1.4, CFL=0.8, N_cells=200, x_min=0.0, x_max=1.0, t_final=0.2):
        self.gamma = gamma
        self.CFL = CFL
        self.N_cells = N_cells
        self.x_min = x_min
        self.x_max = x_max
        self.t_final = t_final

        # Discretization
        self.dx = (self.x_max - self.x_min) / self.N_cells
        self.x_centers = np.linspace(self.x_min + 0.5 * self.dx, self.x_max - 0.5 * self.dx, self.N_cells)

        # Initialize conserved variables U = [rho, rho*u, rho*E]
        self.U = np.zeros((3, self.N_cells))
        self._set_initial_conditions()

        self.t = 0.0
        self.iteration = 0

    # Helper Functions for State Conversion
    def _primitive_to_conserved(self, rho, u, p):
        # Calculates conserved variables from primitive variables
        # Conserved variables: U = [rho, rho*u, rho*E]
        # Total specific energy E = 0.5 * u^2 + p / ((gamma - 1) * rho)
        rho_u = rho * u
        rho_E = rho * (0.5 * u**2 + p / ((self.gamma - 1) * rho))
        return np.array([rho, rho_u, rho_E])

    def _conserved_to_primitive(self, U_conserved):
        # Calculates primitive variables from conserved variables
        # Conserved variables: U = [rho, rho_u, rho_E]
        # Primitive variables: rho, u, p
        rho = U_conserved[0]
        u = U_conserved[1] / rho
        # Pressure calculation: p = (gamma - 1) * (rho_E - 0.5 * rho_u^2 / rho)
        p = (self.gamma - 1) * (U_conserved[2] - 0.5 * U_conserved[1]**2 / rho)
        # Numerical safeguard: ensure pressure is non-negative
        p = np.maximum(p, 1e-12) # Small positive value to prevent negative pressure
        return np.array([rho, u, p])

    def _compute_flux(self, U_conserved):
        # Computes the physical flux vector F from conserved variables
        # F = [rho*u, rho*u^2 + p, (rho*E + p)*u]
        rho, u, p = self._conserved_to_primitive(U_conserved)
        rho_u = U_conserved[1] # Momentum (rho*u)
        rho_E = U_conserved[2] # Total energy (rho*E)
        
        flux_rho = rho_u
        flux_rho_u = rho_u * u + p
        flux_rho_E = (rho_E + p) * u
        return np.array([flux_rho, flux_rho_u, flux_rho_E])

    # Slope Limiter (Minmod)
    def _minmod_limiter(self, a, b):
        # Minmod function: minmod(a,b) = sign(a) * max(0, min(|a|, b*sign(a)))
        # This implementation returns 0 if a and b have different signs,
        # otherwise it returns the value with the smaller magnitude and the common sign.
        return np.where(a * b > 0, np.sign(a) * np.minimum(np.abs(a), np.abs(b)), 0.0)

    # Optimized Part: Vectorized HLLC Riemann Solver
    # This function now takes batch inputs (arrays of states) and returns batch outputs (arrays of fluxes).
    def _hllc_riemann_solver_vectorized(self, UL_batch, UR_batch):
        # UL_batch, UR_batch are conserved variable arrays for left and right states
        # at multiple interfaces, shape (3, N_interfaces)

        # Convert conserved to primitive variables for both states (vectorized)
        rho_L, u_L, p_L = self._conserved_to_primitive(UL_batch)
        rho_R, u_R, p_R = self._conserved_to_primitive(UR_batch)

        # Calculate speed of sound for both states (vectorized)
        c_L = np.sqrt(self.gamma * p_L / rho_L)
        c_R = np.sqrt(self.gamma * p_R / rho_R)

        # Estimate pressure in the star region (p_star_guess) for wave speed estimation (vectorized)
        p_star_guess = 0.5 * (p_L + p_R) + 0.5 * (u_L - u_R) * (rho_L * c_L + rho_R * c_R)
        p_star_guess = np.maximum(1e-12, p_star_guess) # Ensure positive pressure

        # Calculate q_L and q_R factors for shock wave speed estimation (vectorized)
        q_L = np.ones_like(p_L)
        mask_L_shock = p_star_guess > p_L
        q_L[mask_L_shock] = np.sqrt(1 + (self.gamma + 1)/(2*self.gamma) * (p_star_guess[mask_L_shock]/p_L[mask_L_shock] - 1))
        
        q_R = np.ones_like(p_R)
        mask_R_shock = p_star_guess > p_R
        q_R[mask_R_shock] = np.sqrt(1 + (self.gamma + 1)/(2*self.gamma) * (p_star_guess[mask_R_shock]/p_R[mask_R_shock] - 1))

        # Estimate the fastest left (S_L) and right (S_R) wave speeds (vectorized)
        S_L = u_L - c_L * q_L
        S_R = u_R + c_R * q_R

        # Calculate the contact discontinuity speed (S_star) (vectorized)
        # Add a small epsilon to denominator to prevent division by zero in edge cases
        denominator = (rho_L * (S_L - u_L) - rho_R * (S_R - u_R))
        # Use np.where to handle potential zero denominator gracefully
        S_star = np.where(np.abs(denominator) < 1e-12, 
                          (p_R - p_L + rho_L * u_L * (S_L - u_L) - rho_R * u_R * (S_R - u_R)) / (denominator + 1e-12 * np.sign(denominator)),
                          (p_R - p_L + rho_L * u_L * (S_L - u_L) - rho_R * u_R * (S_R - u_R)) / denominator)

        # Compute the physical fluxes for the left and right states (vectorized)
        F_L = self._compute_flux(UL_batch)
        F_R = self._compute_flux(UR_batch)

        # Extract total specific energies for left and right states (vectorized)
        E_L = UL_batch[2] / UL_batch[0]
        E_R = UR_batch[2] / UR_batch[0]

        # Calculate the total specific energies in the star regions (E_star_L, E_star_R) (vectorized)
        E_star_L = E_L + (S_star - u_L) * (S_star + p_L / (rho_L * (S_L - u_L)))
        E_star_R = E_R + (S_star - u_R) * (S_star + p_R / (rho_R * (S_R - u_R)))

        # Calculate densities in the star regions (rho_star_L, rho_star_R) (vectorized)
        rho_star_L = rho_L * (S_L - u_L) / (S_L - S_star)
        rho_star_R = rho_R * (S_R - u_R) / (S_R - S_star)

        # Construct the conserved variable vectors for the star regions (U_star_L, U_star_R) (vectorized)
        U_star_L = np.array([rho_star_L, rho_star_L * S_star, rho_star_L * E_star_L])
        U_star_R = np.array([rho_star_R, rho_star_R * S_star, rho_star_R * E_star_R])

        # Determine the HLLC flux based on the wave speeds using np.where (vectorized)
        F_HLLC = np.zeros_like(F_L)

        # Define masks for each case
        mask1 = S_L >= 0
        mask2 = S_R <= 0
        mask3 = (S_L < 0) & (S_star >= 0)
        mask4 = (S_star < 0) & (S_R > 0)
        
        # Apply fluxes based on masks. np.where allows for conditional assignment.
        # The order of application matters if masks overlap, but for HLLC, these are typically disjoint.
        # We can use a nested np.where or sequential assignment. Sequential assignment is clear here.
        
        # Case 1: All waves are moving to the right, so the flux is F_L
        F_HLLC = np.where(mask1, F_L, F_HLLC)
        
        # Case 2: All waves are moving to the left, so the flux is F_R
        F_HLLC = np.where(mask2, F_R, F_HLLC)
        
        # Case 3: Left wave moves left, contact and right wave move right or are stationary
        # The flux is determined by the left state and the left-star state
        F_HLLC = np.where(mask3, F_L + S_L * (U_star_L - UL_batch), F_HLLC)
        
        # Case 4: Left wave and contact move left or are stationary, right wave moves right
        # The flux is determined by the right state and the right-star state
        F_HLLC = np.where(mask4, F_R + S_R * (U_star_R - UR_batch), F_HLLC)
        
        # If any interface falls into an unhandled configuration (should not happen with correct wave speeds)
        # This check is for robustness, though the HLLC conditions should cover all cases.
        if np.any(~(mask1 | mask2 | mask3 | mask4)):
             raise ValueError("HLLC solver encountered an unhandled wave configuration for some interfaces.")
             
        return F_HLLC

    # Optimized Part: MUSCL Reconstruction and Spatial Derivative Calculation
    # This function computes the right-hand side (RHS) of the semi-discrete ODE, L(U).
    # It incorporates second-order spatial accuracy through MUSCL reconstruction and slope limiting.
    def _compute_rhs(self, U_conserved):
        # Prepare extended array with ghost cells for boundary conditions
        # U_ext will have N_cells + 2 columns (2 ghost cells + N_cells computational cells)
        U_ext = np.zeros((3, self.N_cells + 2))
        U_ext[:, 1:-1] = U_conserved # Copy current U into the interior cells
        
        # Apply outflow boundary conditions to U_ext
        # Left ghost cell takes the value of the first computational cell
        U_ext[:, 0] = U_conserved[:, 0]
        # Right ghost cell takes the value of the last computational cell
        U_ext[:, -1] = U_conserved[:, -1]

        # Convert extended conserved variables to primitive variables for reconstruction (vectorized)
        rho_ext, u_ext, p_ext = self._conserved_to_primitive(U_ext) # (3, N_cells+2) -> (N_cells+2,) for each variable

        # Calculate slopes for primitive variables for all N_cells+2 cells (including ghost cells)
        # Slopes are calculated using central differences (phi_{i+1} - phi_{i-1}) / (2*dx) and then limited.
        # For boundary ghost cells, slopes are copied from adjacent interior cells (transmissive BCs for slopes).
        
        # Initialize full slope arrays (N_cells + 2)
        slopes_rho_full = np.zeros_like(rho_ext)
        slopes_u_full = np.zeros_like(u_ext)
        slopes_p_full = np.zeros_like(p_ext)

        # Compute slopes for interior cells (indices 1 to N_cells in U_ext)
        # These correspond to computational cells 0 to N_cells-1
        slopes_rho_full[1:-1] = self._minmod_limiter(rho_ext[1:-1] - rho_ext[:-2], rho_ext[2:] - rho_ext[1:-1]) / self.dx
        slopes_u_full[1:-1] = self._minmod_limiter(u_ext[1:-1] - u_ext[:-2], u_ext[2:] - u_ext[1:-1]) / self.dx
        slopes_p_full[1:-1] = self._minmod_limiter(p_ext[1:-1] - p_ext[:-2], p_ext[2:] - p_ext[1:-1]) / self.dx

        # Apply transmissive boundary conditions for slopes: copy from adjacent interior cell's slope
        slopes_rho_full[0] = slopes_rho_full[1]
        slopes_rho_full[-1] = slopes_rho_full[-2]
        slopes_u_full[0] = slopes_u_full[1]
        slopes_u_full[-1] = slopes_u_full[-2]
        slopes_p_full[0] = slopes_p_full[1]
        slopes_p_full[-1] = slopes_p_full[-2]

        # Reconstruct left and right states at cell edges for all N_cells+2 cells (vectorized)
        # phi_L_rec_full[i] is the state at the left edge of cell i
        # phi_R_rec_full[i] is the state at the right edge of cell i
        rho_L_rec_full = rho_ext - 0.5 * slopes_rho_full * self.dx
        rho_R_rec_full = rho_ext + 0.5 * slopes_rho_full * self.dx
        u_L_rec_full = u_ext - 0.5 * slopes_u_full * self.dx
        u_R_rec_full = u_ext + 0.5 * slopes_u_full * self.dx
        p_L_rec_full = p_ext - 0.5 * slopes_p_full * self.dx
        p_R_rec_full = p_ext + 0.5 * slopes_p_full * self.dx

        # Ensure positivity of reconstructed density and pressure (numerical safeguard)
        rho_L_rec_full = np.maximum(rho_L_rec_full, 1e-12)
        rho_R_rec_full = np.maximum(rho_R_rec_full, 1e-12)
        p_L_rec_full = np.maximum(p_L_rec_full, 1e-12)
        p_R_rec_full = np.maximum(p_R_rec_full, 1e-12)

        # Construct UL and UR for the N_cells + 1 interfaces (vectorized)
        # For interface j (between cell j and cell j+1 in the U_ext array):
        # UL_interface_batch_prim[:, j] = R_rec from cell j (rho_R_rec_full[j])
        # UR_interface_batch_prim[:, j] = L_rec from cell j+1 (rho_L_rec_full[j+1])
        # These are primitive variables.
        
        # UL_interface_batch_prim will contain the right-extrapolated states of cells 0 to N_cells (N_cells+1 elements)
        UL_interface_batch_prim = np.array([rho_R_rec_full[:-1], u_R_rec_full[:-1], p_R_rec_full[:-1]])
        # UR_interface_batch_prim will contain the left-extrapolated states of cells 1 to N_cells+1 (N_cells+1 elements)
        UR_interface_batch_prim = np.array([rho_L_rec_full[1:], u_L_rec_full[1:], p_L_rec_full[1:]])

        # Convert reconstructed primitive states to conserved states for HLLC solver (vectorized)
        UL_interface_batch_cons = self._primitive_to_conserved(UL_interface_batch_prim[0], UL_interface_batch_prim[1], UL_interface_batch_prim[2])
        UR_interface_batch_cons = self._primitive_to_conserved(UR_interface_batch_prim[0], UR_interface_batch_prim[1], UR_interface_batch_prim[2])

        # Compute numerical fluxes at all N_cells + 1 interfaces using the vectorized HLLC solver
        F_numerical = self._hllc_riemann_solver_vectorized(UL_interface_batch_cons, UR_interface_batch_cons)

        # Compute the spatial derivative (RHS of the ODE) for the N_cells computational cells
        # RHS_i = -(F_{i+1/2} - F_{i-1/2}) / dx
        # F_numerical has N_cells + 1 fluxes.
        # F_numerical[:, 1:] corresponds to F_{i+1/2} for i=0 to N_cells-1
        # F_numerical[:, :-1] corresponds to F_{i-1/2} for i=0 to N_cells-1
        rhs = -(F_numerical[:, 1:] - F_numerical[:, :-1]) / self.dx
        return rhs

    def _set_initial_conditions(self):
        # Initial Conditions (Sod Shock Tube Problem)
        # U is a 3xN_cells array, where each row corresponds to a conserved variable
        # (rho, rho*u, rho*E) and each column corresponds to a cell.

        # Define the left state (0 < x <= 0.5)
        rho_L_init = 1.0
        u_L_init = 0.0
        p_L_init = 1.0
        U_L_init_conserved = self._primitive_to_conserved(rho_L_init, u_L_init, p_L_init)

        # Define the right state (0.5 < x < 1)
        rho_R_init = 0.125
        u_R_init = 0.0
        p_R_init = 0.1
        U_R_init_conserved = self._primitive_to_conserved(rho_R_init, u_R_init, p_R_init)

        # Apply initial conditions to the computational cells (vectorized)
        mask_left = self.x_centers <= 0.5
        # Use np.newaxis to broadcast the 3-element column vector to fill multiple columns
        self.U[:, mask_left] = U_L_init_conserved[:, np.newaxis] 
        self.U[:, ~mask_left] = U_R_init_conserved[:, np.newaxis]

    # Main Simulation Loop
    def solve(self):
        print("Starting Euler Equations Simulation (HLLC-MUSCL-SSP-RK2 Scheme)")
        print(f"Domain: [{self.x_min}, {self.x_max}], Number of cells: {self.N_cells}, dx: {self.dx:.4f}")
        print(f"Final time: {self.t_final}, CFL: {self.CFL}, Gamma: {self.gamma}")
        print("\n--- Simulation Progress ---")

        while self.t < self.t_final:
            # Calculate time step (dt) based on the CFL condition
            # dt = CFL * dx / max_wave_speed
            # max_wave_speed = max(|u| + c), where c is the local speed of sound
            rho_current, u_current, p_current = self._conserved_to_primitive(self.U)
            c_current = np.sqrt(self.gamma * p_current / rho_current)
            max_wave_speed = np.max(np.abs(u_current) + c_current)
            
            dt = self.CFL * self.dx / max_wave_speed
            
            # Adjust dt to ensure we don't overshoot the final time
            if self.t + dt > self.t_final:
                dt = self.t_final - self.t
            
            # Optimized Part: Second-Order SSP-RK2 Time Integration
            # This two-stage Runge-Kutta method improves temporal accuracy.
            
            # Stage 1: Compute k1 = L(U^n) and U_star = U^n + dt * k1
            k1 = self._compute_rhs(self.U)
            U_star = self.U + dt * k1
            
            # Stage 2: Compute k2 = L(U_star) and U^(n+1) = 0.5 * U^n + 0.5 * (U_star + dt * k2)
            # The _compute_rhs function internally handles ghost cells for U_star.
            k2 = self._compute_rhs(U_star)
            U_new = 0.5 * self.U + 0.5 * (U_star + dt * k2)
            
            # Update the state and time
            self.U = U_new
            self.t += dt
            self.iteration += 1
            
            # Print progress periodically
            if self.iteration % 50 == 0 or self.t >= self.t_final:
                print(f"Time: {self.t:.4f}/{self.t_final:.4f}, dt: {dt:.6f}, Iteration: {self.iteration}")

        print(f"\nSimulation finished at t = {self.t:.4f} after {self.iteration} iterations.")

    # Post-processing and Plotting
    def plot_results(self, plot_filename="sod_shock_tube_hllc_muscl_ssp_rk2.png"):
        # Convert the final conserved variables back to primitive variables for plotting
        rho_final, u_final, p_final = self._conserved_to_primitive(self.U)

        # Create a single figure with three subplots to display density, velocity, and pressure
        fig, axs = plt.subplots(3, 1, figsize=(10, 12), sharex=True)
        fig.suptitle(f'Sod Shock Tube Problem at t = {self.t_final:.2f}\n(HLLC-MUSCL-SSP-RK2 Scheme, N={self.N_cells})', fontsize=16)

        # Plot Density (rho)
        axs[0].plot(self.x_centers, rho_final, 'b-', label='Density (rho)')
        axs[0].set_ylabel('Density (rho)')
        axs[0].grid(True)
        axs[0].legend()

        # Plot Velocity (u)
        axs[1].plot(self.x_centers, u_final, 'r-', label='Velocity (u)')
        axs[1].set_ylabel('Velocity (u)')
        axs[1].grid(True)
        axs[1].legend()

        # Plot Pressure (p)
        axs[2].plot(self.x_centers, p_final, 'g-', label='Pressure (p)')
        axs[2].set_xlabel('Position (x)')
        axs[2].set_ylabel('Pressure (p)')
        axs[2].grid(True)
        axs[2].legend()

        # Adjust layout to prevent titles/labels from overlapping
        plt.tight_layout(rect=[0, 0.03, 1, 0.96])

        # Save the plot to a file without displaying it
        plt.savefig(plot_filename)
        print(f"Plot saved as {plot_filename}")

# Main execution block
if __name__ == "__main__":
    solver = EulerSolver()
    solver.solve()
    solver.plot_results()
```
****************************************
