
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt
import scipy # Included as per requirement, though not explicitly used for core solver
import torch # Included as per requirement, though not explicitly used for core solver

# Technical explanation for the solving algorithm:
# This code implements a Finite Volume Method (FVM) to solve the 1D Euler equations,
# which describe the conservation of mass, momentum, and energy for compressible,
# inviscid fluid flow. The FVM approach ensures conservation by integrating the
# equations over discrete control volumes (cells) and computing fluxes at cell interfaces.
#
# The core of this solver is the HLLC (Harten-Lax-van Leer-Contact) approximate Riemann solver.
# The Euler equations are a system of hyperbolic conservation laws, and discontinuities
# (like shocks and contact discontinuities) can form. A Riemann solver is used at each
# cell interface to determine the numerical flux, which represents the flow of conserved
# quantities between cells.
#
# The HLLC solver is chosen for its balance of accuracy and computational efficiency.
# It approximates the solution to the Riemann problem by assuming a three-wave structure:
# a left-going wave (speed SL), a right-going wave (speed SR), and a contact discontinuity
# (speed S_star) in between. Unlike the simpler HLL solver, HLLC explicitly resolves
# the contact discontinuity, leading to sharper resolution of these features.
#
# The steps involved in the HLLC solver are:
# 1. Convert conserved variables (density, momentum, total energy) to primitive variables
#    (density, velocity, pressure) for both left and right states at an interface.
# 2. Calculate the speed of sound for both states.
# 3. Estimate the left (SL) and right (SR) wave speeds. These are typically chosen as
#    the minimum and maximum characteristic speeds (eigenvalues of the flux Jacobian)
#    from the left and right states.
# 4. Calculate the contact wave speed (S_star) and the pressure in the star region (p_star)
#    using jump conditions across the waves.
# 5. Based on the signs of SL, S_star, and SR, determine which region of the Riemann fan
#    the interface falls into.
# 6. Compute the numerical flux (F_HLLC) using the appropriate state (left, right, or
#    one of the two star states separated by the contact discontinuity).
#
# The time integration is performed using an explicit Euler scheme, which is first-order
# accurate in time. The time step (dt) is determined by the CFL (Courant-Friedrichs-Lewy)
# condition to ensure numerical stability, based on the maximum characteristic speed in the domain.
#
# Boundary conditions are handled using zero-order extrapolation (transmissive) for ghost cells.
#
# The simulation proceeds by repeatedly:
# 1. Applying boundary conditions.
# 2. Calculating numerical fluxes at all cell interfaces using the HLLC solver.
# 3. Updating the conserved variables in each cell using the finite volume update formula.
# 4. Incrementing time and adjusting the time step.
#
# Finally, the conserved variables are converted back to primitive variables for plotting
# density, velocity, and pressure at the specified final time.

# Define constants
GAMMA = 1.4 # Ratio of specific heats for an ideal gas

# Function to convert primitive variables (rho, u, p) to conserved variables (rho, rho*u, rho*E)
# This function is designed to work with scalar inputs or broadcasted NumPy arrays.
def primitive_to_conserved(rho, u, p):
    # E = total specific energy
    # E = 0.5 * u^2 + p / ((gamma - 1) * rho)
    # rho*E = 0.5 * rho * u^2 + p / (gamma - 1)
    rho_u = rho * u
    rho_E = 0.5 * rho * u**2 + p / (GAMMA - 1)
    # Stacking along the last axis to get shape (N, 3) if inputs are (N,)
    return np.stack([rho, rho_u, rho_E], axis=-1)

# Function to convert conserved variables (rho, rho*u, rho*E) to primitive variables (rho, u, p)
# This function is vectorized to handle arrays of conserved states.
def conserved_to_primitive_vectorized(U_arr):
    # U_arr is expected to be of shape (N, 3) where N is the number of states
    rho = U_arr[..., 0]
    rho_u = U_arr[..., 1]
    rho_E = U_arr[..., 2]

    # Optimization: Enforce minimum density and pressure for numerical stability.
    # This prevents division by zero or sqrt of negative numbers, which were
    # identified as causes for NaN/Inf issues in the previous run.
    rho = np.maximum(rho, 1e-12) # Ensure density is always positive

    u = rho_u / rho

    # Compute pressure
    p = (GAMMA - 1) * (rho_E - 0.5 * rho * u**2)

    # Optimization: Enforce minimum pressure to prevent unphysical negative pressures.
    p = np.maximum(p, 1e-12) # Ensure pressure is always positive

    return rho, u, p

# Function to compute the physical flux F for a given conserved state U
# This function is vectorized to handle arrays of conserved states.
def compute_flux_vectorized(U_arr):
    # U_arr is expected to be of shape (N, 3)
    rho, u, p = conserved_to_primitive_vectorized(U_arr)
    
    # F = [rho*u, rho*u^2 + p, (rho*E + p)*u]
    # Note: rho*E is U_arr[..., 2]
    flux_rho = rho * u
    flux_rho_u = rho * u**2 + p
    flux_rho_E = (U_arr[..., 2] + p) * u
    
    # Stacking along the last axis to get shape (N, 3)
    return np.stack([flux_rho, flux_rho_u, flux_rho_E], axis=-1)

# HLLC Riemann Solver (vectorized version)
def hllc_solver_vectorized(UL_conserved_arr, UR_conserved_arr):
    # UL_conserved_arr and UR_conserved_arr are expected to be of shape (N_interfaces, 3)

    # Convert conserved states to primitive states
    rhoL, uL, pL = conserved_to_primitive_vectorized(UL_conserved_arr)
    rhoR, uR, pR = conserved_to_primitive_vectorized(UR_conserved_arr)

    # Calculate speeds of sound
    cL = np.sqrt(GAMMA * pL / rhoL)
    cR = np.sqrt(GAMMA * pR / rhoR)

    # Estimate wave speeds SL, SR (Toro's 1999, Chapter 10, Eq. 10.30)
    # These are the fastest left-going and right-going characteristic speeds
    SL = np.minimum(uL - cL, uR - cR)
    SR = np.maximum(uL + cL, uR + cR)

    # Calculate S_star (contact wave speed) using Eq. 10.42 from Toro's book
    # This formula is derived from the equality of pressure and velocity across the contact
    # discontinuity in the star region.
    num = pR - pL + rhoL * uL * (SL - uL) - rhoR * uR * (SR - uR)
    den = rhoL * (SL - uL) - rhoR * (SR - uR)
    
    # Optimization: Handle potential division by zero in 'den' for S_star calculation.
    # Replace very small denominators with a small non-zero value to prevent NaN/Inf.
    den = np.where(np.abs(den) < 1e-12, 1e-12, den)
    S_star = num / den

    # Calculate p_star (pressure in star region) using Eq. 10.43 from Toro's book
    # This formula is derived from the jump condition across the left shock/rarefaction wave.
    p_star = pL + rhoL * (SL - uL) * (S_star - uL)
    
    # Optimization: Ensure p_star is non-negative.
    p_star = np.maximum(p_star, 1e-12)

    # Calculate the HLLC flux based on the wave speeds
    FL_arr = compute_flux_vectorized(UL_conserved_arr)
    FR_arr = compute_flux_vectorized(UR_conserved_arr)

    # Calculate star states U_star_L and U_star_R
    # Need to handle division by zero if SL - S_star or SR - S_star is zero
    # This can happen if S_star is equal to SL or SR, which implies a strong shock or contact.
    # For robustness, add a small epsilon to the denominator or use np.where.
    
    # For rho_star_L
    den_L_star = (SL - S_star)
    rho_star_L = rhoL * (SL - uL) / np.where(np.abs(den_L_star) < 1e-12, 1e-12, den_L_star)
    rho_star_L = np.maximum(rho_star_L, 1e-12) # Ensure positive density in star state

    u_star_L = S_star
    E_star_L = p_star / ((GAMMA - 1) * rho_star_L) + 0.5 * S_star**2
    U_star_L_arr = np.stack([rho_star_L, rho_star_L * u_star_L, rho_star_L * E_star_L], axis=-1)
    
    # For rho_star_R
    den_R_star = (SR - S_star)
    rho_star_R = rhoR * (SR - uR) / np.where(np.abs(den_R_star) < 1e-12, 1e-12, den_R_star)
    rho_star_R = np.maximum(rho_star_R, 1e-12) # Ensure positive density in star state

    u_star_R = S_star
    E_star_R = p_star / ((GAMMA - 1) * rho_star_R) + 0.5 * S_star**2
    U_star_R_arr = np.stack([rho_star_R, rho_star_R * u_star_R, rho_star_R * E_star_R], axis=-1)

    # Optimization: Compute F_star_L and F_star_R using the jump condition formula.
    # This is more consistent with the HLLC derivation and can be more numerically stable
    # than recomputing fluxes from the star states.
    # F_star = F + S * (U_star - U)
    F_star_L_arr = FL_arr + SL[:, np.newaxis] * (U_star_L_arr - UL_conserved_arr)
    F_star_R_arr = FR_arr + SR[:, np.newaxis] * (U_star_R_arr - UR_conserved_arr)

    # Initialize output flux array with zeros, shape (N_interfaces, 3)
    flux_HLLC = np.zeros_like(FL_arr)

    # Select the appropriate flux based on wave speeds using vectorized conditions (np.where)
    # This replaces the sequential if/elif/else structure with parallel array operations.

    # Region 1: SL >= 0 (all waves to the right, flux is FL)
    mask1 = (SL >= 0)
    flux_HLLC[mask1] = FL_arr[mask1]

    # Region 2: SL < 0 and S_star >= 0 (left wave left, contact/right wave right/stationary, flux is F_star_L)
    mask2 = (SL < 0) & (S_star >= 0)
    flux_HLLC[mask2] = F_star_L_arr[mask2]

    # Region 3: S_star < 0 and SR >= 0 (left wave/contact left, right wave right/stationary, flux is F_star_R)
    mask3 = (S_star < 0) & (SR >= 0)
    flux_HLLC[mask3] = F_star_R_arr[mask3]

    # Region 4: SR < 0 (all waves to the left, flux is FR)
    mask4 = (SR < 0)
    flux_HLLC[mask4] = FR_arr[mask4]
    
    return flux_HLLC

# Main simulation function
def solve_euler_equations():
    # Simulation parameters
    x_min, x_max = 0.0, 1.0 # Spatial domain
    t_final = 0.2 # Final simulation time
    N_cells = 200 # Number of computational cells
    CFL = 0.5 # Courant-Friedrichs-Lewy number for stability. Reduced from 0.9 for better stability.
    num_ghost_cells = 2 # Number of ghost cells on each side for boundary conditions

    # Grid setup
    dx = (x_max - x_min) / N_cells # Cell size
    # Cell centers for plotting. These are the centers of the computational cells.
    x_centers = np.linspace(x_min + 0.5 * dx, x_max - 0.5 * dx, N_cells)
    
    # Initialize conserved variables array U
    # U has shape (N_total_cells, 3) where 3 corresponds to [rho, rho*u, rho*E]
    # Add ghost cells to the total number of cells
    U = np.zeros((N_cells + 2 * num_ghost_cells, 3))

    # Set initial conditions (Sod shock tube problem)
    # Left state: (rho, u, p) = (1.0, 0.0, 1.0) for x <= 0.5
    # Right state: (rho, u, p) = (0.125, 0.0, 0.1) for x > 0.5
    
    # Initialize computational cells (excluding ghost cells)
    # Create arrays for initial primitive variables
    rho_init_arr = np.zeros(N_cells)
    u_init_arr = np.zeros(N_cells)
    p_init_arr = np.zeros(N_cells)

    left_state_mask = x_centers <= 0.5
    right_state_mask = x_centers > 0.5

    rho_init_arr[left_state_mask] = 1.0
    u_init_arr[left_state_mask] = 0.0
    p_init_arr[left_state_mask] = 1.0

    rho_init_arr[right_state_mask] = 0.125
    u_init_arr[right_state_mask] = 0.0
    p_init_arr[right_state_mask] = 0.1
    
    # Convert initial primitive variables to conserved variables in a vectorized manner
    U[num_ghost_cells : N_cells + num_ghost_cells] = primitive_to_conserved(rho_init_arr, u_init_arr, p_init_arr)

    # Time integration loop
    t = 0.0
    iteration = 0
    print("Detailed Result Printing:")
    print("--------------------------------------------------")
    print(f"Simulation Parameters:")
    print(f"  Spatial Domain: [{x_min}, {x_max}]")
    print(f"  Number of Computational Cells: {N_cells}")
    print(f"  Cell Size (dx): {dx:.6f}")
    print(f"  Final Simulation Time (t_final): {t_final}")
    print(f"  CFL Number: {CFL}")
    print(f"  Number of Ghost Cells per side: {num_ghost_cells}")
    print("--------------------------------------------------")
    print("Starting Time Integration Loop...")

    while t < t_final:
        # Apply boundary conditions (zero-order extrapolation for ghost cells)
        # Left ghost cells take values from the first computational cell
        U[0:num_ghost_cells] = U[num_ghost_cells]
        # Right ghost cells take values from the last computational cell
        U[N_cells + num_ghost_cells : N_cells + 2 * num_ghost_cells] = U[N_cells + num_ghost_cells - 1]

        # Optimization: Convert all conserved variables to primitive variables once per time step.
        # This avoids redundant conversions inside the flux calculation loop if it were not vectorized.
        # Also used for CFL condition calculation.
        rho_all, u_all, p_all = conserved_to_primitive_vectorized(U)
        
        # Calculate speed of sound for all cells
        c_all = np.sqrt(GAMMA * p_all / rho_all)
        
        # Calculate maximum characteristic speed in the domain for CFL condition
        # Use only computational cells for max speed calculation to avoid boundary effects
        max_char_speed = np.max(np.abs(u_all[num_ghost_cells:-num_ghost_cells]) + c_all[num_ghost_cells:-num_ghost_cells])
        
        # Determine time step dt based on CFL condition
        # Optimization: Added a check for max_char_speed being zero to prevent division by zero.
        if max_char_speed < 1e-12: # If flow is stationary or near-stationary
            dt = t_final - t # Take a large step to finish, or handle as error
            print("Warning: Max characteristic speed near zero. Taking large dt.")
        else:
            dt = CFL * dx / max_char_speed
        
        # Ensure we don't overshoot t_final in the last step
        if t + dt > t_final:
            dt = t_final - t
        
        # Optimization: Compute numerical fluxes at all cell interfaces in a vectorized manner.
        # This significantly reduces computation time compared to a Python loop.
        # UL is the state to the left of interface i+1/2
        # UR is the state to the right of interface i+1/2
        # For N_cells computational cells, there are N_cells+1 interfaces.
        # The interfaces are between U[i] and U[i+1] in the padded array.
        # So, UL_conserved_arr corresponds to U[num_ghost_cells] to U[N_cells + num_ghost_cells]
        # And UR_conserved_arr corresponds to U[num_ghost_cells+1] to U[N_cells + num_ghost_cells+1]
        UL_interface_states = U[num_ghost_cells : N_cells + num_ghost_cells + 1]
        UR_interface_states = U[num_ghost_cells + 1 : N_cells + num_ghost_cells + 2]
        
        fluxes = hllc_solver_vectorized(UL_interface_states, UR_interface_states)

        # Update conserved variables for computational cells using finite volume method
        # U_new[i] = U_old[i] - (dt/dx) * (F_{i+1/2} - F_{i-1/2})
        # The computational cells are U[num_ghost_cells : N_cells + num_ghost_cells]
        U[num_ghost_cells : N_cells + num_ghost_cells] -= (dt / dx) * (fluxes[1:] - fluxes[:-1])
        
        t += dt
        iteration += 1

        # Optimization: Add NaN/Inf check to detect numerical instability early.
        # If the solution becomes unstable, print a message and break the loop.
        if np.any(np.isnan(U)) or np.any(np.isinf(U)):
            print(f"Numerical instability detected at iteration {iteration}, time {t:.6f}. Breaking simulation.")
            break

        if iteration % 100 == 0 or t >= t_final:
            print(f"  Time: {t:.6f}/{t_final:.6f}, dt: {dt:.8f}, Iteration: {iteration}")

    print("--------------------------------------------------")
    print(f"Simulation finished at t = {t:.6f} after {iteration} iterations.")
    print("--------------------------------------------------")

    # Extract primitive variables from the final conserved state for plotting
    # Only consider the computational cells
    final_rho, final_u, final_p = conserved_to_primitive_vectorized(U[num_ghost_cells : N_cells + num_ghost_cells])

    # Plotting results
    plt.figure(figsize=(12, 8))

    plt.subplot(3, 1, 1)
    plt.plot(x_centers, final_rho, 'b-')
    plt.title(f'Sod Shock Tube Problem at t = {t_final}')
    plt.ylabel('Density (ρ)')
    plt.grid(True)

    plt.subplot(3, 1, 2)
    plt.plot(x_centers, final_u, 'r-')
    plt.ylabel('Velocity (u)')
    plt.grid(True)

    plt.subplot(3, 1, 3)
    plt.plot(x_centers, final_p, 'g-')
    plt.ylabel('Pressure (p)')
    plt.xlabel('Position (x)')
    plt.grid(True)

    plt.tight_layout()
    
    # Save the plot without showing it
    plot_filename = 'sod_shock_tube_hllc.png'
    plt.savefig(plot_filename)
    plt.close()
    print(f"Plot saved as {plot_filename}")

# Execute the simulation
if __name__ == "__main__":
    solve_euler_equations()
```
****************************************
