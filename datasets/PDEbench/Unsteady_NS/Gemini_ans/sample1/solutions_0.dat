
****************************************
The problem requires solving the 2D unsteady incompressible Navier-Stokes equations. A widely adopted and robust numerical method for such problems is the **Projection Method**, specifically Chorin's method. This method effectively decouples the velocity and pressure fields, making the solution process more manageable.

### Technical Explanation of the Solving Algorithm (Projection Method)

The Projection Method is a fractional-step approach that proceeds in three main steps for each time iteration:

1.  **Predictor Step (Intermediate Velocity Calculation):**
    In this step, an intermediate velocity field (\(\mathbf{u}^*\)) is computed by solving the momentum equations *without* the pressure gradient term. The convective and viscous terms are typically discretized explicitly using values from the previous time step.
    The equations for the intermediate velocities \(u^*\) and \(v^*\) are:
    \[
    \frac{u^* - u^n}{\Delta t} = - \left( u^n \frac{\partial u^n}{\partial x} + v^n \frac{\partial u^n}{\partial y} \right) + \frac{1}{\mathrm{Re}} \left( \frac{\partial^2 u^n}{\partial x^2} + \frac{\partial^2 u^n}{\partial y^2} \right)
    \]
    \[
    \frac{v^* - v^n}{\Delta t} = - \left( u^n \frac{\partial v^n}{\partial x} + v^n \frac{\partial v^n}{\partial y} \right) + \frac{1}{\mathrm{Re}} \left( \frac{\partial^2 v^n}{\partial x^2} + \frac{\partial^2 v^n}{\partial y^2} \right) + f_y
    \]
    Boundary conditions for velocity (Dirichlet and Neumann) are applied to these intermediate velocities.

2.  **Pressure Correction Step (Poisson Equation for Pressure):**
    The intermediate velocity field \(\mathbf{u}^*\) is generally not divergence-free (i.e., it does not satisfy the incompressibility condition). To enforce incompressibility, a pressure field \(p^{n+1}\) is introduced. The corrected velocities \(\mathbf{u}^{n+1}\) are related to \(\mathbf{u}^*\) and the pressure gradient:
    \[
    \mathbf{u}^{n+1} = \mathbf{u}^* - \Delta t \nabla p^{n+1}
    \]
    By taking the divergence of this equation and applying the incompressibility condition (\(\nabla \cdot \mathbf{u}^{n+1} = 0\)), we obtain a Poisson equation for the pressure:
    \[
    \nabla^2 p^{n+1} = \frac{1}{\Delta t} (\nabla \cdot \mathbf{u}^*)
    \]
    This elliptic partial differential equation is solved for \(p^{n+1}\). The boundary conditions for pressure are derived from the momentum equations at the boundaries. For Dirichlet velocity boundaries, Neumann pressure boundary conditions are typically used (e.g., \(\frac{\partial p}{\partial n} = \frac{1}{\Delta t} \mathbf{u}^* \cdot \mathbf{n}\)). For specified pressure boundaries (like the outlet in this problem), Dirichlet pressure boundary conditions are used. The problem specifies using GMRES for this step.

3.  **Velocity Correction Step:**
    Once \(p^{n+1}\) is determined, the final, divergence-free velocity field \(\mathbf{u}^{n+1}\) is computed by correcting \(\mathbf{u}^*\) using the pressure gradient:
    \[
    u^{n+1} = u^* - \Delta t \frac{\partial p^{n+1}}{\partial x}
    \]
    \[
    v^{n+1} = v^* - \Delta t \frac{\partial p^{n+1}}{\partial y}
    \]
    Finally, the boundary conditions for velocity are applied again to the corrected velocities to ensure consistency.

### Discretization Details

*   **Spatial Discretization:** Second-order central differences are used for all spatial derivatives (convective, viscous, and pressure gradient terms). `numpy.gradient` is leveraged for efficient computation of these derivatives.
*   **Time Integration:** An explicit Euler scheme is used for the convective and viscous terms in the predictor step. The pressure correction step is implicitly coupled.
*   **Grid:** A collocated grid is used where `u`, `v`, and `p` are defined at the same grid points. While staggered grids are often preferred for incompressible flow to avoid pressure oscillations, a collocated grid can be made stable with careful implementation of boundary conditions and appropriate numerical schemes.
*   **Poisson Solver:** The Poisson equation is discretized into a linear system \(A \mathbf{p} = \mathbf{b}\). The matrix \(A\) represents the discrete Laplacian operator, and \(\mathbf{b}\) contains the divergence of the intermediate velocity and boundary condition terms. This sparse linear system is solved using `scipy.sparse.linalg.gmres`, as required.

### Boundary Conditions Implementation

*   **Velocity (u, v):**
    *   **Top and Bottom Walls (No-slip):** `u = 0`, `v = 0` (Dirichlet). Applied directly to `u_star`, `v_star`, `u_new`, `v_new` arrays at the boundary rows.
    *   **Left Boundary (Inlet):** `u = u_inlet(y, t)`, `v = 0` (Dirichlet). Applied directly to `u_star`, `v_star`, `u_new`, `v_new` arrays at the left boundary column.
    *   **Right Boundary (Outlet):** \(\frac{\partial u}{\partial x} = 0\), \(\frac{\partial v}{\partial x} = 0\) (Neumann, zero-gradient). Implemented by setting `u[:, Nx-1] = u[:, Nx-2]` and `v[:, Nx-1] = v[:, Nx-2]`.

*   **Pressure (p) for Poisson Equation:**
    *   **Right Boundary (Outlet):** `p = 0` (Dirichlet). This is directly incorporated into the `A_poisson` matrix and `b_poisson_flat` vector by setting the corresponding diagonal element to 1 and the RHS element to 0.
    *   **Left Boundary (Inlet):** \(\frac{\partial p}{\partial x} = \frac{1}{\Delta t} (u^* - u_{inlet})\). This is a Neumann boundary condition. It's incorporated by modifying the coefficients of the `A_poisson` matrix and adding a term to the `b_poisson_flat` vector for the points on this boundary.
    *   **Top and Bottom Walls:** \(\frac{\partial p}{\partial y} = \frac{1}{\Delta t} v^*\). Since `v*` is set to 0 at these no-slip walls, this simplifies to \(\frac{\partial p}{\partial y} = 0\) (Neumann, zero-gradient). This is incorporated by modifying the coefficients of the `A_poisson` matrix for the points on these boundaries.

### Code Structure

The Python code is structured as follows:
1.  **Parameters and Grid Setup:** Defines physical constants, domain dimensions, grid resolution, and calculates `dx`, `dy`, and `dt`.
2.  **Initialization:** Sets initial `u`, `v`, `p` fields to zero.
3.  **Helper Functions:** Includes functions for calculating the time-dependent inlet velocity profile and for computing spatial derivatives (using `np.gradient`) and Laplacians.
4.  **Poisson Matrix Construction:** Builds the sparse matrix `A_poisson` for the pressure Poisson equation. This matrix is constant throughout the simulation as the grid is fixed. Boundary conditions for pressure are hardcoded into this matrix.
5.  **Time Stepping Loop:**
    *   Iterates through each time step.
    *   **Predictor Step:** Computes `u_star` and `v_star` using explicit Euler and applies velocity boundary conditions.
    *   **Pressure Correction Step:**
        *   Calculates the divergence of `u_star`.
        *   Constructs the right-hand side vector `b_poisson_flat` for the Poisson equation, including terms from Neumann pressure boundary conditions.
        *   Solves `A_poisson * p_flat = b_poisson_flat` using `gmres`.
    *   **Velocity Correction Step:** Updates `u_new` and `v_new` using the solved pressure gradient and applies final velocity boundary conditions.
    *   Updates `u_prev`, `v_prev` for the next time step.
    *   Prints progress and GMRES convergence information.
6.  **Plotting Results:** At the final time `t=0.5`, generates contour plots for `u`, `v`, and `p` using `matplotlib.pyplot.contourf` with the 'jet' colormap and saves them to files.

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import lil_matrix, csr_matrix
from scipy.sparse.linalg import gmres
import time
import os

# --- Parameters and Grid Setup ---
# Define physical parameters
Re = 100.0  # Reynolds number
Lx = 2.0    # Length of the domain in x-direction
Ly = 1.0    # Length of the domain in y-direction
T_final = 0.5 # Final simulation time

# Define grid resolution
Nx = 81     # Number of grid points in x-direction
Ny = 41     # Number of grid points in y-direction

# Calculate grid spacing
dx = Lx / (Nx - 1)
dy = Ly / (Ny - 1)

# Generate mesh coordinates
x = np.linspace(0, Lx, Nx)
y = np.linspace(0, Ly, Ny)
X_mesh, Y_mesh = np.meshgrid(x, y) # Meshgrid for plotting and spatial functions

# Define time step
# Estimate dt based on stability criteria (CFL and viscous diffusion)
# Viscous diffusion limit: dt_visc = 0.5 * min(dx**2, dy**2) * Re
dt_visc = 0.5 * min(dx**2, dy**2) * Re
# Convective limit (approximate max velocity from inlet BC): max_u ~ 1 * (1+1+1) = 3
# dt_conv = min(dx, dy) / max_u
dt_conv = min(dx, dy) / 3.0 # A rough estimate, actual max_u might be different
dt = min(dt_visc, dt_conv) * 0.1 # Take a conservative fraction for stability
dt = 0.001 # Manually set a small dt for robustness, 0.005 was too large for this resolution
# Number of time steps
Nt = int(T_final / dt) + 1
dt = T_final / (Nt - 1) # Adjust dt slightly to hit T_final exactly

# Print simulation parameters for reliability check
print(f"# Simulation Parameters:")
print(f"# Reynolds Number (Re): {Re}")
print(f"# Domain: [{0}, {Lx}] x [{0}, {Ly}]")
print(f"# Grid: {Nx}x{Ny} points (dx={dx:.4f}, dy={dy:.4f})")
print(f"# Time: [0, {T_final}] (dt={dt:.6f}, Nt={Nt} steps)")

# --- Initialization ---
# Initialize velocity components (u, v) and pressure (p) to zero
# u, v, p are stored as (Ny, Nx) arrays for easier indexing (row=y, col=x)
u = np.zeros((Ny, Nx))
v = np.zeros((Ny, Nx))
p = np.zeros((Ny, Nx))

# Store previous time step values for explicit terms in predictor step
u_prev = np.copy(u)
v_prev = np.copy(v)

# --- Helper Functions ---

# Function to calculate the inlet velocity profile based on y-coordinates and current time
def inlet_u_profile(y_coords, current_t):
    return np.sin(np.pi * y_coords) * (np.sin(np.pi * current_t) + np.sin(3 * np.pi * current_t) + np.sin(5 * np.pi * current_t))

# Function to calculate first spatial derivatives using central differences
# np.gradient computes derivatives using central differences for interior points
# and one-sided differences for boundary points.
def compute_derivatives(field, dx_val, dy_val):
    d_field_dx = np.gradient(field, dx_val, axis=1)
    d_field_dy = np.gradient(field, dy_val, axis=0)
    return d_field_dx, d_field_dy

# Function to calculate the Laplacian (second spatial derivatives)
def compute_laplacian(field, dx_val, dy_val):
    d_field_dx, _ = compute_derivatives(field, dx_val, dy_val)
    _, d_field_dy = compute_derivatives(field, dx_val, dy_val)
    d2_field_dx2, _ = compute_derivatives(d_field_dx, dx_val, dy_val) # Second derivative in x
    _, d2_field_dy2 = compute_derivatives(d_field_dy, dx_val, dy_val) # Second derivative in y
    return d2_field_dx2 + d2_field_dy2

# --- Build Poisson Matrix (A_poisson) for Pressure ---
# The matrix A_poisson for the Poisson equation is constant if dx, dy are constant.
# It represents the discretized Laplacian operator with boundary conditions.
# The system is A_poisson * p_flat = b_flat, where p_flat is the flattened pressure array.
N_total = Nx * Ny # Total number of grid points (unknowns for pressure)
A_poisson = lil_matrix((N_total, N_total)) # Use LIL format for easy construction

# Populate the matrix A_poisson by iterating over all grid points (j for y, i for x)
for j in range(Ny):
    for i in range(Nx):
        k = j * Nx + i  # Flattened index for the current grid point (i, j)

        # Right boundary (Outlet, i=Nx-1): Dirichlet BC p=0
        # For these points, the equation is simply p_k = 0
        if i == Nx - 1:
            A_poisson[k, k] = 1.0 # Set diagonal to 1
        else:
            # Standard 5-point stencil coefficients for interior points
            coeff_diag = -2 / dx**2 - 2 / dy**2 # Coefficient for p[i,j]
            coeff_x = 1 / dx**2                 # Coefficient for p[i+/-1,j]
            coeff_y = 1 / dy**2                 # Coefficient for p[i,j+/-1]

            # Apply Neumann BC modifications to coefficients for A_poisson
            # These modifications effectively use a one-sided difference at the boundary
            # and reflect the ghost point into the domain.

            # Left boundary (Inlet, i=0): dp/dx is Neumann
            # The derivative (p[1,j] - p[0,j])/dx is used.
            # This modifies the stencil for p[0,j] and p[1,j].
            if i == 0:
                coeff_diag += coeff_x  # Adjust diagonal term for p[0,j]
                coeff_x *= 2           # Coefficient for p[1,j] becomes 2/dx^2
            
            # Bottom boundary (Wall, j=0): dp/dy is Neumann (v_star[i,0] = 0, so dp/dy = 0)
            # The derivative (p[i,1] - p[i,0])/dy is used.
            if j == 0:
                coeff_diag += coeff_y  # Adjust diagonal term for p[i,0]
                coeff_y *= 2           # Coefficient for p[i,1] becomes 2/dy^2
            
            # Top boundary (Wall, j=Ny-1): dp/dy is Neumann (v_star[i,Ny-1] = 0, so dp/dy = 0)
            # The derivative (p[i,Ny-1] - p[i,Ny-2])/dy is used.
            if j == Ny - 1:
                coeff_diag += coeff_y  # Adjust diagonal term for p[i,Ny-1]
                coeff_y *= 2           # Coefficient for p[i,Ny-2] becomes 2/dy^2

            # Assign coefficients to matrix A_poisson
            A_poisson[k, k] = coeff_diag # Diagonal element
            if i > 0: A_poisson[k, k-1] = 1 / dx**2  # Left neighbor (standard)
            if i < Nx - 1: A_poisson[k, k+1] = coeff_x # Right neighbor (modified if i=0)
            if j > 0: A_poisson[k, k-Nx] = 1 / dy**2  # Bottom neighbor (standard)
            if j < Ny - 1: A_poisson[k, k+Nx] = coeff_y # Top neighbor (modified if j=0 or j=Ny-1)

# Convert to CSR format for efficient GMRES solve
A_poisson = A_poisson.tocsr()

# --- Time Stepping Loop (Projection Method) ---
current_time = 0.0
print(f"# Starting time integration...")
start_time = time.time()

for n in range(Nt):
    current_time = n * dt

    # Print progress at regular intervals and at the last step
    if n % (Nt // 10) == 0 or n == Nt - 1:
        print(f"# Time step {n}/{Nt-1} (t={current_time:.4f})")

    # 1. Predictor Step: Compute intermediate velocities (u_star, v_star)
    # Calculate derivatives of u and v from the previous time step
    u_prev_dx, u_prev_dy = compute_derivatives(u_prev, dx, dy)
    v_prev_dx, v_prev_dy = compute_derivatives(v_prev, dx, dy)

    # Calculate Laplacians of u and v from the previous time step
    laplacian_u_prev = compute_laplacian(u_prev, dx, dy)
    laplacian_v_prev = compute_laplacian(v_prev, dx, dy)

    # Calculate the forcing term f_y at the current time
    # f(x, y, t) = (0, -sin(pi x) sin(pi y) sin(pi t))
    f_y = -np.sin(np.pi * X_mesh) * np.sin(np.pi * Y_mesh) * np.sin(np.pi * current_time)

    # Compute u_star and v_star for all points (including boundaries initially)
    # Convective terms: u*du/dx + v*du/dy
    convective_u = u_prev * u_prev_dx + v_prev * u_prev_dy
    convective_v = u_prev * v_prev_dx + v_prev * v_prev_dy

    # Explicit Euler update for u_star and v_star
    u_star = u_prev + dt * (-convective_u + (1/Re) * laplacian_u_prev)
    v_star = v_prev + dt * (-convective_v + (1/Re) * laplacian_v_prev + f_y)

    # Apply boundary conditions for u_star and v_star
    # No-slip on top and bottom walls (j=0, Ny-1)
    u_star[0, :] = 0.0
    v_star[0, :] = 0.0
    u_star[Ny-1, :] = 0.0
    v_star[Ny-1, :] = 0.0

    # Inlet condition at left boundary (i=0)
    u_inlet_val = inlet_u_profile(y, current_time) # Calculate inlet profile at current time
    u_star[:, 0] = u_inlet_val
    v_star[:, 0] = 0.0

    # Outlet condition at right boundary (i=Nx-1): du/dx = 0, dv/dx = 0 (zero gradient)
    u_star[:, Nx-1] = u_star[:, Nx-2]
    v_star[:, Nx-1] = v_star[:, Nx-2]

    # 2. Pressure Correction Step: Solve Poisson equation for pressure
    # Calculate divergence of u_star
    u_star_dx, _ = compute_derivatives(u_star, dx, dy)
    _, v_star_dy = compute_derivatives(v_star, dx, dy)
    divergence_u_star = u_star_dx + v_star_dy

    # Construct the RHS vector (b_poisson_flat) for the Poisson equation
    b_poisson_flat = np.zeros(N_total)
    for j in range(Ny):
        for i in range(Nx):
            k = j * Nx + i # Flattened index

            # Right boundary (Outlet, i=Nx-1): Dirichlet BC p=0
            # The RHS for these points is 0, as A_poisson[k,k] is 1.0
            if i == Nx - 1:
                b_poisson_flat[k] = 0.0
            else:
                # Standard RHS term from divergence
                b_poisson_flat[k] = divergence_u_star[j, i] / dt

                # Add Neumann BC terms to RHS
                # Left boundary (Inlet, i=0): dp/dx = (u_star[0,j] - u_inlet_val[j])/dt
                # This term is added to the RHS for points on the left boundary
                if i == 0:
                    b_poisson_flat[k] += (2 * (u_star[j,0] - u_inlet_val[j])) / (dt * dx)
                
                # Bottom boundary (Wall, j=0): dp/dy = v_star[i,0]/dt. Since v_star[i,0]=0, this term is 0.
                # Top boundary (Wall, j=Ny-1): dp/dy = v_star[i,Ny-1]/dt. Since v_star[i,Ny-1]=0, this term is 0.
                # So, no additional terms for top/bottom walls in b_poisson_flat.

    # Solve the linear system A_poisson * p_flat = b_poisson_flat using GMRES
    # x0 is the initial guess (previous pressure field flattened)
    # atol is the absolute tolerance for convergence
    # maxiter limits the number of iterations
    p_flat, info = gmres(A_poisson, b_poisson_flat, x0=p.flatten(), atol=1e-8, maxiter=1000)
    p = p_flat.reshape((Ny, Nx)) # Reshape the solved pressure back to 2D array

    # Print GMRES convergence information
    if info == 0:
        print(f"#   GMRES converged at t={current_time:.4f}")
    else:
        print(f"#   GMRES did NOT converge at t={current_time:.4f}, info={info}")

    # 3. Velocity Correction Step: Update velocities using the new pressure
    # Calculate pressure gradients
    p_dx, p_dy = compute_derivatives(p, dx, dy)

    # Correct u_star and v_star to obtain divergence-free u_new and v_new
    u_new = u_star - dt * p_dx
    v_new = v_star - dt * p_dy

    # Apply final boundary conditions for u_new and v_new
    # No-slip on top and bottom walls (j=0, Ny-1)
    u_new[0, :] = 0.0
    v_new[0, :] = 0.0
    u_new[Ny-1, :] = 0.0
    v_new[Ny-1, :] = 0.0

    # Inlet condition at left boundary (i=0)
    u_new[:, 0] = u_inlet_val
    v_new[:, 0] = 0.0

    # Outlet condition at right boundary (i=Nx-1): du/dx = 0, dv/dx = 0 (zero gradient)
    u_new[:, Nx-1] = u_new[:, Nx-2]
    v_new[:, Nx-1] = v_new[:, Nx-2]

    # Update for next time step: current solution becomes previous for next iteration
    u_prev = np.copy(u_new)
    v_prev = np.copy(v_new)
    u = np.copy(u_new) # u is the current solution
    v = np.copy(v_new) # v is the current solution

end_time = time.time()
print(f"# Time integration completed in {end_time - start_time:.2f} seconds.")

# --- Plotting Results at T_final ---
print(f"# Plotting results at t={T_final:.4f}...")

# Create a directory for plots if it doesn't exist
if not os.path.exists("ns_plots"):
    os.makedirs("ns_plots")

# Plot u velocity contour
plt.figure(figsize=(10, 5))
plt.contourf(X_mesh, Y_mesh, u, levels=50, cmap='jet') # Use jet colormap
plt.colorbar(label='u velocity')
plt.title(f'u Velocity Contour at t = {T_final:.2f}')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal') # Maintain aspect ratio
plt.tight_layout() # Adjust layout to prevent labels overlapping
plt.savefig('ns_plots/u_velocity_contour.png') # Save figure
plt.close() # Close figure to free memory

# Plot v velocity contour
plt.figure(figsize=(10, 5))
plt.contourf(X_mesh, Y_mesh, v, levels=50, cmap='jet') # Use jet colormap
plt.colorbar(label='v velocity')
plt.title(f'v Velocity Contour at t = {T_final:.2f}')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal')
plt.tight_layout()
plt.savefig('ns_plots/v_velocity_contour.png') # Save figure
plt.close()

# Plot pressure contour
plt.figure(figsize=(10, 5))
plt.contourf(X_mesh, Y_mesh, p, levels=50, cmap='jet') # Use jet colormap
plt.colorbar(label='Pressure')
plt.title(f'Pressure Contour at t = {T_final:.2f}')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal')
plt.tight_layout()
plt.savefig('ns_plots/pressure_contour.png') # Save figure
plt.close()

print("# Plots saved to 'ns_plots/' directory.")
print("# Simulation finished.")
```
****************************************
