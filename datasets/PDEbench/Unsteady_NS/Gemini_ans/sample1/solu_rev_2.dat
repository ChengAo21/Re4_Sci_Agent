
****************************************
```python
# Technical explanation for the solving algorithm:
# This code implements a finite difference method for solving the 2D unsteady incompressible Navier-Stokes equations
# using the fractional step (or projection) method. This method decouples the velocity and pressure fields,
# making the solution process more manageable.

# The algorithm proceeds in three main steps at each time step:

# 1. Predictor (Momentum) Step:
#    - The intermediate velocities (u_star, v_star) are computed by solving the momentum equations
#      without the pressure gradient term.
#    - Convective terms (u*du/dx, v*du/dy, etc.) and viscous terms (Laplacian) are discretized
#      using explicit finite differences (e.g., central differences for spatial derivatives).
#    - The forcing term is also included.
#    - Boundary conditions for velocity (no-slip, inlet, zero-gradient outlet) are applied to u_star and v_star.
#    - This step typically uses an explicit time integration scheme (e.g., Explicit Euler) for simplicity,
#      which imposes a stability constraint on the time step (CFL condition and viscous diffusion limit).

# 2. Pressure Correction (Poisson) Step:
#    - The incompressibility condition (divergence-free velocity, du/dx + dv/dy = 0) is enforced.
#    - This is achieved by solving a Poisson equation for pressure.
#    - The right-hand side (RHS) of the Poisson equation is proportional to the divergence of the intermediate
#      velocity field (u_star, v_star).
#    - The Poisson equation is discretized using central finite differences, resulting in a large sparse linear system.
#    - Boundary conditions for pressure are derived from the velocity boundary conditions. For example,
#      at no-slip walls, the normal pressure gradient is related to the normal component of the intermediate velocity.
#      At the outlet, a Dirichlet boundary condition (p=0) is specified to fix the pressure level.
#    - This linear system is solved using the Generalized Minimal Residual (GMRES) iterative method,
#      which is suitable for non-symmetric sparse matrices.

# 3. Velocity Correction Step:
#    - The intermediate velocities (u_star, v_star) are corrected by subtracting the gradient of the
#      newly computed pressure field.
#    - This correction ensures that the final velocity field (u_new, v_new) is divergence-free.
#    - The final velocity boundary conditions are re-applied to u_new and v_new.
#    - These corrected velocities become the initial conditions for the next time step.

# Spatial Discretization:
# - A uniform Cartesian grid is used.
# - Central finite differences are employed for all spatial derivatives (first and second order)
#   in the interior of the domain.
# - One-sided finite differences or ghost-point methods are used to handle derivatives at boundaries
#   and to incorporate boundary conditions into the discretized equations.

# Time Integration:
# - Explicit Euler method is used for time integration of the momentum equations.

# Optimized and Refined Sections based on Teacher Feedback:
# 1. Numerical Differentiation: Replaced `np.gradient` with custom functions (`compute_dx`, `compute_dy`, `compute_d2x`, `compute_d2y`, `compute_laplacian`)
#    that explicitly implement central differences for interior points and one-sided differences at boundaries.
#    This provides more control over accuracy and boundary treatment.
# 2. Poisson Matrix and RHS Assembly: The construction of the `A_poisson` matrix and `b_poisson_flat` RHS vector
#    has been thoroughly re-evaluated and re-implemented based on a detailed derivation of finite difference
#    stencils for interior points and specific Neumann/Dirichlet boundary conditions for pressure.
#    This is critical for GMRES convergence. The Neumann boundary conditions for pressure are derived from
#    the corrected momentum equations at the boundaries, leading to specific modifications in the matrix
#    coefficients and additions to the RHS vector. The Dirichlet condition at the outlet (p=0) is explicitly
#    handled to ensure a unique solution for pressure.
#    Specifically, the `build_poisson_matrix` function has been rewritten to explicitly apply the modified
#    stencils for Neumann boundary conditions (left, top, bottom boundaries) and the Dirichlet condition (right outlet).
# 3. GMRES Preconditioning: An Incomplete LU (ILU) preconditioner (`scipy.sparse.linalg.spilu`) has been added
#    to the GMRES solver. This significantly improves the convergence rate and robustness of GMRES for large,
#    sparse, and potentially ill-conditioned linear systems, directly addressing the previous non-convergence issues.
# 4. GMRES Convergence Monitoring: Enhanced print statements for GMRES convergence, including the `info` flag,
#    and added checks for `NaN` values in intermediate computations to aid debugging.
# 5. Time Step Calculation: A robust `dt` calculation is included, considering both convective and viscous limits,
#    and a conservative factor is applied to enhance stability.
# 6. Plotting: Added a quiver plot to visualize the velocity vector field, providing more comprehensive flow visualization.

import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import lil_matrix, csr_matrix
from scipy.sparse.linalg import gmres, spilu, LinearOperator
import time
import os

# --- Parameters and Grid Setup ---
# Define physical parameters
Re = 100.0  # Reynolds number
Lx = 2.0    # Length of the domain in x-direction
Ly = 1.0    # Length of the domain in y-direction
T_final = 0.5 # Final simulation time

# Define grid resolution
Nx = 81     # Number of grid points in x-direction
Ny = 41     # Number of grid points in y-direction

# Calculate grid spacing
dx = Lx / (Nx - 1)
dy = Ly / (Ny - 1)

# Generate mesh coordinates
x = np.linspace(0, Lx, Nx)
y = np.linspace(0, Ly, Ny)
X_mesh, Y_mesh = np.meshgrid(x, y) # Meshgrid for plotting and spatial functions

# Define time step
# Estimate dt based on stability criteria (CFL and viscous diffusion)
# Viscous diffusion limit for explicit scheme: dt_visc = 0.5 * min(dx**2, dy**2) * Re
dt_visc = 0.5 * min(dx**2, dy**2) * Re
# Convective limit (CFL): dt_conv = min(dx, dy) / max_velocity
# A rough estimate for max_velocity from inlet BC: max_u ~ 1 * (1+1+1) = 3
max_u_estimate = 3.0
dt_conv = min(dx, dy) / max_u_estimate
# Take a conservative fraction of the minimum of these two limits for stability
# The factor 0.05 is very conservative, chosen to ensure initial stability.
# It can be increased if the solver is stable.
dt = min(dt_visc, dt_conv) * 0.05

# Adjust dt slightly to hit T_final exactly
Nt = int(T_final / dt) + 1
dt = T_final / (Nt - 1)

# Print simulation parameters for reliability check
print(f"# Simulation Parameters:")
print(f"# Reynolds Number (Re): {Re}")
print(f"# Domain: [{0}, {Lx}] x [{0}, {Ly}]")
print(f"# Grid: {Nx}x{Ny} points (dx={dx:.4f}, dy={dy:.4f})")
print(f"# Time: [0, {T_final}] (dt={dt:.6f}, Nt={Nt} steps)")
print(f"# Estimated dt_visc: {dt_visc:.6f}")
print(f"# Estimated dt_conv: {dt_conv:.6f}")
print(f"# Chosen dt: {dt:.6f}")

# --- Initialization ---
# Initialize velocity components (u, v) and pressure (p) to zero
# u, v, p are stored as (Ny, Nx) arrays for easier indexing (row=y, col=x)
u = np.zeros((Ny, Nx))
v = np.zeros((Ny, Nx))
p = np.zeros((Ny, Nx))

# Store previous time step values for explicit terms in predictor step
u_prev = np.copy(u)
v_prev = np.copy(v)

# --- Helper Functions for Finite Differences ---

# Optimized: Replaced np.gradient with explicit finite difference functions.
# This provides more control over boundary conditions and accuracy.
def compute_dx(field, dx_val):
    # Computes d/dx using central differences for interior, one-sided for boundaries
    d_field_dx = np.zeros_like(field)
    # Central difference for interior points
    d_field_dx[:, 1:-1] = (field[:, 2:] - field[:, :-2]) / (2 * dx_val)
    # Forward difference for left boundary (i=0)
    d_field_dx[:, 0] = (field[:, 1] - field[:, 0]) / dx_val
    # Backward difference for right boundary (i=Nx-1)
    d_field_dx[:, -1] = (field[:, -1] - field[:, -2]) / dx_val
    return d_field_dx

def compute_dy(field, dy_val):
    # Computes d/dy using central differences for interior, one-sided for boundaries
    d_field_dy = np.zeros_like(field)
    # Central difference for interior points
    d_field_dy[1:-1, :] = (field[2:, :] - field[:-2, :]) / (2 * dy_val)
    # Forward difference for bottom boundary (j=0)
    d_field_dy[0, :] = (field[1, :] - field[0, :]) / dy_val
    # Backward difference for top boundary (j=Ny-1)
    d_field_dy[-1, :] = (field[-1, :] - field[-2, :]) / dy_val
    return d_field_dy

def compute_d2x(field, dx_val):
    # Computes d^2/dx^2 using central differences for interior points.
    # One-sided approximations are used at boundaries.
    d2_field_dx2 = np.zeros_like(field)
    d2_field_dx2[:, 1:-1] = (field[:, 2:] - 2 * field[:, 1:-1] + field[:, :-2]) / (dx_val**2)
    # Forward difference for 2nd derivative at left boundary
    d2_field_dx2[:, 0] = (field[:, 2] - 2 * field[:, 1] + field[:, 0]) / (dx_val**2)
    # Backward difference for 2nd derivative at right boundary
    d2_field_dx2[:, -1] = (field[:, -1] - 2 * field[:, -2] + field[:, -3]) / (dx_val**2)
    return d2_field_dx2

def compute_d2y(field, dy_val):
    # Computes d^2/dy^2 using central differences for interior points.
    # One-sided approximations are used at boundaries.
    d2_field_dy2 = np.zeros_like(field)
    d2_field_dy2[1:-1, :] = (field[2:, :] - 2 * field[1:-1, :] + field[:-2, :]) / (dy_val**2)
    # Forward difference for 2nd derivative at bottom boundary
    d2_field_dy2[0, :] = (field[2, :] - 2 * field[1, :] + field[0, :]) / (dy_val**2)
    # Backward difference for 2nd derivative at top boundary
    d2_field_dy2[-1, :] = (field[-1, :] - 2 * field[-2, :] + field[-3, :]) / (dy_val**2)
    return d2_field_dy2

def compute_laplacian(field, dx_val, dy_val):
    return compute_d2x(field, dx_val) + compute_d2y(field, dy_val)

# Function to calculate the inlet velocity profile based on y-coordinates and current time
def inlet_u_profile(y_coords, current_t):
    return np.sin(np.pi * y_coords) * (np.sin(np.pi * current_t) + np.sin(3 * np.pi * current_t) + np.sin(5 * np.pi * current_t))

# --- Build Poisson Matrix (A_poisson) for Pressure ---
# Optimized: Re-implemented the Poisson matrix assembly based on detailed finite difference
# derivation for interior points and all boundary conditions (Dirichlet and Neumann).
# This is crucial for GMRES convergence.
def build_poisson_matrix(Nx, Ny, dx, dy):
    N_total = Nx * Ny
    A_poisson = lil_matrix((N_total, N_total))

    # Base coefficients for standard 5-point stencil
    coeff_diag_x = -2 / dx**2
    coeff_x_neighbor = 1 / dx**2
    coeff_diag_y = -2 / dy**2
    coeff_y_neighbor = 1 / dy**2

    for j in range(Ny):
        for i in range(Nx):
            k = j * Nx + i  # Flattened index for (i, j)

            # Outlet (i=Nx-1): Dirichlet BC p=0
            # For these points, the equation is simply p_k = 0.
            # So, set diagonal to 1 and all other entries in this row to 0.
            if i == Nx - 1:
                A_poisson[k, k] = 1.0
            else:
                # Initialize diagonal for current point
                A_poisson[k, k] = 0.0

                # X-direction terms (d^2p/dx^2)
                if i == 0:  # Left boundary (Inlet, Neumann BC dp/dx)
                    # Stencil for d^2p/dx^2 at i=0 using ghost point: (2p[1,j] - 2p[0,j])/dx^2
                    A_poisson[k, k] += coeff_diag_x  # -2/dx^2 for p[0,j]
                    A_poisson[k, k+1] += 2 * coeff_x_neighbor # 2/dx^2 for p[1,j]
                else: # Interior or Right boundary (Neumann BC dp/dx, but handled by general stencil)
                    # Standard central difference: (p[i+1,j] - 2p[i,j] + p[i-1,j])/dx^2
                    A_poisson[k, k] += coeff_diag_x  # -2/dx^2 for p[i,j]
                    A_poisson[k, k-1] += coeff_x_neighbor # 1/dx^2 for p[i-1,j]
                    A_poisson[k, k+1] += coeff_x_neighbor # 1/dx^2 for p[i+1,j]

                # Y-direction terms (d^2p/dy^2)
                if j == 0:  # Bottom boundary (Wall, Neumann BC dp/dy)
                    # Stencil for d^2p/dy^2 at j=0 using ghost point: (2p[i,1] - 2p[i,0])/dy^2
                    A_poisson[k, k] += coeff_diag_y  # -2/dy^2 for p[i,0]
                    A_poisson[k, k+Nx] += 2 * coeff_y_neighbor # 2/dy^2 for p[i,1]
                elif j == Ny - 1: # Top boundary (Wall, Neumann BC dp/dy)
                    # Stencil for d^2p/dy^2 at j=Ny-1 using ghost point: (2p[i,Ny-2] - 2p[i,Ny-1])/dy^2
                    A_poisson[k, k] += coeff_diag_y  # -2/dy^2 for p[i,Ny-1]
                    A_poisson[k, k-Nx] += 2 * coeff_y_neighbor # 2/dy^2 for p[i,Ny-2]
                else: # Interior
                    # Standard central difference: (p[i,j+1] - 2p[i,j] + p[i,j-1])/dy^2
                    A_poisson[k, k] += coeff_diag_y  # -2/dy^2 for p[i,j]
                    A_poisson[k, k-Nx] += coeff_y_neighbor # 1/dy^2 for p[i,j-1]
                    A_poisson[k, k+Nx] += coeff_y_neighbor # 1/dy^2 for p[i,j+1]

    return A_poisson.tocsr() # Convert to CSR format for efficient GMRES solve

# Build the Poisson matrix once as it's constant throughout the simulation
A_poisson = build_poisson_matrix(Nx, Ny, dx, dy)
print(f"# Poisson matrix built. Shape: {A_poisson.shape}")

# Optimized: Create a preconditioner for GMRES to improve convergence.
# Using Incomplete LU factorization (ILU)
M = None # Initialize preconditioner to None
try:
    # Adjust drop_tol and fill_factor for performance/accuracy trade-off
    # Smaller drop_tol and larger fill_factor lead to a better (denser) preconditioner,
    # but take more time to compute and apply.
    M_x = spilu(A_poisson, drop_tol=1e-5, fill_factor=20)
    M = LinearOperator(A_poisson.shape, M_x.solve)
    print("# ILU preconditioner successfully created for GMRES.")
except RuntimeError as e:
    print(f"# Warning: Could not create ILU preconditioner. Falling back to no preconditioner. Error: {e}")
    print("# GMRES convergence might be slow or fail without a preconditioner.")

# --- Time Stepping Loop (Projection Method) ---
current_time = 0.0
print(f"# Starting time integration...")
start_time = time.time()

for n in range(Nt):
    current_time = n * dt

    # Print progress at regular intervals and at the last step
    if n % (Nt // 10) == 0 or n == Nt - 1:
        print(f"# Time step {n}/{Nt-1} (t={current_time:.4f})")

    # 1. Predictor Step: Compute intermediate velocities (u_star, v_star)
    # Calculate derivatives of u and v from the previous time step using custom FD functions
    u_prev_dx = compute_dx(u_prev, dx)
    u_prev_dy = compute_dy(u_prev, dy)
    v_prev_dx = compute_dx(v_prev, dx)
    v_prev_dy = compute_dy(v_prev, dy)

    # Calculate Laplacians of u and v from the previous time step
    laplacian_u_prev = compute_laplacian(u_prev, dx, dy)
    laplacian_v_prev = compute_laplacian(v_prev, dx, dy)

    # Calculate the forcing term f_y at the current time
    # f(x, y, t) = (0, -sin(pi x) sin(pi y) sin(pi t))
    f_y = -np.sin(np.pi * X_mesh) * np.sin(np.pi * Y_mesh) * np.sin(np.pi * current_time)

    # Compute u_star and v_star for all points (including boundaries initially)
    # Convective terms: u*du/dx + v*du/dy
    convective_u = u_prev * u_prev_dx + v_prev * u_prev_dy
    convective_v = u_prev * v_prev_dx + v_prev * v_prev_dy

    # Explicit Euler update for u_star and v_star
    u_star = u_prev + dt * (-convective_u + (1/Re) * laplacian_u_prev)
    v_star = v_prev + dt * (-convective_v + (1/Re) * laplacian_v_prev + f_y)

    # Apply boundary conditions for u_star and v_star
    # No-slip on top and bottom walls (j=0, Ny-1)
    u_star[0, :] = 0.0
    v_star[0, :] = 0.0
    u_star[Ny-1, :] = 0.0
    v_star[Ny-1, :] = 0.0

    # Inlet condition at left boundary (i=0)
    u_inlet_val = inlet_u_profile(y, current_time) # Calculate inlet profile at current time
    u_star[:, 0] = u_inlet_val
    v_star[:, 0] = 0.0

    # Outlet condition at right boundary (i=Nx-1): du/dx = 0, dv/dx = 0 (zero gradient)
    # This is approximated by copying values from the adjacent interior column.
    u_star[:, Nx-1] = u_star[:, Nx-2]
    v_star[:, Nx-1] = v_star[:, Nx-2]

    # Check for NaNs after predictor step
    if np.any(np.isnan(u_star)) or np.any(np.isnan(v_star)):
        print(f"#   NaNs detected in u_star or v_star at t={current_time:.4f}. Aborting simulation.")
        break

    # 2. Pressure Correction Step: Solve Poisson equation for pressure
    # Optimized: Re-implemented RHS construction for Poisson equation with correct Neumann BC terms.
    # Calculate divergence of u_star
    u_star_dx = compute_dx(u_star, dx)
    v_star_dy = compute_dy(v_star, dy)
    divergence_u_star = u_star_dx + v_star_dy

    # Check for NaNs in divergence
    if np.any(np.isnan(divergence_u_star)):
        print(f"#   NaNs detected in divergence_u_star at t={current_time:.4f}. Aborting simulation.")
        break

    # Construct the RHS vector (b_poisson_flat) for the Poisson equation
    b_poisson_flat = np.zeros(Nx * Ny)
    for j in range(Ny):
        for i in range(Nx):
            k = j * Nx + i # Flattened index

            # Outlet (i=Nx-1): Dirichlet BC p=0. RHS is 0 for these points.
            if i == Nx - 1:
                b_poisson_flat[k] = 0.0
            else:
                # Standard RHS term from divergence: (1/dt) * (du_star/dx + dv_star/dy)
                b_poisson_flat[k] = divergence_u_star[j, i] / dt

                # Add Neumann BC terms to RHS (from ghost point elimination).
                # The general form for the term added to RHS is -2 * G / Delta_n, where G is the normal derivative.
                # The sign depends on the direction of the outward normal.

                # Left boundary (Inlet, i=0): dp/dx = G_x0 = (u_star[j,0] - u_inlet_val[j])/dt
                # Normal is in -x direction, so add -2 * G_x0 / dx to RHS.
                if i == 0:
                    G_x0 = (u_star[j,0] - u_inlet_val[j]) / dt
                    b_poisson_flat[k] -= (2 * G_x0) / dx

                # Bottom boundary (Wall, j=0): dp/dy = G_y0 = v_star[0,i]/dt (since v_new=0)
                # Normal is in -y direction, so add -2 * G_y0 / dy to RHS.
                if j == 0:
                    G_y0 = v_star[0,i] / dt
                    b_poisson_flat[k] -= (2 * G_y0) / dy

                # Top boundary (Wall, j=Ny-1): dp/dy = G_y_Ny_1 = v_star[Ny-1,i]/dt (since v_new=0)
                # Normal is in +y direction, so add +2 * G_y_Ny_1 / dy to RHS.
                if j == Ny - 1:
                    G_y_Ny_1 = v_star[Ny-1,i] / dt
                    b_poisson_flat[k] += (2 * G_y_Ny_1) / dy

    # Check for NaNs in RHS
    if np.any(np.isnan(b_poisson_flat)):
        print(f"#   NaNs detected in b_poisson_flat at t={current_time:.4f}. Aborting simulation.")
        break

    # Solve the linear system A_poisson * p_flat = b_poisson_flat using GMRES
    # x0 is the initial guess (previous pressure field flattened)
    # atol is the absolute tolerance for convergence
    # maxiter limits the number of iterations
    # M is the preconditioner
    try:
        p_flat, info = gmres(A_poisson, b_poisson_flat, x0=p.flatten(), atol=1e-8, maxiter=1000, M=M)
        p = p_flat.reshape((Ny, Nx)) # Reshape the solved pressure back to 2D array

        # Print GMRES convergence information
        if info == 0:
            print(f"#   GMRES converged at t={current_time:.4f}")
        else:
            print(f"#   GMRES did NOT converge at t={current_time:.4f}, info={info}. Max iterations reached or breakdown.")
            # If GMRES consistently fails, it indicates a problem with the matrix or RHS.
            # For robustness, one might consider increasing maxiter or adding a preconditioner.
            # However, the primary fix is ensuring the system is well-posed, which has been addressed.
            # If info is not 0, it means GMRES did not converge within maxiter or encountered a breakdown.
            # This often indicates an ill-conditioned matrix or an issue with the problem formulation.
            # For this problem, if GMRES fails, the solution is unreliable.
            # For robustness, we might want to break the loop here if it fails too many times.
            # For now, we continue to see the behavior.
            if np.any(np.isnan(p)):
                print(f"#   NaNs detected in pressure solution after GMRES at t={current_time:.4f}. Aborting simulation.")
                break
    except Exception as e:
        print(f"#   Error during GMRES solve at t={current_time:.4f}: {e}. Aborting simulation.")
        break

    # 3. Velocity Correction Step: Update velocities using the new pressure
    # Calculate pressure gradients using custom FD functions
    p_dx = compute_dx(p, dx)
    p_dy = compute_dy(p, dy)

    # Correct u_star and v_star to obtain divergence-free u_new and v_new
    u_new = u_star - dt * p_dx
    v_new = v_star - dt * p_dy

    # Apply final boundary conditions for u_new and v_new
    # No-slip on top and bottom walls (j=0, Ny-1)
    u_new[0, :] = 0.0
    v_new[0, :] = 0.0
    u_new[Ny-1, :] = 0.0
    v_new[Ny-1, :] = 0.0

    # Inlet condition at left boundary (i=0)
    u_new[:, 0] = u_inlet_val
    v_new[:, 0] = 0.0

    # Outlet condition at right boundary (i=Nx-1): du/dx = 0, dv/dx = 0 (zero gradient)
    u_new[:, Nx-1] = u_new[:, Nx-2]
    v_new[:, Nx-1] = v_new[:, Nx-2]

    # Check for NaNs after velocity correction
    if np.any(np.isnan(u_new)) or np.any(np.isnan(v_new)):
        print(f"#   NaNs detected in u_new or v_new at t={current_time:.4f}. Aborting simulation.")
        break

    # Update for next time step: current solution becomes previous for next iteration
    u_prev = np.copy(u_new)
    v_prev = np.copy(v_new)
    u = np.copy(u_new) # u is the current solution
    v = np.copy(v_new) # v is the current solution

end_time = time.time()
print(f"# Time integration completed in {end_time - start_time:.2f} seconds.")

# --- Plotting Results at T_final ---
print(f"# Plotting results at t={T_final:.4f}...")

# Create a directory for plots if it doesn't exist
if not os.path.exists("ns_plots"):
    os.makedirs("ns_plots")

# Plot u velocity contour
plt.figure(figsize=(10, 5))
plt.contourf(X_mesh, Y_mesh, u, levels=50, cmap='jet') # Use jet colormap
plt.colorbar(label='u velocity')
plt.title(f'u Velocity Contour at t = {T_final:.2f}')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal') # Maintain aspect ratio
plt.tight_layout() # Adjust layout to prevent labels overlapping
plt.savefig('ns_plots/u_velocity_contour.png') # Save figure
plt.close() # Close figure to free memory

# Plot v velocity contour
plt.figure(figsize=(10, 5))
plt.contourf(X_mesh, Y_mesh, v, levels=50, cmap='jet') # Use jet colormap
plt.colorbar(label='v velocity')
plt.title(f'v Velocity Contour at t = {T_final:.2f}')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal')
plt.tight_layout()
plt.savefig('ns_plots/v_velocity_contour.png') # Save figure
plt.close()

# Plot pressure contour
plt.figure(figsize=(10, 5))
plt.contourf(X_mesh, Y_mesh, p, levels=50, cmap='jet') # Use jet colormap
plt.colorbar(label='Pressure')
plt.title(f'Pressure Contour at t = {T_final:.2f}')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal')
plt.tight_layout()
plt.savefig('ns_plots/pressure_contour.png') # Save figure
plt.close()

# Plot velocity vector field (quiver plot)
plt.figure(figsize=(10, 5))
# Downsample for clearer visualization if grid is too dense
skip = max(1, int(Nx / 40)) # Adjust skip factor based on grid density
plt.quiver(X_mesh[::skip, ::skip], Y_mesh[::skip, ::skip], u[::skip, ::skip], v[::skip, ::skip],
           color='black', scale=5, width=0.002) # Adjust scale and width as needed
plt.contourf(X_mesh, Y_mesh, np.sqrt(u**2 + v**2), levels=50, cmap='jet', alpha=0.8) # Background magnitude
plt.colorbar(label='Velocity Magnitude')
plt.title(f'Velocity Vector Field at t = {T_final:.2f}')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal')
plt.tight_layout()
plt.savefig('ns_plots/velocity_quiver_contour.png')
plt.close()

print("# Plots saved to 'ns_plots/' directory.")
print("# Simulation finished.")
```
****************************************
