
****************************************
```python
# Ensure only use # for annotations to explain each section of the code.

# Technical explanation for the solving algorithm:
# This code implements a finite difference method for solving the 2D unsteady incompressible Navier-Stokes equations
# using the Projection Method (also known as the Fractional Step Method). This method decouples the velocity and
# pressure fields, making the solution process more manageable.
#
# The algorithm proceeds in three main steps at each time iteration:
#
# 1.  Predictor Step (Momentum Equation without Pressure Gradient):
#     - An intermediate velocity field (u_star, v_star) is computed by solving the momentum equations
#       while temporarily omitting the pressure gradient term.
#     - The convective terms (u*du/dx, v*du/dy, etc.) and viscous terms (Laplacian) are calculated
#       using velocity values from the previous time step. An explicit Euler scheme is used for time integration
#       of these terms. This choice is simple but imposes a strict time step limit for stability.
#     - Boundary conditions for u_star and v_star are applied immediately after this explicit update.
#
# 2.  Pressure Correction Step (Poisson Equation for Pressure):
#     - The incompressibility condition (divergence-free velocity, ∇ ⋅ u = 0) is enforced. This leads to a
#       Poisson equation for pressure: ∇²p = (1/dt) * ∇ ⋅ u_star.
#     - The right-hand side (RHS) of this equation is the divergence of the intermediate velocity field, scaled by 1/dt.
#     - Boundary conditions for pressure are crucial:
#       - A Dirichlet condition (p=0) is applied at the outlet (right boundary), as specified.
#       - Homogeneous Neumann conditions (∂p/∂n=0) are applied at the other boundaries (inlet, top, and bottom walls).
#         This is a common simplification in projection methods, implying that the pressure gradient normal to these
#         boundaries is zero. These Neumann conditions are incorporated directly into the coefficients of the
#         Poisson matrix (A_poisson) by modifying the stencil at the boundary points.
#     - This linear system (Ap = b) is solved using the Generalized Minimal Residual (GMRES) iterative method.
#       To significantly improve GMRES convergence for the potentially ill-conditioned Poisson matrix, an Incomplete LU (ILU)
#       preconditioner (scipy.sparse.linalg.spilu) is employed.
#       Optimized part: The `SuperLU` object returned by `spilu` is wrapped in a `scipy.sparse.linalg.LinearOperator`
#       to be compatible with the `M` (preconditioner) argument of `gmres`, resolving the `TypeError` encountered previously.
#
# 3.  Velocity Correction Step:
#     - The intermediate velocities (u_star, v_star) are corrected by subtracting the pressure gradient,
#       scaled by the time step.
#     - This step ensures that the final velocity field (u_new, v_new) is divergence-free.
#       Optimized part: The divergence of the corrected velocity field is monitored and printed to verify
#       that the incompressibility constraint is being satisfied.
#     - Final boundary conditions for u_new and v_new are applied.
#
# Time stepping: An explicit Euler scheme is used for the predictor step. The time step (dt) is chosen
# conservatively based on both the Courant-Friedrichs-Lewy (CFL) condition (for convection) and the
# viscous diffusion limit to maintain numerical stability.
#
# Spatial Discretization: Central finite differences are used for all spatial derivatives (first and second order)
# for interior points. One-sided differences are used at boundaries for first derivatives. For the Laplacian,
# a 5-point stencil is used for interior points. For the pressure Poisson matrix, boundary conditions are
# incorporated directly into the matrix coefficients.

import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import lil_matrix, csr_matrix
from scipy.sparse.linalg import gmres, spilu, LinearOperator # Import LinearOperator
import time
import os

# --- Parameters and Grid Setup ---
# Define physical parameters
Re = 100.0  # Reynolds number
Lx = 2.0    # Length of the domain in x-direction
Ly = 1.0    # Length of the domain in y-direction
T_final = 0.5 # Final simulation time

# Define grid resolution
Nx = 81     # Number of grid points in x-direction
Ny = 41     # Number of grid points in y-direction

# Calculate grid spacing
dx = Lx / (Nx - 1)
dy = Ly / (Ny - 1)

# Generate mesh coordinates
x = np.linspace(0, Lx, Nx)
y = np.linspace(0, Ly, Ny)
X_mesh, Y_mesh = np.meshgrid(x, y) # Meshgrid for plotting and spatial functions

# Define time step
# Estimate dt based on stability criteria (CFL and viscous diffusion)
# Viscous diffusion limit: dt_visc = 0.5 * min(dx**2, dy**2) * Re (since kinematic viscosity nu = 1/Re)
dt_visc = 0.5 * min(dx**2, dy**2) * Re
# Convective limit (approximate max velocity from inlet BC): max_u ~ 1 * (sin(pi*0.5) + sin(3*pi*0.5) + sin(5*pi*0.5)) = 1 * (1 - 1 + 1) = 1
# However, the inlet profile is sin(pi*y) * (sin(pi*t) + sin(3*pi*t) + sin(5*pi*t)).
# Max value of sin(pi*y) is 1. Max value of (sin(pi*t) + sin(3*pi*t) + sin(5*pi*t)) can be up to 3.
# So, max_u can be up to 3.
dt_conv = min(dx, dy) / 3.0
# Take a conservative fraction of the minimum of these two limits for robustness
dt = min(dt_visc, dt_conv) * 0.1 # Reduced factor for more robustness
# Number of time steps
Nt = int(T_final / dt) + 1
dt = T_final / (Nt - 1) # Adjust dt slightly to hit T_final exactly

# Print simulation parameters for reliability check
print(f"# Simulation Parameters:")
print(f"# Reynolds Number (Re): {Re}")
print(f"# Domain: [{0}, {Lx}] x [{0}, {Ly}]")
print(f"# Grid: {Nx}x{Ny} points (dx={dx:.4f}, dy={dy:.4f})")
print(f"# Time: [0, {T_final}] (dt={dt:.6f}, Nt={Nt} steps)")

# --- Initialization ---
# Initialize velocity components (u, v) and pressure (p) to zero
# u, v, p are stored as (Ny, Nx) arrays for easier indexing (row=y, col=x)
u = np.zeros((Ny, Nx))
v = np.zeros((Ny, Nx))
p = np.zeros((Ny, Nx))

# Store previous time step values for explicit terms in predictor step
u_prev = np.copy(u)
v_prev = np.copy(v)

# --- Helper Functions ---

# Function to calculate the inlet velocity profile based on y-coordinates and current time
def inlet_u_profile(y_coords, current_t):
    return np.sin(np.pi * y_coords) * (np.sin(np.pi * current_t) + np.sin(3 * np.pi * current_t) + np.sin(5 * np.pi * current_t))

# Optimized part: Replaced np.gradient with explicit finite difference stencils for better control
# and consistency with boundary condition handling. This avoids potential ambiguities with
# np.gradient's internal boundary handling.
def compute_first_derivatives(field, dx_val, dy_val):
    """
    Computes first spatial derivatives (du/dx, du/dy) using central differences for interior points
    and one-sided differences at boundaries.
    """
    d_field_dx = np.zeros_like(field)
    d_field_dy = np.zeros_like(field)

    # d/dx (x-direction derivatives)
    # Interior points (central difference)
    d_field_dx[:, 1:-1] = (field[:, 2:] - field[:, 0:-2]) / (2 * dx_val)
    # Left boundary (forward difference)
    d_field_dx[:, 0] = (field[:, 1] - field[:, 0]) / dx_val
    # Right boundary (backward difference)
    d_field_dx[:, -1] = (field[:, -1] - field[:, -2]) / dx_val

    # d/dy (y-direction derivatives)
    # Interior points (central difference)
    d_field_dy[1:-1, :] = (field[2:, :] - field[0:-2, :]) / (2 * dy_val)
    # Bottom boundary (forward difference)
    d_field_dy[0, :] = (field[1, :] - field[0, :]) / dy_val
    # Top boundary (backward difference)
    d_field_dy[-1, :] = (field[-1, :] - field[-2, :]) / dy_val

    return d_field_dx, d_field_dy

# Optimized part: Implemented Laplacian using a direct 5-point stencil for clarity and control.
# Boundary values for the Laplacian are not explicitly computed here; instead, the boundary conditions
# for u_star and v_star are applied after the predictor step, which is standard for explicit schemes.
def compute_laplacian(field, dx_val, dy_val):
    """
    Computes the Laplacian (d^2/dx^2 + d^2/dy^2) using a 5-point stencil for interior points.
    Boundary values are not computed here; they are handled by explicit boundary conditions
    applied to u_star and v_star after the predictor step.
    """
    laplacian = np.zeros_like(field)

    # Interior points (standard 5-point stencil)
    laplacian[1:-1, 1:-1] = (field[1:-1, 2:] - 2 * field[1:-1, 1:-1] + field[1:-1, 0:-2]) / dx_val**2 + \
                            (field[2:, 1:-1] - 2 * field[1:-1, 1:-1] + field[0:-2, 1:-1]) / dy_val**2
    return laplacian

# --- Build Poisson Matrix (A_poisson) for Pressure ---
# Optimized part: Re-implemented matrix assembly for A_poisson to correctly handle
# homogeneous Neumann boundary conditions (∂p/∂n = 0) at inlet, top, and bottom walls,
# and Dirichlet boundary condition (p=0) at the outlet. This is crucial for GMRES convergence.
N_total = Nx * Ny # Total number of grid points (unknowns for pressure)
A_poisson = lil_matrix((N_total, N_total)) # Use LIL format for easy construction

# Coefficients for standard 5-point stencil for ∇²p = RHS
# The equation is (p_{i+1,j} - 2p_{i,j} + p_{i-1,j})/dx^2 + (p_{i,j+1} - 2p_{i,j} + p_{i,j-1})/dy^2 = RHS
# So, the diagonal coefficient for p_{i,j} is -2/dx^2 - 2/dy^2
# The off-diagonal coefficients are 1/dx^2 or 1/dy^2
coeff_diag_base = -2 / dx**2 - 2 / dy**2
coeff_x_off = 1 / dx**2
coeff_y_off = 1 / dy**2

for j in range(Ny):
    for i in range(Nx):
        k = j * Nx + i  # Flattened index for the current grid point (i, j)

        # Right boundary (Outlet, i=Nx-1): Dirichlet BC p=0
        # For these points, the equation is simply p_k = 0.
        # This means A_poisson[k,k] = 1.0 and all other entries in row k are 0.
        if i == Nx - 1:
            A_poisson[k, k] = 1.0
        else:
            # Interior points and other boundaries (Neumann BCs)
            # Start with the standard diagonal coefficient
            A_poisson[k, k] = coeff_diag_base

            # Add off-diagonal terms for neighbors
            # Left neighbor (i-1)
            if i > 0:
                A_poisson[k, k-1] = coeff_x_off
            # Right neighbor (i+1)
            if i < Nx - 1: # This condition is always true for non-outlet points
                A_poisson[k, k+1] = coeff_x_off
            # Bottom neighbor (j-1)
            if j > 0:
                A_poisson[k, k-Nx] = coeff_y_off
            # Top neighbor (j+1)
            if j < Ny - 1:
                A_poisson[k, k+Nx] = coeff_y_off

            # Apply homogeneous Neumann BC modifications to coefficients
            # For a homogeneous Neumann boundary (e.g., ∂p/∂x = 0 at i=0),
            # the ghost point (p_{-1,j}) is set equal to the adjacent interior point (p_{1,j}).
            # This effectively doubles the coefficient for the interior neighbor and keeps the diagonal unchanged.
            if i == 0: # Left boundary (Inlet): ∂p/∂x = 0
                # The term for p_{i-1,j} (which is p_{-1,j}) is replaced by p_{1,j}.
                # So, the coefficient for p_{k, k-1} (which doesn't exist for i=0) is effectively added to p_{k, k+1}.
                A_poisson[k, k+1] += coeff_x_off # Double the coefficient for the right neighbor

            if j == 0: # Bottom boundary (Wall): ∂p/∂y = 0
                A_poisson[k, k+Nx] += coeff_y_off # Double the coefficient for the top neighbor

            if j == Ny - 1: # Top boundary (Wall): ∂p/∂y = 0
                A_poisson[k, k-Nx] += coeff_y_off # Double the coefficient for the bottom neighbor

# Convert to CSR format for efficient GMRES solve
A_poisson = A_poisson.tocsr()

# Optimized part: Precompute ILU preconditioner for GMRES.
# This significantly improves the convergence rate of GMRES for the Poisson equation.
print("# Building ILU preconditioner for GMRES...")
# drop_tol: drop entries if their magnitude is smaller than this tolerance
# fill_factor: specifies the maximum number of non-zero elements in the factors L and U
# Adjusting these parameters can balance between preconditioning quality and computation time.
ilu_preconditioner = spilu(A_poisson, drop_tol=1e-5, fill_factor=20)
print("# ILU preconditioner built.")

# Optimized part: Create a LinearOperator for the ILU preconditioner.
# This resolves the TypeError when passing the SuperLU object directly to gmres.
def ilu_solve(x):
    return ilu_preconditioner.solve(x)
M_preconditioner = LinearOperator(A_poisson.shape, ilu_solve)
print("# LinearOperator for ILU preconditioner created.")

# --- Time Stepping Loop (Projection Method) ---
current_time = 0.0
print(f"# Starting time integration...")
start_time = time.time()

# Callback function to monitor GMRES residual
gmres_residuals = []
def gmres_callback(rk):
    # rk is the current residual vector. We store its L2 norm.
    gmres_residuals.append(np.linalg.norm(rk))

for n in range(Nt):
    current_time = n * dt

    # Print progress and solution statistics at regular intervals and at the last step
    if n % (Nt // 10) == 0 or n == Nt - 1:
        print(f"\n# Time step {n}/{Nt-1} (t={current_time:.4f})")
        print(f"#   Min/Max u: {u.min():.4e} / {u.max():.4e}")
        print(f"#   Min/Max v: {v.min():.4e} / {v.max():.4e}")
        print(f"#   Min/Max p: {p.min():.4e} / {p.max():.4e}")


    # 1. Predictor Step: Compute intermediate velocities (u_star, v_star)
    # Calculate derivatives of u and v from the previous time step
    u_prev_dx, u_prev_dy = compute_first_derivatives(u_prev, dx, dy)
    v_prev_dx, v_prev_dy = compute_first_derivatives(v_prev, dx, dy)

    # Calculate Laplacians of u and v from the previous time step
    laplacian_u_prev = compute_laplacian(u_prev, dx, dy)
    laplacian_v_prev = compute_laplacian(v_prev, dx, dy)

    # Calculate the forcing term f_y at the current time
    # f(x, y, t) = (0, -sin(pi x) sin(pi y) sin(pi t))
    f_y = -np.sin(np.pi * X_mesh) * np.sin(np.pi * Y_mesh) * np.sin(np.pi * current_time)

    # Compute u_star and v_star for all points (including boundaries initially)
    # Convective terms: u*du/dx + v*du/dy
    convective_u = u_prev * u_prev_dx + v_prev * u_prev_dy
    convective_v = u_prev * v_prev_dx + v_prev * v_prev_dy

    # Explicit Euler update for u_star and v_star
    u_star = u_prev + dt * (-convective_u + (1/Re) * laplacian_u_prev)
    v_star = v_prev + dt * (-convective_v + (1/Re) * laplacian_v_prev + f_y)

    # Apply boundary conditions for u_star and v_star
    # No-slip on top and bottom walls (j=0, Ny-1)
    u_star[0, :] = 0.0
    v_star[0, :] = 0.0
    u_star[Ny-1, :] = 0.0
    v_star[Ny-1, :] = 0.0

    # Inlet condition at left boundary (i=0)
    u_inlet_val = inlet_u_profile(y, current_time) # Calculate inlet profile at current time
    u_star[:, 0] = u_inlet_val
    v_star[:, 0] = 0.0

    # Outlet condition at right boundary (i=Nx-1): du/dx = 0, dv/dx = 0 (zero gradient)
    # This is implemented by setting the boundary value equal to the adjacent interior value.
    u_star[:, Nx-1] = u_star[:, Nx-2]
    v_star[:, Nx-1] = v_star[:, Nx-2]

    # 2. Pressure Correction Step: Solve Poisson equation for pressure
    # Calculate divergence of u_star
    u_star_dx, _ = compute_first_derivatives(u_star, dx, dy)
    _, v_star_dy = compute_first_derivatives(v_star, dx, dy)
    divergence_u_star = u_star_dx + v_star_dy

    # Optimized part: Vectorized assembly of the RHS vector for the Poisson equation.
    # This is faster than nested loops.
    # The RHS is (1/dt) * divergence(u_star).
    # No additional terms are added for homogeneous Neumann BCs, as these are handled in A_poisson.
    b_poisson_flat = (divergence_u_star / dt).flatten()

    # Apply Dirichlet BC for pressure at the outlet (i=Nx-1) to the RHS vector
    # For points on the outlet, p_k = 0, so the RHS is 0.
    for j in range(Ny):
        k = j * Nx + (Nx - 1) # Flattened index for outlet points
        b_poisson_flat[k] = 0.0

    # Solve the linear system A_poisson * p_flat = b_poisson_flat using GMRES
    # Optimized part: Using a preconditioner (M_preconditioner) for GMRES.
    # Also, using a callback to monitor residuals for detailed convergence information.
    gmres_residuals = [] # Reset residuals for current GMRES call
    p_flat, info = gmres(A_poisson, b_poisson_flat, x0=p.flatten(), atol=1e-8, maxiter=1000,
                         M=M_preconditioner, callback=gmres_callback) # Use M_preconditioner here
    p = p_flat.reshape((Ny, Nx)) # Reshape the solved pressure back to 2D array

    # Print GMRES convergence information
    if info == 0:
        print(f"#   GMRES converged at t={current_time:.4f} in {len(gmres_residuals)} iterations.")
    else:
        print(f"#   GMRES did NOT converge at t={current_time:.4f}, info={info} (maxiter reached).")
    if gmres_residuals:
        print(f"#   GMRES initial residual: {gmres_residuals[0]:.2e}, final residual: {gmres_residuals[-1]:.2e}")
    else:
        print("#   GMRES did not run any iterations (likely already converged or problem with setup).")

    # 3. Velocity Correction Step: Update velocities using the new pressure
    # Calculate pressure gradients
    p_dx, p_dy = compute_first_derivatives(p, dx, dy)

    # Correct u_star and v_star to obtain divergence-free u_new and v_new
    u_new = u_star - dt * p_dx
    v_new = v_star - dt * p_dy

    # Apply final boundary conditions for u_new and v_new
    # No-slip on top and bottom walls (j=0, Ny-1)
    u_new[0, :] = 0.0
    v_new[0, :] = 0.0
    u_new[Ny-1, :] = 0.0
    v_new[Ny-1, :] = 0.0

    # Inlet condition at left boundary (i=0)
    u_new[:, 0] = u_inlet_val
    v_new[:, 0] = 0.0

    # Outlet condition at right boundary (i=Nx-1): du/dx = 0, dv/dx = 0 (zero gradient)
    u_new[:, Nx-1] = u_new[:, Nx-2]
    v_new[:, Nx-1] = v_new[:, Nx-2]

    # Optimized part: Monitor divergence of the corrected velocity field
    # This is a crucial check for the incompressibility constraint.
    u_new_dx, _ = compute_first_derivatives(u_new, dx, dy)
    _, v_new_dy = compute_first_derivatives(v_new, dx, dy)
    divergence_u_new = u_new_dx + v_new_dy
    print(f"#   Divergence (∇·u) min/max/mean/std: {divergence_u_new.min():.2e} / {divergence_u_new.max():.2e} / {divergence_u_new.mean():.2e} / {divergence_u_new.std():.2e}")


    # Update for next time step: current solution becomes previous for next iteration
    u_prev = np.copy(u_new)
    v_prev = np.copy(v_new)
    u = np.copy(u_new) # u is the current solution
    v = np.copy(v_new) # v is the current solution

    # Check for NaNs/Infs to detect numerical instability early
    if np.any(np.isnan(u)) or np.any(np.isinf(u)) or \
       np.any(np.isnan(v)) or np.any(np.isinf(v)) or \
       np.any(np.isnan(p)) or np.any(np.isinf(p)):
        print(f"!!! WARNING: NaN or Inf detected at time step {n} (t={current_time:.4f}). Aborting simulation.")
        break

end_time = time.time()
print(f"\n# Time integration completed in {end_time - start_time:.2f} seconds.")

# --- Plotting Results at T_final ---
print(f"# Plotting results at t={T_final:.4f}...")

# Create a directory for plots if it doesn't exist
if not os.path.exists("ns_plots"):
    os.makedirs("ns_plots")

# Plot u velocity contour
plt.figure(figsize=(10, 5))
plt.contourf(X_mesh, Y_mesh, u, levels=50, cmap='jet') # Use jet colormap
plt.colorbar(label='u velocity')
plt.title(f'u Velocity Contour at t = {T_final:.2f}')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal') # Maintain aspect ratio
plt.tight_layout() # Adjust layout to prevent labels overlapping
plt.savefig('ns_plots/u_velocity_contour.png') # Save figure
plt.close() # Close figure to free memory

# Plot v velocity contour
plt.figure(figsize=(10, 5))
plt.contourf(X_mesh, Y_mesh, v, levels=50, cmap='jet') # Use jet colormap
plt.colorbar(label='v velocity')
plt.title(f'v Velocity Contour at t = {T_final:.2f}')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal')
plt.tight_layout()
plt.savefig('ns_plots/v_velocity_contour.png') # Save figure
plt.close()

# Plot pressure contour
plt.figure(figsize=(10, 5))
plt.contourf(X_mesh, Y_mesh, p, levels=50, cmap='jet') # Use jet colormap
plt.colorbar(label='Pressure')
plt.title(f'Pressure Contour at t = {T_final:.2f}')
plt.xlabel('x')
plt.ylabel('y')
plt.axis('equal')
plt.tight_layout()
plt.savefig('ns_plots/pressure_contour.png') # Save figure
plt.close()

print("# Plots saved to 'ns_plots/' directory.")
print("# Simulation finished.")
```
****************************************
