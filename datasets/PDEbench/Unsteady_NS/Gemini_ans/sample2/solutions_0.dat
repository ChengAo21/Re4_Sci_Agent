
****************************************
```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt
import os

# Technical explanation for the solving algorithm:
# This code implements a Finite Difference Method (FDM) for solving the 2D unsteady
# incompressible Navier-Stokes equations. The core approach is a fractional step
# (or projection) method, which effectively decouples the velocity and pressure fields.
# This method, often attributed to Chorin, proceeds in three main steps at each time iteration:
#
# 1. Spatial Discretization:
#    - A uniform Cartesian grid is used for the spatial domain.
#    - All primary variables (u, v, p) are collocated at the grid nodes (cell centers or vertices).
#    - Spatial derivatives (convection, diffusion, pressure gradients, divergence)
#      are approximated using second-order central finite differences for interior points.
#      For boundary conditions involving derivatives (Neumann type), second-order
#      approximations using ghost cells are employed to maintain accuracy.
#
# 2. Time Integration (Fractional Step Method - Chorin's Projection):
#    - The time integration is explicit (Forward Euler) for the convective and forcing terms.
#    - Diffusion terms are also treated explicitly in the predictor step for simplicity.
#      While implicit treatment (e.g., Crank-Nicolson) would offer better stability
#      for viscous terms, explicit treatment is chosen here for a more straightforward
#      implementation, requiring a sufficiently small time step.
#    - The method proceeds as follows:
#      a. Predictor Step (Momentum Equations without Pressure):
#         - An intermediate velocity field (u_star, v_star) is computed by solving
#           the momentum equations, neglecting the pressure gradient terms.
#         - This step accounts for the effects of convection, diffusion, and external
#           body forces on the velocity.
#         - Dirichlet boundary conditions for velocity (no-slip walls, inlet) are
#           directly applied to u_star and v_star.
#         - Neumann boundary conditions for velocity (outlet, zero-gradient) are
#           also applied to the intermediate velocity field.
#      b. Pressure Correction Step (Poisson Equation for Pressure):
#         - The intermediate velocity field (u_star, v_star) is generally not
#           divergence-free, violating the incompressibility constraint.
#         - A Poisson equation for pressure (p_new) is formulated. The right-hand
#           side (RHS) of this Poisson equation is proportional to the divergence
#           of the intermediate velocity field, ensuring that the subsequent
#           velocity correction makes the field divergence-free.
#         - This large, sparse linear system (A * p_vec = b_vec) is constructed
#           and solved using a sparse direct solver from `scipy.sparse.linalg.spsolve`.
#         - Boundary conditions for pressure are critical: Dirichlet at the outlet (p=0)
#           and Neumann (dp/dn=0) at other boundaries (inlet, top, bottom walls) are
#           implemented by modifying the coefficients of the Poisson matrix for boundary points.
#      c. Velocity Correction Step:
#         - The final, divergence-free velocity field (u_new, v_new) for the current
#           time step is obtained by correcting the intermediate velocity (u_star, v_star)
#           using the pressure gradients calculated from the newly solved pressure field.
#         - All velocity boundary conditions (Dirichlet and Neumann) are then applied
#           to the corrected velocity field to ensure consistency with the physical problem.
#
# 3. Boundary Conditions (BCs) Implementation:
#    - No-slip (top and bottom walls): Velocity components (u, v) are set to zero (Dirichlet BCs).
#    - Inlet (left boundary): Velocity components (u, v) are specified as time-dependent
#      functions (Dirichlet BCs).
#    - Outlet (right boundary): Zero-gradient conditions for velocity (du/dx=0, dv/dx=0)
#      (Neumann BCs) and a fixed pressure of zero (p=0) (Dirichlet BC for pressure).
#      Neumann velocity BCs are approximated by setting the boundary value equal to the
#      neighboring interior value (first-order zero-gradient) for simplicity, or by
#      using ghost cells for second-order accuracy.
#
# 4. Solver for Poisson Equation:
#    - The discretized Poisson equation results in a large, sparse linear system.
#    - `scipy.sparse.linalg.spsolve` is used, which is a direct solver. It is robust
#      for moderately sized systems. For very large-scale simulations, iterative
#      solvers (e.g., Conjugate Gradient, BiCGSTAB) would be more memory-efficient
#      and computationally faster.
#
# 5. Stability Considerations:
#    - The explicit time integration scheme requires a time step (dt) that satisfies
#      both the Courant-Friedrichs-Lewy (CFL) condition (for convection) and the
#      Fourier number condition (for diffusion) to ensure numerical stability.
#      The chosen `dt` is conservative based on these criteria.
#    - Using a collocated grid (where all variables are defined at the same points)
#      can sometimes lead to pressure oscillations (checkerboard patterns) if not
#      stabilized (e.g., with staggered grids or Rhie-Chow interpolation). This
#      implementation uses a simple collocated grid, which might exhibit such
#      oscillations if the grid resolution or time step is not sufficiently fine.

# 1. Parameters and Grid Setup
Lx = 2.0  # Domain length in x-direction
Ly = 1.0  # Domain length in y-direction
Re = 100.0  # Reynolds number

Nx = 81  # Number of grid points in x-direction (including boundaries)
Ny = 41  # Number of grid points in y-direction (including boundaries)
dx = Lx / (Nx - 1)  # Grid spacing in x-direction
dy = Ly / (Ny - 1)  # Grid spacing in y-direction

T_final = 5.0  # Final simulation time
dt = 0.005  # Time step size
Nt = int(T_final / dt)  # Number of time steps

# Create meshgrid for spatial coordinates. 'ij' indexing ensures X[i,j] is x_i and Y[i,j] is y_j.
x = np.linspace(0, Lx, Nx)
y = np.linspace(0, Ly, Ny)
X, Y = np.meshgrid(x, y, indexing='ij')

# 2. Initial Conditions
u = np.zeros((Nx, Ny))  # Velocity component in x-direction
v = np.zeros((Nx, Ny))  # Velocity component in y-direction
p = np.zeros((Nx, Ny))  # Pressure field

# Store results for plotting at specific timesteps
plot_times = [0.5, 2.5, 5.0]
results = {t: {'u': None, 'v': None, 'p': None} for t in plot_times}
current_plot_idx = 0 # Index to track which plot_time is next

# Create directory for saving plots
output_dir = "ns_2d_results"
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# 3. Define Forcing Term and Inlet BC functions
def forcing_term_y(x_val, y_val, t_val):
    # f(x, y, t) = (0, -sin(pi x) sin(pi y) sin(pi t))
    return -np.sin(np.pi * x_val) * np.sin(np.pi * y_val) * np.sin(np.pi * t_val)

def inlet_u_bc(y_val, t_val):
    # u(0, y, t) = sin(pi y) (sin(pi t) + sin(3pi t) + sin(5pi t))
    return np.sin(np.pi * y_val) * (np.sin(np.pi * t_val) + np.sin(3 * np.pi * t_val) + np.sin(5 * np.pi * t_val))

# Helper functions for calculating spatial derivatives using central differences
# These functions are designed for interior points (i,j)
def du_dx(field, i, j): return (field[i+1, j] - field[i-1, j]) / (2 * dx)
def du_dy(field, i, j): return (field[i, j+1] - field[i, j-1]) / (2 * dy)
def d2_dx2(field, i, j): return (field[i+1, j] - 2 * field[i, j] + field[i-1, j]) / dx**2
def d2_dy2(field, i, j): return (field[i, j+1] - 2 * field[i, j] + field[i, j-1]) / dy**2

# 4. Time Stepping Loop
print(f"Starting simulation with Nx={Nx}, Ny={Ny}, dx={dx:.4f}, dy={dy:.4f}, dt={dt:.4f}, Nt={Nt}")
print(f"Reynolds number Re={Re}")
print(f"Saving plots at times: {plot_times}")

for n in range(Nt + 1):
    current_time = n * dt

    # Print necessary solving information to facilitate reliability check
    if n % (Nt // 10) == 0 or (current_plot_idx < len(plot_times) and np.isclose(current_time, plot_times[current_plot_idx], atol=dt/2)):
        print(f"\n--- Time Step: {n}/{Nt} (t = {current_time:.4f}) ---")
        print(f"Max u: {np.max(u):.4e}, Min u: {np.min(u):.4e}")
        print(f"Max v: {np.max(v):.4e}, Min v: {np.min(v):.4e}")
        print(f"Max p: {np.max(p):.4e}, Min p: {np.min(p):.4e}")

    # Create copies of current velocity fields for time stepping
    u_prev = u.copy()
    v_prev = v.copy()

    # Apply all velocity boundary conditions to u_prev and v_prev before predictor step
    # This ensures BCs are consistent for derivative calculations at boundaries
    # Inlet BCs (left boundary)
    u_prev[0, :] = inlet_u_bc(y, current_time)
    v_prev[0, :] = 0.0

    # No-slip BCs (top and bottom walls)
    u_prev[:, 0] = 0.0  # Bottom wall
    u_prev[:, Ny-1] = 0.0 # Top wall
    v_prev[:, 0] = 0.0  # Bottom wall
    v_prev[:, Ny-1] = 0.0 # Top wall

    # Outlet BCs (right boundary - zero-gradient, first-order approximation)
    u_prev[Nx-1, :] = u_prev[Nx-2, :]
    v_prev[Nx-1, :] = v_prev[Nx-2, :]

    # --- a. Predictor Step (Compute u_star, v_star) ---
    u_star = np.zeros_like(u_prev)
    v_star = np.zeros_like(v_prev)

    # Calculate derivatives and update u_star, v_star for interior points
    for i in range(1, Nx - 1):
        for j in range(1, Ny - 1):
            # Convective terms
            conv_u = u_prev[i, j] * du_dx(u_prev, i, j) + v_prev[i, j] * du_dy(u_prev, i, j)
            conv_v = u_prev[i, j] * du_dx(v_prev, i, j) + v_prev[i, j] * du_dy(v_prev, i, j)

            # Diffusive terms
            diff_u = (1/Re) * (d2_dx2(u_prev, i, j) + d2_dy2(u_prev, i, j))
            diff_v = (1/Re) * (d2_dx2(v_prev, i, j) + d2_dy2(v_prev, i, j))

            # Forcing term (only in y-direction)
            f_y_val = forcing_term_y(X[i, j], Y[i, j], current_time)

            # Update u_star, v_star using Forward Euler
            u_star[i, j] = u_prev[i, j] + dt * (-conv_u + diff_u)
            v_star[i, j] = v_prev[i, j] + dt * (-conv_v + diff_v + f_y_val)

    # Apply Dirichlet BCs for u_star, v_star (no-slip, inlet)
    u_star[0, :] = inlet_u_bc(y, current_time) # Inlet
    v_star[0, :] = 0.0 # Inlet
    u_star[:, 0] = 0.0 # Bottom wall
    u_star[:, Ny-1] = 0.0 # Top wall
    v_star[:, 0] = 0.0 # Bottom wall
    v_star[:, Ny-1] = 0.0 # Top wall

    # Apply Neumann BCs for u_star, v_star (outlet - zero gradient)
    u_star[Nx-1, :] = u_star[Nx-2, :]
    v_star[Nx-1, :] = v_star[Nx-2, :]

    # --- b. Pressure Correction Step (Solve Poisson Equation for Pressure) ---
    # Calculate RHS for Poisson equation: RHS = (1/dt) * (du_star/dx + dv_star/dy)
    RHS = np.zeros((Nx, Ny))
    for i in range(1, Nx - 1):
        for j in range(1, Ny - 1):
            # Divergence of intermediate velocity
            div_u_star = (u_star[i+1, j] - u_star[i-1, j]) / (2 * dx) + \
                         (v_star[i, j+1] - v_star[i, j-1]) / (2 * dy)
            RHS[i, j] = div_u_star / dt

    # Construct sparse matrix A and vector b for the linear system A * p_vec = b_vec
    N_total = Nx * Ny # Total number of pressure unknowns
    A = sp.lil_matrix((N_total, N_total)) # Use LIL format for efficient matrix construction
    b_poisson = np.zeros(N_total)

    for i in range(Nx):
        for j in range(Ny):
            k = i * Ny + j # Linear index for (i,j)

            if i == Nx - 1: # Right boundary (Dirichlet p=0)
                A[k, k] = 1.0 # Set diagonal to 1
                b_poisson[k] = 0.0 # Set RHS to 0
            else: # All other points (interior and other boundaries)
                # Standard Laplacian stencil for interior points
                A[k, k] = -2/dx**2 - 2/dy**2
                b_poisson[k] = RHS[i, j]

                # Neighbors in x-direction
                if i == 0: # Left boundary (Neumann dp/dx=0, using ghost cell p[-1,j] = p[1,j])
                    A[k, k+Ny] += 2/dx**2 # Coefficient for p[i+1,j] (p[1,j]) becomes 2/dx^2
                else: # Interior or top/bottom boundaries
                    A[k, k+Ny] += 1/dx**2 # Coefficient for p[i+1,j]
                    A[k, k-Ny] += 1/dx**2 # Coefficient for p[i-1,j]

                # Neighbors in y-direction
                if j == 0: # Bottom boundary (Neumann dp/dy=0, using ghost cell p[i,-1] = p[i,1])
                    A[k, k+1] += 2/dy**2 # Coefficient for p[i,j+1] (p[i,1]) becomes 2/dy^2
                elif j == Ny - 1: # Top boundary (Neumann dp/dy=0, using ghost cell p[i,Ny] = p[i,Ny-2])
                    A[k, k-1] += 2/dy**2 # Coefficient for p[i,j-1] (p[i,Ny-2]) becomes 2/dy^2
                else: # Interior or left/right boundaries
                    A[k, k+1] += 1/dy**2 # Coefficient for p[i,j+1]
                    A[k, k-1] += 1/dy**2 # Coefficient for p[i,j-1]

    # Convert to CSR format for efficient solving with spsolve
    A = A.tocsr()

    # Solve for pressure field
    p_vec = spla.spsolve(A, b_poisson)
    p_new = p_vec.reshape((Nx, Ny)) # Reshape 1D solution vector back to 2D grid

    # --- c. Velocity Correction Step ---
    u_new = np.zeros_like(u_star)
    v_new = np.zeros_like(v_star)

    # Calculate pressure gradients and update velocities for interior points
    for i in range(1, Nx - 1):
        for j in range(1, Ny - 1):
            dp_dx_val = (p_new[i+1, j] - p_new[i-1, j]) / (2 * dx)
            dp_dy_val = (p_new[i, j+1] - p_new[i, j-1]) / (2 * dy)

            u_new[i, j] = u_star[i, j] - dt * dp_dx_val
            v_new[i, j] = v_star[i, j] - dt * dp_dy_val

    # Apply all velocity boundary conditions to u_new, v_new
    # Inlet BCs
    u_new[0, :] = inlet_u_bc(y, current_time)
    v_new[0, :] = 0.0

    # No-slip BCs (top and bottom walls)
    u_new[:, 0] = 0.0
    u_new[:, Ny-1] = 0.0
    v_new[:, 0] = 0.0
    v_new[:, Ny-1] = 0.0

    # Outlet BCs (zero-gradient)
    u_new[Nx-1, :] = u_new[Nx-2, :]
    v_new[Nx-1, :] = v_new[Nx-2, :]

    # Update fields for the next time step
    u = u_new.copy()
    v = v_new.copy()
    p = p_new.copy()

    # Store results for plotting if current_time matches a plot_time
    if current_plot_idx < len(plot_times) and np.isclose(current_time, plot_times[current_plot_idx], atol=dt/2):
        results[plot_times[current_plot_idx]]['u'] = u.copy()
        results[plot_times[current_plot_idx]]['v'] = v.copy()
        results[plot_times[current_plot_idx]]['p'] = p.copy()
        print(f"--- Stored results for plotting at t = {current_time:.4f} ---")
        current_plot_idx += 1

# 5. Plotting
print("\n--- Generating plots ---")
for t_plot in plot_times:
    if results[t_plot]['u'] is not None:
        u_plot = results[t_plot]['u']
        v_plot = results[t_plot]['v']
        p_plot = results[t_plot]['p']

        # Plot u velocity contour
        plt.figure(figsize=(10, 5))
        plt.contourf(X, Y, u_plot, levels=50, cmap='viridis')
        plt.colorbar(label='u velocity')
        plt.title(f'u velocity at t = {t_plot} (Re={Re})')
        plt.xlabel('x')
        plt.ylabel('y')
        plt.gca().set_aspect('equal', adjustable='box') # Maintain aspect ratio
        plt.savefig(os.path.join(output_dir, f'u_velocity_t{t_plot}.png'))
        plt.close() # Close figure to free memory

        # Plot v velocity contour
        plt.figure(figsize=(10, 5))
        plt.contourf(X, Y, v_plot, levels=50, cmap='viridis')
        plt.colorbar(label='v velocity')
        plt.title(f'v velocity at t = {t_plot} (Re={Re})')
        plt.xlabel('x')
        plt.ylabel('y')
        plt.gca().set_aspect('equal', adjustable='box')
        plt.savefig(os.path.join(output_dir, f'v_velocity_t{t_plot}.png'))
        plt.close()

        # Plot pressure contour
        plt.figure(figsize=(10, 5))
        plt.contourf(X, Y, p_plot, levels=50, cmap='viridis')
        plt.colorbar(label='Pressure')
        plt.title(f'Pressure at t = {t_plot} (Re={Re})')
        plt.xlabel('x')
        plt.ylabel('y')
        plt.gca().set_aspect('equal', adjustable='box')
        plt.savefig(os.path.join(output_dir, f'pressure_t{t_plot}.png'))
        plt.close()
    else:
        print(f"Warning: Results for t = {t_plot} were not captured. Skipping plot.")

print(f"\nSimulation finished. Plots saved in '{output_dir}' directory.")
```
****************************************
Starting simulation with Nx=81, Ny=41, dx=0.0250, dy=0.0250, dt=0.0050, Nt=1000
Reynolds number Re=100.0
Saving plots at times: [0.5, 2.5, 5.0]

--- Time Step: 0/1000 (t = 0.0000) ---
Max u: 0.0000e+00, Min u: 0.0000e+00
Max v: 0.0000e+00, Min v: 0.0000e+00
Max p: 0.0000e+00, Min p: 0.0000e+00

--- Time Step: 100/1000 (t = 0.5000) ---
Max u: 1.0563e+00, Min u: 0.0000e+00
Max v: 1.6273e-01, Min v: -2.3602e-01
Max p: 3.4229e+00, Min p: 0.0000e+00
--- Stored results for plotting at t = 0.5000 ---

--- Time Step: 200/1000 (t = 1.0000) ---
Max u: 6.9941e-01, Min u: -4.6296e-01
Max v: 4.6970e-01, Min v: -4.6869e-01
Max p: 0.0000e+00, Min p: -3.5738e+01

--- Time Step: 300/1000 (t = 1.5000) ---
Max u: 0.0000e+00, Min u: -9.9790e-01
Max v: 3.0156e-01, Min v: -3.7964e-01
Max p: 0.0000e+00, Min p: -4.0710e+00

--- Time Step: 400/1000 (t = 2.0000) ---
Max u: 3.5866e-01, Min u: -5.2653e-01
Max v: 1.8615e-01, Min v: -1.8613e-01
Max p: 3.6799e+01, Min p: 0.0000e+00

--- Time Step: 500/1000 (t = 2.5000) ---
Max u: 1.0529e+00, Min u: 0.0000e+00
Max v: 1.6269e-01, Min v: -2.1881e-01
Max p: 3.4652e+00, Min p: 0.0000e+00
--- Stored results for plotting at t = 2.5000 ---

--- Time Step: 600/1000 (t = 3.0000) ---
Max u: 6.9941e-01, Min u: -4.4524e-01
Max v: 4.6988e-01, Min v: -4.6854e-01
Max p: 0.0000e+00, Min p: -3.5736e+01

--- Time Step: 700/1000 (t = 3.5000) ---
Max u: 0.0000e+00, Min u: -9.9790e-01
Max v: 3.0533e-01, Min v: -3.7632e-01
Max p: 0.0000e+00, Min p: -4.0736e+00

--- Time Step: 800/1000 (t = 4.0000) ---
Max u: 3.6950e-01, Min u: -5.3314e-01
Max v: 1.8540e-01, Min v: -1.8692e-01
Max p: 3.6799e+01, Min p: 0.0000e+00

--- Time Step: 900/1000 (t = 4.5000) ---
Max u: 1.0526e+00, Min u: 0.0000e+00
Max v: 1.6329e-01, Min v: -2.1215e-01
Max p: 3.4648e+00, Min p: 0.0000e+00

--- Time Step: 1000/1000 (t = 5.0000) ---
Max u: 6.9945e-01, Min u: -4.4484e-01
Max v: 4.6994e-01, Min v: -4.6848e-01
Max p: 0.0000e+00, Min p: -3.5736e+01
--- Stored results for plotting at t = 5.0000 ---

--- Generating plots ---