
****************************************
```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt

# ---------------------------
# Technical explanation:
# We implement the Projection Method (Chorin's fractional step) to solve the 2D unsteady incompressible Navier-Stokes equations.
# The method decouples velocity and pressure by:
# 1) Computing an intermediate velocity field ignoring pressure.
# 2) Solving a Poisson equation for pressure correction to enforce incompressibility.
# 3) Correcting velocity with the pressure gradient.
#
# Spatial derivatives are approximated by second-order central finite differences on a uniform grid.
# Time integration uses explicit Euler for convective and forcing terms, implicit treatment of viscous terms via Crank-Nicolson is not used here for simplicity.
# The pressure Poisson equation is solved using GMRES with atol tolerance.
#
# Boundary conditions:
# - No-slip (u=v=0) on top and bottom walls.
# - Inlet velocity profile on left boundary.
# - Outlet: Neumann for velocity gradients, Dirichlet p=0 on right boundary.
#
# The forcing term acts only on v-momentum.
#
# At final time t=0.5, velocity components u,v and pressure p are plotted as contour plots with jet colormap.
# Solver iteration info is printed for each Poisson solve.
# ---------------------------

# Domain parameters
Lx, Ly = 2.0, 1.0
Nx, Ny = 81, 41  # grid points in x and y
dx, dy = Lx/(Nx-1), Ly/(Ny-1)
x = np.linspace(0, Lx, Nx)
y = np.linspace(0, Ly, Ny)

# Time parameters
Re = 100.0
dt = 0.002  # time step size (small for stability)
t_final = 0.5
nt = int(t_final/dt)

# Create meshgrid for forcing and BC evaluation
X, Y = np.meshgrid(x, y, indexing='ij')

# Initialize fields: u, v, p
u = np.zeros((Nx, Ny))
v = np.zeros((Nx, Ny))
p = np.zeros((Nx, Ny))

# Helper function: forcing term f = (0, fy)
def forcing(t):
    fy = -np.sin(np.pi * X) * np.sin(np.pi * Y) * np.sin(np.pi * t)
    return np.zeros_like(fy), fy

# Boundary condition functions for inlet velocity u,v at x=0
def inlet_velocity(y, t):
    val = np.sin(np.pi * y) * (np.sin(np.pi * t) + np.sin(3*np.pi * t) + np.sin(5*np.pi * t))
    return val

# Build Laplacian operator for pressure Poisson equation with Neumann and Dirichlet BCs
def build_pressure_poisson_matrix(Nx, Ny, dx, dy):
    N = Nx * Ny
    diagonals = []
    offsets = []

    # 5-point Laplacian stencil with Dirichlet p=0 at right boundary (x=Lx)
    # and Neumann elsewhere for pressure

    main_diag = np.ones(N) * (-2/dx**2 - 2/dy**2)
    off_diag_x = np.ones(N-1) / dx**2
    off_diag_y = np.ones(N - Ny) / dy**2

    # Adjust for boundary conditions:
    # We will enforce p=0 at right boundary (x=Lx) by setting rows corresponding to that boundary to identity

    # Create sparse matrix in lil format for easy assignment
    A = sp.lil_matrix((N, N))

    for i in range(Nx):
        for j in range(Ny):
            idx = i*Ny + j
            if i == Nx-1:
                # Dirichlet p=0 at right boundary
                A[idx, idx] = 1.0
            else:
                # Interior or other boundaries: fill Laplacian stencil
                A[idx, idx] = main_diag[idx]
                # left neighbor
                if i > 0:
                    A[idx, idx - Ny] = 1/dx**2
                else:
                    # Neumann BC at left boundary for pressure: dp/dx=0
                    # Implemented by zero flux: approximate by one-sided difference
                    A[idx, idx] += 1/dx**2  # Neumann BC modifies diagonal

                # right neighbor
                if i < Nx-1:
                    A[idx, idx + Ny] = 1/dx**2

                # bottom neighbor
                if j > 0:
                    A[idx, idx - 1] = 1/dy**2
                else:
                    # Neumann BC at bottom boundary for pressure: dp/dy=0
                    A[idx, idx] += 1/dy**2

                # top neighbor
                if j < Ny-1:
                    A[idx, idx + 1] = 1/dy**2
                else:
                    # Neumann BC at top boundary for pressure: dp/dy=0
                    A[idx, idx] += 1/dy**2

    return A.tocsr()

# Build pressure Poisson matrix once
A_p = build_pressure_poisson_matrix(Nx, Ny, dx, dy)

# Function to compute divergence of velocity field
def divergence(u, v, dx, dy):
    dudx = (u[2:,1:-1] - u[:-2,1:-1]) / (2*dx)
    dvdy = (v[1:-1,2:] - v[1:-1,:-2]) / (2*dy)
    div = np.zeros_like(u[1:-1,1:-1])
    div[:,:] = dudx + dvdy
    return div

# Function to compute gradient of pressure field
def gradient_p(p, dx, dy):
    dpdx = np.zeros_like(p)
    dpdy = np.zeros_like(p)
    dpdx[1:-1,1:-1] = (p[2:,1:-1] - p[:-2,1:-1]) / (2*dx)
    dpdy[1:-1,1:-1] = (p[1:-1,2:] - p[1:-1,:-2]) / (2*dy)
    # Neumann BC for dp/dx at right boundary: zero gradient
    dpdx[-1,:] = dpdx[-2,:]
    # Neumann BC for dp/dy at top and bottom boundaries: zero gradient
    dpdy[:,0] = dpdy[:,1]
    dpdy[:,-1] = dpdy[:,-2]
    return dpdx, dpdy

# Function to compute Laplacian of a scalar field
def laplacian(phi, dx, dy):
    lap = np.zeros_like(phi)
    lap[1:-1,1:-1] = (
        (phi[2:,1:-1] - 2*phi[1:-1,1:-1] + phi[:-2,1:-1]) / dx**2 +
        (phi[1:-1,2:] - 2*phi[1:-1,1:-1] + phi[1:-1,:-2]) / dy**2
    )
    # Neumann BC: zero second derivative at boundaries (approximate)
    lap[0,:] = lap[1,:]
    lap[-1,:] = lap[-2,:]
    lap[:,0] = lap[:,1]
    lap[:,-1] = lap[:,-2]
    return lap

# Function to apply velocity boundary conditions at current time t
def apply_velocity_bc(u, v, t):
    # No-slip top and bottom walls (y=0 and y=Ly)
    u[:,0] = 0.0
    v[:,0] = 0.0
    u[:,-1] = 0.0
    v[:,-1] = 0.0

    # Inlet (x=0)
    u[0,:] = inlet_velocity(y, t)
    v[0,:] = 0.0

    # Outlet (x=Lx) Neumann for velocity gradients:
    # Approximate by copying values from interior (zero gradient)
    u[-1,:] = u[-2,:]
    v[-1,:] = v[-2,:]

# Function to apply pressure boundary conditions
def apply_pressure_bc(p):
    # Dirichlet p=0 at right boundary (x=Lx)
    p[-1,:] = 0.0
    # Neumann elsewhere (already handled in matrix assembly)
    # For numerical stability, copy adjacent values at other boundaries
    p[0,:] = p[1,:]  # left boundary Neumann
    p[:,0] = p[:,1]  # bottom boundary Neumann
    p[:,-1] = p[:,-2]  # top boundary Neumann

# Flatten 2D array to 1D vector for linear solver
def flatten(arr):
    return arr.ravel(order='C')

# Reshape 1D vector to 2D array
def reshape(vec):
    return vec.reshape((Nx, Ny), order='C')

# Main time-stepping loop
print("Starting time integration...")
for n in range(nt):
    t = (n+1)*dt

    # Compute forcing term at current time
    fx, fy = forcing(t)

    # Compute nonlinear convective terms using central differences (interior points)
    u_x = (u[2:,1:-1] - u[:-2,1:-1]) / (2*dx)
    u_y = (u[1:-1,2:] - u[1:-1,:-2]) / (2*dy)
    v_x = (v[2:,1:-1] - v[:-2,1:-1]) / (2*dx)
    v_y = (v[1:-1,2:] - v[1:-1,:-2]) / (2*dy)

    u_c = u[1:-1,1:-1]
    v_c = v[1:-1,1:-1]

    conv_u = u_c * u_x + v_c * u_y
    conv_v = u_c * v_x + v_c * v_y

    # Compute viscous terms (Laplacian)
    lap_u = laplacian(u, dx, dy)
    lap_v = laplacian(v, dx, dy)

    # Intermediate velocity u_star, v_star (explicit Euler step ignoring pressure gradient)
    u_star = np.copy(u)
    v_star = np.copy(v)

    u_star[1:-1,1:-1] = u[1:-1,1:-1] + dt * (
        - conv_u + (1/Re)*lap_u[1:-1,1:-1] + fx[1:-1,1:-1]
    )
    v_star[1:-1,1:-1] = v[1:-1,1:-1] + dt * (
        - conv_v + (1/Re)*lap_v[1:-1,1:-1] + fy[1:-1,1:-1]
    )

    # Apply velocity BCs to intermediate velocity
    apply_velocity_bc(u_star, v_star, t)

    # Compute RHS for pressure Poisson equation: divergence of u_star / dt
    div_u_star = np.zeros((Nx, Ny))
    div_u_star[1:-1,1:-1] = (
        (u_star[2:,1:-1] - u_star[:-2,1:-1])/(2*dx) +
        (v_star[1:-1,2:] - v_star[1:-1,:-2])/(2*dy)
    )
    rhs_p = flatten(div_u_star / dt)

    # Solve pressure Poisson equation A_p p = rhs_p using GMRES
    # Initial guess: previous pressure
    p0 = flatten(p)

    # Callback function to print GMRES iteration info
    gmres_iter = [0]
    def gmres_callback(rk=None):
        gmres_iter[0] += 1

    p_vec, info = spla.gmres(A_p, rhs_p, x0=p0, atol=1e-8, callback=gmres_callback, restart=50, maxiter=500)
    if info == 0:
        print(f"Time step {n+1}/{nt}, t={t:.3f}: GMRES converged in {gmres_iter[0]} iterations.")
    else:
        print(f"Time step {n+1}/{nt}, t={t:.3f}: GMRES did NOT converge after {gmres_iter[0]} iterations, info={info}.")

    p = reshape(p_vec)
    apply_pressure_bc(p)

    # Compute pressure gradient
    dpdx, dpdy = gradient_p(p, dx, dy)

    # Correct velocity to enforce incompressibility
    u[1:-1,1:-1] = u_star[1:-1,1:-1] - dt * dpdx[1:-1,1:-1]
    v[1:-1,1:-1] = v_star[1:-1,1:-1] - dt * dpdy[1:-1,1:-1]

    # Re-apply velocity BCs after correction
    apply_velocity_bc(u, v, t)

    # Optional: print progress every 50 steps
    if (n+1) % 50 == 0 or n == nt-1:
        div_max = np.max(np.abs(divergence(u, v, dx, dy)))
        print(f"Step {n+1}/{nt}, t={t:.3f}, max divergence = {div_max:.3e}")

print("Time integration completed.")

# ---------------------------
# Plotting results at t=0.5
# ---------------------------

# Create figure for u velocity contour
plt.figure(figsize=(8,4))
cp = plt.contourf(X, Y, u, levels=50, cmap='jet')
plt.colorbar(cp)
plt.title('Velocity component u at t=0.5')
plt.xlabel('x')
plt.ylabel('y')
plt.tight_layout()
plt.savefig('velocity_u_t0.5.png')
plt.close()

# Create figure for v velocity contour
plt.figure(figsize=(8,4))
cp = plt.contourf(X, Y, v, levels=50, cmap='jet')
plt.colorbar(cp)
plt.title('Velocity component v at t=0.5')
plt.xlabel('x')
plt.ylabel('y')
plt.tight_layout()
plt.savefig('velocity_v_t0.5.png')
plt.close()

# Create figure for pressure contour
plt.figure(figsize=(8,4))
cp = plt.contourf(X, Y, p, levels=50, cmap='jet')
plt.colorbar(cp)
plt.title('Pressure p at t=0.5')
plt.xlabel('x')
plt.ylabel('y')
plt.tight_layout()
plt.savefig('pressure_p_t0.5.png')
plt.close()

print("Contour plots saved: 'velocity_u_t0.5.png', 'velocity_v_t0.5.png', 'pressure_p_t0.5.png'.")
```

****************************************
