
****************************************
```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt

# ---------------------------
# Technical explanation:
# This code solves the 2D unsteady incompressible Navier-Stokes equations using the Projection Method (Chorin's fractional step).
# The method decouples velocity and pressure by:
# 1) Computing an intermediate velocity field ignoring pressure.
# 2) Solving a Poisson equation for pressure correction to enforce incompressibility.
# 3) Correcting velocity with the pressure gradient.
#
# Spatial derivatives are approximated by second-order central finite differences on a uniform grid.
# Time integration uses explicit Euler for convective and forcing terms.
#
# The pressure Poisson equation is solved using GMRES with an ILU preconditioner to ensure convergence.
#
# Boundary conditions:
# - No-slip (u=v=0) on top and bottom walls.
# - Inlet velocity profile on left boundary.
# - Outlet: Neumann for velocity gradients, Dirichlet p=0 on right boundary.
#
# The forcing term acts only on v-momentum.
#
# Improvements incorporated based on feedback:
# - Added explicit residual norm monitoring for GMRES solver.
# - Tightened GMRES tolerance and increased max iterations.
# - Added divergence norm monitoring every 10 steps for better incompressibility check.
# - Verified and carefully applied velocity and pressure boundary conditions.
# - Modularized code into functions for clarity and maintainability.
# - Added comments explaining key steps and optimizations.
# ---------------------------

# Domain parameters
Lx, Ly = 2.0, 1.0
Nx, Ny = 81, 41  # grid points in x and y
dx, dy = Lx / (Nx - 1), Ly / (Ny - 1)
x = np.linspace(0, Lx, Nx)
y = np.linspace(0, Ly, Ny)

# Time parameters
Re = 100.0
dt = 0.002  # time step size (small for stability)
t_final = 0.5
nt = int(t_final / dt)

# Create meshgrid for forcing and BC evaluation
X, Y = np.meshgrid(x, y, indexing='ij')

# Initialize fields: u, v, p
u = np.zeros((Nx, Ny))
v = np.zeros((Nx, Ny))
p = np.zeros((Nx, Ny))

# Forcing term f = (0, fy)
def forcing(t):
    fy = -np.sin(np.pi * X) * np.sin(np.pi * Y) * np.sin(np.pi * t)
    return np.zeros_like(fy), fy

# Inlet velocity profile at x=0
def inlet_velocity(y_vals, t):
    return np.sin(np.pi * y_vals) * (np.sin(np.pi * t) + np.sin(3 * np.pi * t) + np.sin(5 * np.pi * t))

# Build Laplacian operator matrix for pressure Poisson equation with mixed BCs
def build_pressure_poisson_matrix(Nx, Ny, dx, dy):
    N = Nx * Ny
    A = sp.lil_matrix((N, N))

    dx2 = dx * dx
    dy2 = dy * dy
    main_diag_val = -2.0 / dx2 - 2.0 / dy2
    off_diag_x_val = 1.0 / dx2
    off_diag_y_val = 1.0 / dy2

    for i in range(Nx):
        for j in range(Ny):
            idx = i * Ny + j

            if i == Nx - 1:
                # Dirichlet BC for pressure at right boundary: p = 0
                A[idx, idx] = 1.0
            else:
                # Interior or other boundaries: Laplacian stencil with Neumann BCs
                A[idx, idx] = main_diag_val

                # Left neighbor
                if i > 0:
                    A[idx, idx - Ny] = off_diag_x_val
                else:
                    # Neumann BC at left boundary for pressure: dp/dx=0
                    # Implemented by modifying diagonal (ghost point approx)
                    A[idx, idx] += off_diag_x_val

                # Right neighbor
                if i < Nx - 1:
                    A[idx, idx + Ny] = off_diag_x_val

                # Bottom neighbor
                if j > 0:
                    A[idx, idx - 1] = off_diag_y_val
                else:
                    # Neumann BC at bottom boundary for pressure: dp/dy=0
                    A[idx, idx] += off_diag_y_val

                # Top neighbor
                if j < Ny - 1:
                    A[idx, idx + 1] = off_diag_y_val
                else:
                    # Neumann BC at top boundary for pressure: dp/dy=0
                    A[idx, idx] += off_diag_y_val

    return A.tocsr()

# Build pressure Poisson matrix once
A_p = build_pressure_poisson_matrix(Nx, Ny, dx, dy)

# Setup ILU preconditioner for GMRES to improve convergence
try:
    ilu = spla.spilu(A_p.tocsc(), drop_tol=1e-4, fill_factor=10)
    Mx = spla.LinearOperator(A_p.shape, ilu.solve)
    preconditioner_available = True
except RuntimeError:
    print("Warning: ILU preconditioner could not be constructed. GMRES may not converge efficiently.")
    preconditioner_available = False
    Mx = None

# Compute divergence of velocity field (central differences)
def divergence(u, v, dx, dy):
    dudx = (u[2:, 1:-1] - u[:-2, 1:-1]) / (2 * dx)
    dvdy = (v[1:-1, 2:] - v[1:-1, :-2]) / (2 * dy)
    div = dudx + dvdy
    return div

# Compute gradient of pressure field (central differences)
def gradient_p(p, dx, dy):
    dpdx = np.zeros_like(p)
    dpdy = np.zeros_like(p)
    dpdx[1:-1, 1:-1] = (p[2:, 1:-1] - p[:-2, 1:-1]) / (2 * dx)
    dpdy[1:-1, 1:-1] = (p[1:-1, 2:] - p[1:-1, :-2]) / (2 * dy)

    # Neumann BC for dp/dx at right boundary: zero gradient
    dpdx[-1, :] = dpdx[-2, :]
    # Neumann BC for dp/dy at top and bottom boundaries: zero gradient
    dpdy[:, 0] = dpdy[:, 1]
    dpdy[:, -1] = dpdy[:, -2]
    return dpdx, dpdy

# Compute Laplacian of scalar field (central differences)
def laplacian(phi, dx, dy):
    lap = np.zeros_like(phi)
    lap[1:-1, 1:-1] = (
        (phi[2:, 1:-1] - 2 * phi[1:-1, 1:-1] + phi[:-2, 1:-1]) / dx ** 2 +
        (phi[1:-1, 2:] - 2 * phi[1:-1, 1:-1] + phi[1:-1, :-2]) / dy ** 2
    )
    # Neumann BC: zero second derivative at boundaries (approximate)
    lap[0, :] = lap[1, :]
    lap[-1, :] = lap[-2, :]
    lap[:, 0] = lap[:, 1]
    lap[:, -1] = lap[:, -2]
    return lap

# Apply velocity boundary conditions at current time t
def apply_velocity_bc(u, v, t):
    # No-slip top and bottom walls (y=0 and y=Ly)
    u[:, 0] = 0.0
    v[:, 0] = 0.0
    u[:, -1] = 0.0
    v[:, -1] = 0.0

    # Inlet (x=0)
    u[0, :] = inlet_velocity(y, t)
    v[0, :] = 0.0

    # Outlet (x=Lx) Neumann for velocity gradients (zero gradient)
    u[-1, :] = u[-2, :]
    v[-1, :] = v[-2, :]

# Apply pressure boundary conditions
def apply_pressure_bc(p):
    # Dirichlet p=0 at right boundary (x=Lx)
    p[-1, :] = 0.0
    # Neumann elsewhere (approximate by copying adjacent values)
    p[0, :] = p[1, :]    # left boundary Neumann
    p[:, 0] = p[:, 1]    # bottom boundary Neumann
    p[:, -1] = p[:, -2]  # top boundary Neumann

# Flatten 2D array to 1D vector for linear solver
def flatten(arr):
    return arr.ravel(order='C')

# Reshape 1D vector to 2D array
def reshape(vec):
    return vec.reshape((Nx, Ny), order='C')

# Main time-stepping loop
print("Starting time integration...")

for n in range(nt):
    t = (n + 1) * dt

    # Compute forcing term at current time
    fx, fy = forcing(t)

    # Compute nonlinear convective terms using central differences (interior points)
    u_x = (u[2:, 1:-1] - u[:-2, 1:-1]) / (2 * dx)
    u_y = (u[1:-1, 2:] - u[1:-1, :-2]) / (2 * dy)
    v_x = (v[2:, 1:-1] - v[:-2, 1:-1]) / (2 * dx)
    v_y = (v[1:-1, 2:] - v[1:-1, :-2]) / (2 * dy)

    u_c = u[1:-1, 1:-1]
    v_c = v[1:-1, 1:-1]

    conv_u = u_c * u_x + v_c * u_y
    conv_v = u_c * v_x + v_c * v_y

    # Compute viscous terms (Laplacian)
    lap_u = laplacian(u, dx, dy)
    lap_v = laplacian(v, dx, dy)

    # Intermediate velocity u_star, v_star (explicit Euler step ignoring pressure gradient)
    u_star = np.copy(u)
    v_star = np.copy(v)

    u_star[1:-1, 1:-1] = u[1:-1, 1:-1] + dt * (
        -conv_u + (1 / Re) * lap_u[1:-1, 1:-1] + fx[1:-1, 1:-1]
    )
    v_star[1:-1, 1:-1] = v[1:-1, 1:-1] + dt * (
        -conv_v + (1 / Re) * lap_v[1:-1, 1:-1] + fy[1:-1, 1:-1]
    )

    # Apply velocity BCs to intermediate velocity
    apply_velocity_bc(u_star, v_star, t)

    # Compute RHS for pressure Poisson equation: divergence of u_star / dt
    div_u_star = np.zeros((Nx, Ny))
    div_u_star[1:-1, 1:-1] = (
        (u_star[2:, 1:-1] - u_star[:-2, 1:-1]) / (2 * dx) +
        (v_star[1:-1, 2:] - v_star[1:-1, :-2]) / (2 * dy)
    )
    rhs_p = flatten(div_u_star / dt)

    # Solve pressure Poisson equation A_p p = rhs_p using GMRES with ILU preconditioner
    p0 = flatten(p)

    gmres_iter = [0]
    gmres_residuals = []

    def gmres_callback(rk=None):
        gmres_iter[0] += 1
        if rk is not None:
            gmres_residuals.append(rk)

    # Use tighter tolerance and increased max iterations for better convergence
    gmres_kwargs = dict(
        x0=p0,
        atol=1e-10,
        restart=100,
        maxiter=1000,
        callback=gmres_callback,
        callback_type='legacy'
    )
    if preconditioner_available:
        gmres_kwargs['M'] = Mx

    p_vec, info = spla.gmres(A_p, rhs_p, **gmres_kwargs)

    if info == 0:
        print(f"Time step {n+1}/{nt}, t={t:.3f}: GMRES converged in {gmres_iter[0]} iterations.")
        if gmres_residuals:
            print(f"  Final GMRES residual norm: {gmres_residuals[-1]:.3e}")
    else:
        print(f"Time step {n+1}/{nt}, t={t:.3f}: GMRES did NOT converge after {gmres_iter[0]} iterations, info={info}.")

    p = reshape(p_vec)
    apply_pressure_bc(p)

    # Compute pressure gradient
    dpdx, dpdy = gradient_p(p, dx, dy)

    # Correct velocity to enforce incompressibility
    u[1:-1, 1:-1] = u_star[1:-1, 1:-1] - dt * dpdx[1:-1, 1:-1]
    v[1:-1, 1:-1] = v_star[1:-1, 1:-1] - dt * dpdy[1:-1, 1:-1]

    # Re-apply velocity BCs after correction
    apply_velocity_bc(u, v, t)

    # Monitor divergence norm every 10 steps and at last step
    if (n + 1) % 10 == 0 or n == nt - 1:
        div = divergence(u, v, dx, dy)
        div_norm = np.linalg.norm(div.ravel(), ord=2) / div.size
        div_max = np.max(np.abs(div))
        print(f"Step {n+1}/{nt}, t={t:.3f}, max divergence = {div_max:.3e}, L2 norm divergence = {div_norm:.3e}")

print("Time integration completed.")

# ---------------------------
# Plotting results at t=0.5
# ---------------------------

# Velocity component u contour
plt.figure(figsize=(8, 4))
cp = plt.contourf(X, Y, u, levels=50, cmap='jet')
plt.colorbar(cp)
plt.title('Velocity component u at t=0.5')
plt.xlabel('x')
plt.ylabel('y')
plt.tight_layout()
plt.savefig('velocity_u_t0.5.png')
plt.close()

# Velocity component v contour
plt.figure(figsize=(8, 4))
cp = plt.contourf(X, Y, v, levels=50, cmap='jet')
plt.colorbar(cp)
plt.title('Velocity component v at t=0.5')
plt.xlabel('x')
plt.ylabel('y')
plt.tight_layout()
plt.savefig('velocity_v_t0.5.png')
plt.close()

# Pressure contour
plt.figure(figsize=(8, 4))
cp = plt.contourf(X, Y, p, levels=50, cmap='jet')
plt.colorbar(cp)
plt.title('Pressure p at t=0.5')
plt.xlabel('x')
plt.ylabel('y')
plt.tight_layout()
plt.savefig('pressure_p_t0.5.png')
plt.close()

print("Contour plots saved: 'velocity_u_t0.5.png', 'velocity_v_t0.5.png', 'pressure_p_t0.5.png'.")
```

****************************************
