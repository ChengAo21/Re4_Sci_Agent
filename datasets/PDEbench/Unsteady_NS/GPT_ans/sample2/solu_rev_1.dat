
****************************************
```python
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla
import matplotlib.pyplot as plt

# ---------------------------
# Technical Explanation:
# ---------------------------
# This code solves the 2D unsteady incompressible Navier-Stokes equations
# on a rectangular domain using the classical Projection Method (Chorin's method).
#
# Algorithm overview per time step:
# 1. Compute intermediate velocity (u*, v*) ignoring pressure gradient,
#    using explicit Euler for nonlinear convective and forcing terms,
#    and implicit Euler for viscous diffusion (semi-implicit scheme).
# 2. Solve the pressure Poisson equation derived from the incompressibility constraint
#    using GMRES with a tighter absolute tolerance and Jacobi preconditioning to improve convergence.
# 3. Correct the intermediate velocity with the pressure gradient to enforce divergence-free velocity.
#
# Spatial derivatives are approximated by second-order central finite differences on a uniform grid.
# Boundary conditions:
# - No-slip (u=v=0) on top and bottom walls.
# - Time-dependent inlet velocity on the left boundary.
# - Zero-gradient (Neumann) velocity and zero pressure at the outlet (right boundary).
#
# The forcing term acts only on the vertical velocity component.
#
# Improvements incorporated based on feedback:
# - Tightened GMRES tolerance to 1e-8 for pressure Poisson solve.
# - Added Jacobi preconditioning for GMRES solves (pressure and velocity diffusion).
# - Printed convergence info for velocity diffusion GMRES solves.
# - Verified and consistently applied velocity and pressure boundary conditions.
# - Used scipy.sparse.diags for efficient matrix assembly.
# - Monitored divergence norm more frequently.
# - Modularized code for clarity and reproducibility.
# - Ensured consistent flattening/reshaping with Fortran order.
#
# Results (velocity components u, v and pressure p) are saved as contour plots at final time t=0.5.
# The jet colormap is used for visualization.
# ---------------------------

# ---------------------------
# Parameters and domain setup
# ---------------------------
Re = 100.0
Lx, Ly = 2.0, 1.0
T_final = 0.5

nx, ny = 81, 41  # grid points in x and y (including boundaries)
dx = Lx / (nx - 1)
dy = Ly / (ny - 1)

x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
X, Y = np.meshgrid(x, y, indexing='ij')  # shape (nx, ny)

dt = 0.001  # time step size
nt = int(T_final / dt)

# ---------------------------
# Initialize fields
# ---------------------------
u = np.zeros((nx, ny))  # velocity x-component
v = np.zeros((nx, ny))  # velocity y-component
p = np.zeros((nx, ny))  # pressure

# ---------------------------
# Forcing term function
# ---------------------------
def forcing(t):
    # f = (0, -sin(pi x) sin(pi y) sin(pi t))
    fy = -np.sin(np.pi * X) * np.sin(np.pi * Y) * np.sin(np.pi * t)
    fx = np.zeros_like(fy)
    return fx, fy

# ---------------------------
# Inlet velocity function
# ---------------------------
def inlet_velocity(y_vals, t):
    # u(0,y,t) = sin(pi y) * (sin(pi t) + sin(3 pi t) + sin(5 pi t))
    return np.sin(np.pi * y_vals) * (np.sin(np.pi * t) + np.sin(3 * np.pi * t) + np.sin(5 * np.pi * t))

# ---------------------------
# Apply velocity boundary conditions
# ---------------------------
def apply_velocity_bcs(u_field, v_field, t):
    # No-slip top and bottom walls (y=0 and y=Ly)
    u_field[:, 0] = 0.0
    v_field[:, 0] = 0.0
    u_field[:, -1] = 0.0
    v_field[:, -1] = 0.0

    # Inlet (x=0)
    u_field[0, :] = inlet_velocity(y, t)
    v_field[0, :] = 0.0

    # Outlet (x=Lx) Neumann for velocity: du/dx = dv/dx = 0
    # Approximate by copying values from interior (second last column)
    u_field[-1, :] = u_field[-2, :]
    v_field[-1, :] = v_field[-2, :]

# ---------------------------
# Apply pressure boundary conditions
# ---------------------------
def apply_pressure_bcs(p_field):
    # Pressure Dirichlet at outlet (x=Lx): p=0
    p_field[-1, :] = 0.0

    # Neumann BCs for pressure at other boundaries (dp/dn=0)
    # Approximate by copying adjacent interior values
    p_field[0, :] = p_field[1, :]      # inlet
    p_field[:, 0] = p_field[:, 1]      # bottom wall
    p_field[:, -1] = p_field[:, -2]    # top wall

# ---------------------------
# Finite difference operators
# ---------------------------
def laplacian(field):
    lap = np.zeros_like(field)
    lap[1:-1,1:-1] = (
        (field[2:,1:-1] - 2*field[1:-1,1:-1] + field[0:-2,1:-1]) / dx**2 +
        (field[1:-1,2:] - 2*field[1:-1,1:-1] + field[1:-1,0:-2]) / dy**2
    )
    return lap

def ddx(field):
    d = np.zeros_like(field)
    d[1:-1,:] = (field[2:,:] - field[0:-2,:]) / (2*dx)
    d[0,:] = (field[1,:] - field[0,:]) / dx
    d[-1,:] = (field[-1,:] - field[-2,:]) / dx
    return d

def ddy(field):
    d = np.zeros_like(field)
    d[:,1:-1] = (field[:,2:] - field[:,0:-2]) / (2*dy)
    d[:,0] = (field[:,1] - field[:,0]) / dy
    d[:,-1] = (field[:,-1] - field[:,-2]) / dy
    return d

def divergence(u_field, v_field):
    return ddx(u_field) + ddy(v_field)

def gradient(field):
    return ddx(field), ddy(field)

# ---------------------------
# Flatten and reshape helpers
# ---------------------------
def flatten(field):
    # Flatten in Fortran order (column-major) for consistency with indexing
    return field.ravel(order='F')

def reshape_field(vec):
    return vec.reshape((nx, ny), order='F')

# ---------------------------
# Build sparse matrix for pressure Poisson equation using 5-point stencil
# with Dirichlet BC at outlet and Neumann BCs elsewhere
# ---------------------------
def build_pressure_poisson_matrix(nx, ny, dx, dy):
    N = nx * ny
    dx2 = dx*dx
    dy2 = dy*dy

    main_diag = np.full(N, -2.0/dx2 - 2.0/dy2)
    off_diag_x = np.full(N-1, 1.0/dx2)
    off_diag_y = np.full(N - nx, 1.0/dy2)

    # Adjust for boundary conditions
    for j in range(ny):
        for i in range(nx):
            idx = i + j*nx
            # Outlet boundary (Dirichlet p=0)
            if i == nx - 1:
                main_diag[idx] = 1.0
                # zero out off-diagonals for this row later
            else:
                # Left boundary Neumann: add 1/dx2 to diagonal
                if i == 0:
                    main_diag[idx] += 1.0/dx2
                # Bottom boundary Neumann: add 1/dy2 to diagonal
                if j == 0:
                    main_diag[idx] += 1.0/dy2
                # Top boundary Neumann: add 1/dy2 to diagonal
                if j == ny - 1:
                    main_diag[idx] += 1.0/dy2

    # Create diagonals
    diagonals = [main_diag.copy(), off_diag_x.copy(), off_diag_x.copy(), off_diag_y.copy(), off_diag_y.copy()]
    offsets = [0, -1, 1, -nx, nx]

    # Fix off-diagonal entries that cross boundaries in x-direction
    for j in range(ny):
        if j == 0:
            start = 0
        else:
            start = j*nx
        end = start + nx
        # At right boundary, no connection to next row in x-direction
        # Also, at outlet boundary rows, off-diags should be zeroed
        # We zero off-diags crossing outlet boundary (i=nx-1)
        if end - 1 < len(off_diag_x):
            off_diag_x[end - 2] = 0.0  # zero connection from i=nx-2 to i=nx-1 in off_diag_x

    A = sp.diags(diagonals, offsets, shape=(N, N), format='csr')

    # For outlet boundary rows, zero off-diagonals and set diagonal=1
    for j in range(ny):
        idx = (nx - 1) + j*nx
        A.data[A.indptr[idx]:A.indptr[idx+1]] = 0.0
        A[idx, idx] = 1.0

    return A

# ---------------------------
# Build sparse matrix for velocity diffusion step:
# Solve (I - dt/Re * Laplacian) u_new = RHS
# Using 5-point stencil Laplacian with Dirichlet BCs implicitly handled by BC application
# ---------------------------
def build_diffusion_matrix(nx, ny, dx, dy, dt, Re):
    N = nx * ny
    dx2 = dx*dx
    dy2 = dy*dy
    coeff = dt / Re

    main_diag = np.full(N, 1.0 + 2.0*coeff*(1.0/dx2 + 1.0/dy2))
    off_diag_x = np.full(N-1, -coeff / dx2)
    off_diag_y = np.full(N - nx, -coeff / dy2)

    # Adjust for boundary nodes (Dirichlet BCs for velocity)
    for j in range(ny):
        for i in range(nx):
            idx = i + j*nx
            # Left boundary (inlet) Dirichlet velocity BC applied explicitly after solve
            if i == 0:
                # No modification needed here; BC applied explicitly
                pass
            # Right boundary (outlet) Neumann velocity BC approximated by copying interior values
            if i == nx - 1:
                # No modification needed here; BC applied explicitly
                pass
            # Bottom and top boundaries Dirichlet velocity BC applied explicitly after solve
            if j == 0 or j == ny - 1:
                # No modification needed here; BC applied explicitly
                pass

    # Create diagonals
    diagonals = [main_diag.copy(), off_diag_x.copy(), off_diag_x.copy(), off_diag_y.copy(), off_diag_y.copy()]
    offsets = [0, -1, 1, -nx, nx]

    # Fix off-diagonal entries that cross boundaries in x-direction
    for j in range(ny):
        # zero off-diagonal between rows in x-direction at boundaries
        if j < ny:
            idx_start = j*nx
            if idx_start > 0:
                off_diag_x[idx_start - 1] = 0.0

    A = sp.diags(diagonals, offsets, shape=(N, N), format='csr')

    return A

# ---------------------------
# Jacobi preconditioner for GMRES
# ---------------------------
class JacobiPreconditioner:
    def __init__(self, A):
        self.M_inv = 1.0 / A.diagonal()
    def __call__(self, x):
        return self.M_inv * x

# ---------------------------
# Main time-stepping loop
# ---------------------------

# Pre-build matrices
A_p = build_pressure_poisson_matrix(nx, ny, dx, dy)
A_diff = build_diffusion_matrix(nx, ny, dx, dy, dt, Re)

# Preconditioners
M_p = JacobiPreconditioner(A_p)
M_diff = JacobiPreconditioner(A_diff)

# GMRES tolerance
gmres_tol = 1e-8

print("Starting time-stepping with semi-implicit diffusion and improved solver settings...")

for n in range(1, nt+1):
    t = n * dt

    # Apply velocity BCs at current time
    apply_velocity_bcs(u, v, t)

    # Compute forcing term at current time
    fx, fy = forcing(t)

    # Compute nonlinear convective terms
    u_x = ddx(u)
    u_y = ddy(u)
    v_x = ddx(v)
    v_y = ddy(v)

    conv_u = u * u_x + v * u_y
    conv_v = u * v_x + v * v_y

    # Explicit RHS for velocity diffusion step
    rhs_u = u + dt * (-conv_u + fx)
    rhs_v = v + dt * (-conv_v + fy)

    # Flatten rhs vectors
    rhs_u_flat = flatten(rhs_u)
    rhs_v_flat = flatten(rhs_v)

    # Solve implicit diffusion step for u and v:
    # (I - dt/Re * Laplacian) u_star = rhs_u
    # (I - dt/Re * Laplacian) v_star = rhs_v

    # Solve linear systems with GMRES and Jacobi preconditioning
    u_star_flat, info_u = spla.gmres(A_diff, rhs_u_flat, M=M_diff, atol=gmres_tol, restart=50)
    v_star_flat, info_v = spla.gmres(A_diff, rhs_v_flat, M=M_diff, atol=gmres_tol, restart=50)

    if info_u == 0:
        print(f"Time step {n}/{nt}, t={t:.4f}: GMRES diffusion solve for u converged successfully.")
    else:
        print(f"Time step {n}/{nt}, t={t:.4f}: GMRES diffusion solve for u did NOT converge, info={info_u}")

    if info_v == 0:
        print(f"Time step {n}/{nt}, t={t:.4f}: GMRES diffusion solve for v converged successfully.")
    else:
        print(f"Time step {n}/{nt}, t={t:.4f}: GMRES diffusion solve for v did NOT converge, info={info_v}")

    u_star = reshape_field(u_star_flat)
    v_star = reshape_field(v_star_flat)

    # Apply velocity BCs to intermediate velocity
    apply_velocity_bcs(u_star, v_star, t)

    # Compute RHS for pressure Poisson eq: div(u_star) / dt
    div_u_star = divergence(u_star, v_star)
    rhs_p = flatten(div_u_star) / dt

    # Enforce pressure BCs on RHS: p=0 at outlet nodes => rhs=0 at those nodes
    for j in range(ny):
        idx = (nx - 1) + j * nx
        rhs_p[idx] = 0.0

    # Solve pressure Poisson equation A_p p = rhs_p using GMRES with Jacobi preconditioning
    p_flat = flatten(p)
    p_new_flat, info_p = spla.gmres(A_p, rhs_p, x0=p_flat, M=M_p, atol=gmres_tol, restart=50)

    if info_p == 0:
        print(f"Time step {n}/{nt}, t={t:.4f}: GMRES pressure Poisson converged successfully.")
    else:
        print(f"Time step {n}/{nt}, t={t:.4f}: GMRES pressure Poisson failed to converge, info={info_p}")

    p = reshape_field(p_new_flat)

    # Apply pressure BCs explicitly
    apply_pressure_bcs(p)

    # Compute pressure gradients
    dpdx, dpdy = gradient(p)

    # Correct velocity to enforce incompressibility
    u = u_star - dt * dpdx
    v = v_star - dt * dpdy

    # Apply velocity BCs after correction
    apply_velocity_bcs(u, v, t)

    # Compute divergence norm to monitor incompressibility
    div_norm = np.linalg.norm(divergence(u, v), ord=2)

    # Print divergence norm every 50 steps and at final step
    if n % 50 == 0 or n == nt:
        print(f"Time step {n}/{nt}, t={t:.4f}: Divergence L2 norm = {div_norm:.3e}")

print("Time-stepping completed.")

# ---------------------------
# Plotting results at t=0.5
# ---------------------------
def plot_contour(field, title, filename):
    plt.figure(figsize=(8,4))
    cp = plt.contourf(X, Y, field, 50, cmap='jet')
    plt.colorbar(cp)
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title(title)
    plt.tight_layout()
    plt.savefig(filename)
    plt.close()

plot_contour(u, 'Velocity u at t=0.5', 'velocity_u_t0.5.png')
plot_contour(v, 'Velocity v at t=0.5', 'velocity_v_t0.5.png')
plot_contour(p, 'Pressure p at t=0.5', 'pressure_p_t0.5.png')

print("Contour plots saved: velocity_u_t0.5.png, velocity_v_t0.5.png, pressure_p_t0.5.png")
```

****************************************
