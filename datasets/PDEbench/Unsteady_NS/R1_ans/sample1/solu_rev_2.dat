
****************************************
Based on the teacher's feedback, I've implemented significant improvements focusing on accurate Neumann boundary handling for the Poisson equation, consistent divergence calculations, and enhanced diagnostics. Key optimizations include:

1. **Poisson Matrix Reconstruction**: Implemented ghost-point-free second-order Neumann BCs using modified Laplacian stencils
2. **Divergence Calculations**: Used second-order one-sided differences at boundaries
3. **Pressure Gradient Correction**: Consistent boundary treatment for pressure gradients
4. **Enhanced Diagnostics**: Added L2 divergence norms and GMRES convergence monitoring
5. **Stability Improvements**: Maintained CFL-based time stepping with explicit Euler

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import lil_matrix, csr_matrix, diags
from scipy.sparse.linalg import gmres, LinearOperator, spilu

# ==============================================================================
# PARAMETERS AND GRID SETUP
# ==============================================================================
Re = 100.0                # Reynolds number
Lx, Ly = 2.0, 1.0         # Domain dimensions
T_total = 0.5             # Total simulation time
nx, ny = 100, 50          # Grid resolution (optimized for accuracy/stability balance)
dx = Lx / (nx - 1)        # Spatial step in x
dy = Ly / (ny - 1)        # Spatial step in y
cfl = 0.5                 # CFL safety factor
dt = cfl * min(dx, dy)    # Dynamic time step based on CFL condition
nt = int(T_total / dt) + 1 # Number of time steps

# Create computational grid (column-major ordering for matrix operations)
x = np.linspace(0, Lx, nx)
y = np.linspace(0, Ly, ny)
X, Y = np.meshgrid(x, y, indexing='xy')

# Initialize flow fields
u = np.zeros((ny, nx))
v = np.zeros((ny, nx))
p = np.zeros((ny, nx))

# ==============================================================================
# POISSON MATRIX CONSTRUCTION (IMPROVED NEUMANN BCs)
# ==============================================================================
n_total = nx * ny
A = lil_matrix((n_total, n_total))

# Precompute coefficients
cx = 1.0 / dx**2
cy = 1.0 / dy**2

for i in range(ny):
    for j in range(nx):
        idx = i * nx + j
        
        # Right boundary: Dirichlet (p=0)
        if j == nx - 1:
            A[idx, idx] = 1.0
        
        # Top-left corner (i=0, j=0): Neumann in both directions
        elif i == 0 and j == 0:
            A[idx, idx] = -2*cx - 2*cy
            A[idx, idx+1] = 2*cx         # Right neighbor
            A[idx, idx+nx] = 2*cy         # Below neighbor
        
        # Bottom-left corner (i=ny-1, j=0): Neumann in both directions
        elif i == ny-1 and j == 0:
            A[idx, idx] = -2*cx - 2*cy
            A[idx, idx+1] = 2*cx          # Right neighbor
            A[idx, idx-nx] = 2*cy          # Above neighbor
        
        # Left boundary (j=0, not corner): Neumann in x
        elif j == 0:
            A[idx, idx] = -2*cx - 2*cy
            A[idx, idx+1] = 2*cx           # Right neighbor
            # Vertical neighbors (standard stencil)
            if i > 0 and i < ny-1:
                A[idx, idx-nx] = cy        # Above
                A[idx, idx+nx] = cy        # Below
        
        # Top boundary (i=0, not corner): Neumann in y
        elif i == 0:
            A[idx, idx] = -2*cx - 2*cy
            A[idx, idx+nx] = 2*cy          # Below neighbor
            # Horizontal neighbors (standard stencil)
            if j > 0 and j < nx-1:
                A[idx, idx-1] = cx         # Left
                A[idx, idx+1] = cx         # Right
        
        # Bottom boundary (i=ny-1, not corner): Neumann in y
        elif i == ny-1:
            A[idx, idx] = -2*cx - 2*cy
            A[idx, idx-nx] = 2*cy          # Above neighbor
            # Horizontal neighbors
            if j > 0 and j < nx-1:
                A[idx, idx-1] = cx         # Left
                A[idx, idx+1] = cx         # Right
        
        # Interior points: Standard 5-point stencil
        else:
            A[idx, idx] = -2*(cx + cy)
            A[idx, idx-1] = cx             # Left
            A[idx, idx+1] = cx             # Right
            A[idx, idx-nx] = cy            # Above
            A[idx, idx+nx] = cy            # Below

# Convert to efficient CSR format
A = A.tocsr()

# ==============================================================================
# PRECONDITIONER SETUP FOR GMRES
# ==============================================================================
# Incomplete LU decomposition for preconditioning
M_inv = spilu(A.tocsc(), drop_tol=1e-5, fill_factor=30)
def preconditioner(b):
    return M_inv.solve(b)

M = LinearOperator((n_total, n_total), preconditioner)

# ==============================================================================
# TIME STEPPING LOOP (PROJECTION METHOD)
# ==============================================================================
for n in range(nt):
    t = n * dt
    
    # Forcing term (vertical direction only)
    f_y = -np.sin(np.pi * X) * np.sin(np.pi * Y) * np.sin(np.pi * t)
    
    # ======================================================================
    # DERIVATIVE CALCULATIONS (SECOND-ORDER ACCURATE)
    # ======================================================================
    # Initialize derivatives
    dudx = np.zeros_like(u)
    dudy = np.zeros_like(u)
    dvdx = np.zeros_like(v)
    dvdy = np.zeros_like(v)
    
    # Interior points: Central differences
    dudx[:, 1:-1] = (u[:, 2:] - u[:, :-2]) / (2*dx)
    dudy[1:-1, :] = (u[2:, :] - u[:-2, :]) / (2*dy)
    dvdx[:, 1:-1] = (v[:, 2:] - v[:, :-2]) / (2*dx)
    dvdy[1:-1, :] = (v[2:, :] - v[:-2, :]) / (2*dy)
    
    # Boundaries: Second-order one-sided differences
    # Left boundary (j=0)
    dudx[:, 0] = (-3*u[:, 0] + 4*u[:, 1] - u[:, 2]) / (2*dx)
    dvdx[:, 0] = (-3*v[:, 0] + 4*v[:, 1] - v[:, 2]) / (2*dx)
    # Right boundary (j=nx-1)
    dudx[:, -1] = (3*u[:, -1] - 4*u[:, -2] + u[:, -3]) / (2*dx)
    dvdx[:, -1] = (3*v[:, -1] - 4*v[:, -2] + v[:, -3]) / (2*dx)
    # Top boundary (i=0)
    dudy[0, :] = (-3*u[0, :] + 4*u[1, :] - u[2, :]) / (2*dy)
    dvdy[0, :] = (-3*v[0, :] + 4*v[1, :] - v[2, :]) / (2*dy)
    # Bottom boundary (i=ny-1)
    dudy[-1, :] = (3*u[-1, :] - 4*u[-2, :] + u[-3, :]) / (2*dy)
    dvdy[-1, :] = (3*v[-1, :] - 4*v[-2, :] + v[-3, :]) / (2*dy)
    
    # ======================================================================
    # VISCOUS TERMS (LAPLACIAN)
    # ======================================================================
    laplacian_u = np.zeros_like(u)
    laplacian_v = np.zeros_like(v)
    
    # Interior points
    laplacian_u[:, 1:-1] = (u[:, 2:] - 2*u[:, 1:-1] + u[:, :-2]) / dx**2
    laplacian_v[:, 1:-1] = (v[:, 2:] - 2*v[:, 1:-1] + v[:, :-2]) / dx**2
    
    laplacian_u[1:-1, :] += (u[2:, :] - 2*u[1:-1, :] + u[:-2, :]) / dy**2
    laplacian_v[1:-1, :] += (v[2:, :] - 2*v[1:-1, :] + v[:-2, :]) / dy**2
    
    # Boundary treatments
    # Left boundary (j=0)
    laplacian_u[:, 0] = (2*u[:, 1] - 2*u[:, 0]) / dx**2
    laplacian_v[:, 0] = (2*v[:, 1] - 2*v[:, 0]) / dx**2
    # Right boundary (j=nx-1) - Neumann already satisfied by gradient condition
    # Top boundary (i=0)
    laplacian_u[0, :] += (2*u[1, :] - 2*u[0, :]) / dy**2
    laplacian_v[0, :] += (2*v[1, :] - 2*v[0, :]) / dy**2
    # Bottom boundary (i=ny-1)
    laplacian_u[-1, :] += (2*u[-2, :] - 2*u[-1, :]) / dy**2
    laplacian_v[-1, :] += (2*v[-2, :] - 2*v[-1, :]) / dy**2
    
    # ======================================================================
    # INTERMEDIATE VELOCITY CALCULATION
    # ======================================================================
    u_star = u + dt * (-u*dudx - v*dudy + (1/Re)*laplacian_u)
    v_star = v + dt * (-u*dvdx - v*dvdy + (1/Re)*laplacian_v + f_y)
    
    # ======================================================================
    # BOUNDARY CONDITIONS FOR INTERMEDIATE VELOCITIES
    # ======================================================================
    # Inlet condition (left boundary)
    inlet_profile = np.sin(np.pi * y) * (np.sin(np.pi*t) + np.sin(3*np.pi*t) + np.sin(5*np.pi*t))
    u_star[:, 0] = inlet_profile
    v_star[:, 0] = 0.0
    
    # No-slip walls (top and bottom)
    u_star[0, :] = 0.0
    u_star[-1, :] = 0.0
    v_star[0, :] = 0.0
    v_star[-1, :] = 0.0
    
    # Outflow condition (right boundary)
    u_star[:, -1] = u_star[:, -2]
    v_star[:, -1] = v_star[:, -2]
    
    # ======================================================================
    # DIVERGENCE OF INTERMEDIATE VELOCITY (SECOND-ORDER ACCURATE)
    # ======================================================================
    div_u = np.zeros_like(u_star)
    # Interior points
    div_u[:, 1:-1] = (u_star[:, 2:] - u_star[:, :-2]) / (2*dx)
    div_u[1:-1, :] += (v_star[2:, :] - v_star[:-2, :]) / (2*dy)
    
    # Boundaries: Second-order one-sided differences
    # Left boundary (j=0)
    div_u[:, 0] = (-3*u_star[:, 0] + 4*u_star[:, 1] - u_star[:, 2]) / (2*dx)
    # Right boundary (j=nx-1)
    div_u[:, -1] = (3*u_star[:, -1] - 4*u_star[:, -2] + u_star[:, -3]) / (2*dx)
    # Top boundary (i=0)
    div_u[0, :] += (-3*v_star[0, :] + 4*v_star[1, :] - v_star[2, :]) / (2*dy)
    # Bottom boundary (i=ny-1)
    div_u[-1, :] += (3*v_star[-1, :] - 4*v_star[-2, :] + v_star[-3, :]) / (2*dy)
    
    # RHS for Poisson equation
    rhs = div_u.ravel() / dt
    
    # Apply Dirichlet BC at outlet (right boundary)
    for i in range(ny):
        idx = i * nx + (nx - 1)
        rhs[idx] = 0.0  # p=0 at outlet
    
    # ======================================================================
    # PRESSURE SOLVE WITH GMRES
    # ======================================================================
    p_flat, info = gmres(A, rhs, M=M, atol=1e-8, maxiter=2000)
    if info > 0:
        print(f"GMRES warning: Convergence not achieved at step {n}, info={info}")
    elif info < 0:
        print(f"GMRES error: Illegal input at step {n}, info={info}")
    else:
        resid = np.linalg.norm(A.dot(p_flat) - rhs) / np.linalg.norm(rhs)
        print(f"Poisson solve: Step {n}, |res|/|rhs| = {resid:.3e}")
    
    p = p_flat.reshape(ny, nx)
    
    # ======================================================================
    # PRESSURE GRADIENT CALCULATION (SECOND-ORDER ACCURATE)
    # ======================================================================
    p_x = np.zeros_like(p)
    p_y = np.zeros_like(p)
    
    # Interior points
    p_x[:, 1:-1] = (p[:, 2:] - p[:, :-2]) / (2*dx)
    p_y[1:-1, :] = (p[2:, :] - p[:-2, :]) / (2*dy)
    
    # Boundaries: Second-order one-sided differences
    # Left boundary (j=0)
    p_x[:, 0] = (-3*p[:, 0] + 4*p[:, 1] - p[:, 2]) / (2*dx)
    # Right boundary (j=nx-1)
    p_x[:, -1] = (3*p[:, -1] - 4*p[:, -2] + p[:, -3]) / (2*dx)
    # Top boundary (i=0)
    p_y[0, :] = (-3*p[0, :] + 4*p[1, :] - p[2, :]) / (2*dy)
    # Bottom boundary (i=ny-1)
    p_y[-1, :] = (3*p[-1, :] - 4*p[-2, :] + p[-3, :]) / (2*dy)
    
    # ======================================================================
    # VELOCITY CORRECTION
    # ======================================================================
    u = u_star - dt * p_x
    v = v_star - dt * p_y
    
    # ======================================================================
    # BOUNDARY CONDITIONS ENFORCEMENT
    # ======================================================================
    u[:, 0] = inlet_profile  # Inlet
    v[:, 0] = 0.0
    u[0, :] = 0.0; u[-1, :] = 0.0  # Walls
    v[0, :] = 0.0; v[-1, :] = 0.0
    u[:, -1] = u[:, -2]; v[:, -1] = v[:, -2]  # Outlet
    
    # ======================================================================
    # DIVERGENCE DIAGNOSTICS
    # ======================================================================
    div_final = np.zeros_like(u)
    # Interior points
    div_final[:, 1:-1] = (u[:, 2:] - u[:, :-2]) / (2*dx)
    div_final[1:-1, :] += (v[2:, :] - v[:-2, :]) / (2*dy)
    
    # Boundaries: Second-order one-sided differences
    div_final[:, 0] = (-3*u[:, 0] + 4*u[:, 1] - u[:, 2]) / (2*dx)
    div_final[:, -1] = (3*u[:, -1] - 4*u[:, -2] + u[:, -3]) / (2*dx)
    div_final[0, :] += (-3*v[0, :] + 4*v[1, :] - v[2, :]) / (2*dy)
    div_final[-1, :] += (3*v[-1, :] - 4*v[-2, :] + v[-3, :]) / (2*dy)
    
    max_div = np.max(np.abs(div_final))
    l2_div = np.linalg.norm(div_final) * np.sqrt(dx*dy)
    max_vel = np.max(np.sqrt(u**2 + v**2))
    
    print(f"Step {n+1}/{nt}: t={t:.4f}, dt={dt:.6f}, "
          f"Max vel={max_vel:.6f}, Max div={max_div:.3e}, L2 div={l2_div:.3e}")

# ==============================================================================
# VISUALIZATION
# ==============================================================================
plt.figure(figsize=(18, 6))

# Velocity u contour
plt.subplot(131)
contour_u = plt.contourf(X, Y, u, levels=50, cmap='jet')
plt.colorbar(contour_u, label='$u$ velocity')
plt.title('Velocity $u$ at $t=0.5$')
plt.xlabel('$x$')
plt.ylabel('$y$')
plt.axis('equal')

# Velocity v contour
plt.subplot(132)
contour_v = plt.contourf(X, Y, v, levels=50, cmap='jet')
plt.colorbar(contour_v, label='$v$ velocity')
plt.title('Velocity $v$ at $t=0.5$')
plt.xlabel('$x$')
plt.ylabel('$y$')
plt.axis('equal')

# Pressure contour
plt.subplot(133)
contour_p = plt.contourf(X, Y, p, levels=50, cmap='jet')
plt.colorbar(contour_p, label='Pressure')
plt.title('Pressure $p$ at $t=0.5$')
plt.xlabel('$x$')
plt.ylabel('$y$')
plt.axis('equal')

plt.tight_layout()
plt.savefig('ns_results_refined.png')
```

**Key Improvements:**

1. **Neumann BC Implementation**:
   - Reconstructed Poisson matrix using ghost-point-free method
   - Implemented second-order accurate stencils for all boundaries
   - Properly handled corner points with combined Neumann conditions

2. **Divergence Control**:
   - Used second-order one-sided differences for divergence calculations
   - Added L2 norm diagnostics for incompressibility enforcement
   - Improved pressure gradient calculations at boundaries

3. **Solver Diagnostics**:
   - Added residual monitoring for GMRES iterations
   - Enhanced printing of divergence metrics (both max and L2 norms)
   - Maintained CFL-based time stepping for stability

4. **Visualization Enhancements**:
   - Added equal axis scaling for proper aspect ratio
   - Included colorbar labels for clarity
   - Maintained jet colormap as requested

This implementation maintains the projection method's core while significantly improving numerical accuracy, particularly for boundary treatments and divergence control. The diagnostics provide comprehensive information for solution verification.
****************************************
