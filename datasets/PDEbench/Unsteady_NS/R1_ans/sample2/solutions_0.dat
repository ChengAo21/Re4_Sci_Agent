
****************************************
To solve the 2D unsteady incompressible Navier-Stokes equations with the given boundary conditions and forcing term, we implement the Projection Method (Chorin's method). This approach decouples velocity and pressure computations, making it efficient for moderate Reynolds number flows (Re=100). The algorithm involves:
1. Computing intermediate velocities without pressure gradient
2. Solving a pressure Poisson equation using GMRES
3. Correcting velocities with pressure gradient
4. Applying boundary conditions at each step

Key technical aspects:
- Spatial derivatives: 2nd-order central differences (1st-order at boundaries)
- Time integration: Explicit Euler
- Pressure solver: GMRES with mixed Neumann/Dirichlet BCs
- Boundary handling:
  - Inlet: Time-dependent velocity profile
  - Outlet: Zero-gradient velocity, fixed pressure
  - Walls: No-slip condition

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import lil_matrix, csr_matrix
from scipy.sparse.linalg import gmres
import time

# ==============================================================================
# Parameters and Grid Setup
# ==============================================================================
Re = 100.0       # Reynolds number
Lx, Ly = 2.0, 1.0  # Domain dimensions
T = 0.5           # Simulation time
Nx, Ny = 101, 51  # Grid resolution
dx = Lx/(Nx-1)    # Spatial step in x
dy = Ly/(Ny-1)    # Spatial step in y
dt = 0.001        # Time step (stable per CFL/viscous constraints)
num_steps = int(T/dt)  # Total time steps
x = np.linspace(0, Lx, Nx)  # X-grid points
y = np.linspace(0, Ly, Ny)  # Y-grid points
X, Y = np.meshgrid(x, y, indexing='ij')  # Grid matrices

# ==============================================================================
# Initial Conditions
# ==============================================================================
u = np.zeros((Nx, Ny))  # X-velocity
v = np.zeros((Nx, Ny))  # Y-velocity
p = np.zeros((Nx, Ny))  # Pressure

# ==============================================================================
# Helper Functions
# ==============================================================================
def forcing_term(x, y, t):
    """Vertical forcing term f_y(x,y,t)"""
    return -np.sin(np.pi*x) * np.sin(np.pi*y) * np.sin(np.pi*t)

def u_inlet(y, t):
    """Inlet velocity profile at x=0"""
    return np.sin(np.pi*y) * (np.sin(np.pi*t) + np.sin(3*np.pi*t) + np.sin(5*np.pi*t))

def compute_derivative(f, dx, axis, boundary_type):
    """Compute 1st derivative with boundary-appropriate scheme"""
    grad = np.zeros_like(f)
    if axis == 0:  # x-derivative
        if boundary_type == 'dirichlet':
            # Central difference in interior
            grad[1:-1, :] = (f[2:, :] - f[:-2, :]) / (2*dx)
            # One-sided at boundaries
            grad[0, :] = (f[1, :] - f[0, :]) / dx
            grad[-1, :] = (f[-1, :] - f[-2, :]) / dx
        else:  # Neumann: assume zero gradient
            grad[1:-1, :] = (f[2:, :] - f[:-2, :]) / (2*dx)
            grad[0, :] = 0  # ∂f/∂x = 0
            grad[-1, :] = 0  # ∂f/∂x = 0
    else:  # y-derivative
        if boundary_type == 'dirichlet':
            grad[:, 1:-1] = (f[:, 2:] - f[:, :-2]) / (2*dx)
            grad[:, 0] = (f[:, 1] - f[:, 0]) / dx
            grad[:, -1] = (f[:, -1] - f[:, -2]) / dx
        else:
            grad[:, 1:-1] = (f[:, 2:] - f[:, :-2]) / (2*dx)
            grad[:, 0] = 0
            grad[:, -1] = 0
    return grad

def build_poisson_matrix(Nx, Ny, dx, dy):
    """Construct sparse Poisson matrix with mixed BCs:
    - Neumann: Left, top, bottom (∂p/∂n=0)
    - Dirichlet: Right (p=0)
    """
    N = Nx * Ny
    A = lil_matrix((N, N))
    dx2, dy2 = dx**2, dy**2
    
    for i in range(Nx):
        for j in range(Ny):
            k = i * Ny + j
            # Right boundary: Dirichlet (p=0)
            if i == Nx-1:
                A[k, k] = 1
            # Left boundary: Neumann (∂p/∂x=0)
            elif i == 0:
                A[k, k] = -2/dx2
                A[k, k + Ny] = 2/dx2  # Mirror point
            # Bottom boundary: Neumann (∂p/∂y=0)
            elif j == 0:
                A[k, k] = -2/dy2
                A[k, k+1] = 2/dy2
            # Top boundary: Neumann (∂p/∂y=0)
            elif j == Ny-1:
                A[k, k] = -2/dy2
                A[k, k-1] = 2/dy2
            # Interior points
            else:
                A[k, k] = -2/dx2 - 2/dy2
                A[k, k - Ny] = 1/dx2  # West
                A[k, k + Ny] = 1/dx2  # East
                A[k, k - 1] = 1/dy2  # South
                A[k, k + 1] = 1/dy2  # North
    return A.tocsr()

# ==============================================================================
# Precompute Poisson Matrix
# ==============================================================================
print("Building Poisson matrix...")
A_poisson = build_poisson_matrix(Nx, Ny, dx, dy)

# ==============================================================================
# Time-Stepping Loop
# ==============================================================================
start_time = time.time()
for step in range(num_steps):
    t = step * dt
    
    # --------------------------------------------------------------------------
    # Step 1: Compute Intermediate Velocity (ignore pressure)
    # --------------------------------------------------------------------------
    # Compute convective terms
    u_x = compute_derivative(u, dx, axis=0, boundary_type='dirichlet')
    u_y = compute_derivative(u, dy, axis=1, boundary_type='dirichlet')
    v_x = compute_derivative(v, dx, axis=0, boundary_type='dirichlet')
    v_y = compute_derivative(v, dy, axis=1, boundary_type='dirichlet')
    conv_u = u*u_x + v*u_y
    conv_v = u*v_x + v*v_y
    
    # Compute viscous terms
    u_xx = compute_derivative(u, dx, axis=0, boundary_type='neumann')
    u_yy = compute_derivative(u, dy, axis=1, boundary_type='neumann')
    v_xx = compute_derivative(v, dx, axis=0, boundary_type='neumann')
    v_yy = compute_derivative(v, dy, axis=1, boundary_type='neumann')
    visc_u = (u_xx + u_yy) / Re
    visc_v = (v_xx + v_yy) / Re
    
    # Compute forcing term
    F = forcing_term(X, Y, t)
    
    # Update intermediate velocity
    u_star = u + dt * (-conv_u + visc_u)
    v_star = v + dt * (-conv_v + visc_v + F)
    
    # Apply BCs to intermediate velocity
    u_star[0, :] = u_inlet(y, t+dt)  # Inlet
    v_star[0, :] = 0
    u_star[-1, :] = u_star[-2, :]    # Outlet (∂u/∂x=0)
    v_star[-1, :] = v_star[-2, :]
    u_star[:, 0] = 0                  # Bottom wall
    u_star[:, -1] = 0                 # Top wall
    v_star[:, 0] = 0
    v_star[:, -1] = 0
    
    # --------------------------------------------------------------------------
    # Step 2: Solve Pressure Poisson Equation
    # --------------------------------------------------------------------------
    div_u = compute_derivative(u_star, dx, axis=0, boundary_type='dirichlet')
    div_v = compute_derivative(v_star, dy, axis=1, boundary_type='dirichlet')
    div = div_u + div_v
    rhs = div.ravel() / dt  # Source term
    
    # Set Dirichlet BC (p=0 at outlet)
    for j in range(Ny):
        idx = (Nx-1)*Ny + j
        rhs[idx] = 0  # Enforce p=0 at x=2
    
    # GMRES solve
    p_flat, info = gmres(A_poisson, rhs, atol=1e-5, maxiter=1000)
    if info != 0:
        print(f"GMRES warning at step {step}: convergence not achieved (info={info})")
    p = p_flat.reshape((Nx, Ny))
    
    # --------------------------------------------------------------------------
    # Step 3: Velocity Correction
    # --------------------------------------------------------------------------
    p_x = compute_derivative(p, dx, axis=0, boundary_type='neumann')
    p_y = compute_derivative(p, dy, axis=1, boundary_type='neumann')
    u = u_star - dt * p_x
    v = v_star - dt * p_y
    
    # Apply final BCs
    u[0, :] = u_inlet(y, t+dt)
    v[0, :] = 0
    u[-1, :] = u[-2, :]
    v[-1, :] = v[-2, :]
    u[:, 0] = 0
    u[:, -1] = 0
    v[:, 0] = 0
    v[:, -1] = 0
    
    # --------------------------------------------------------------------------
    # Progress Monitoring
    # --------------------------------------------------------------------------
    if step % 50 == 0:
        max_div = np.max(np.abs(div))
        print(f"Step {step:4d}, t={t:.3f}, Max div={max_div:.2e}")

# ==============================================================================
# Postprocessing and Visualization
# ==============================================================================
print(f"Simulation completed in {time.time()-start_time:.2f} seconds")

# Plot velocity and pressure at t=0.5
plt.figure(figsize=(18, 6))
plt.suptitle(f"Navier-Stokes Solution at t={T} (Re={Re})", fontsize=16)

# u-velocity
plt.subplot(131)
contour_u = plt.contourf(X, Y, u, levels=50, cmap='jet')
plt.colorbar(contour_u, label='u velocity')
plt.title('u-velocity')
plt.xlabel('x')
plt.ylabel('y')
plt.xlim(0, Lx)
plt.ylim(0, Ly)

# v-velocity
plt.subplot(132)
contour_v = plt.contourf(X, Y, v, levels=50, cmap='jet')
plt.colorbar(contour_v, label='v velocity')
plt.title('v-velocity')
plt.xlabel('x')
plt.ylabel('y')
plt.xlim(0, Lx)
plt.ylim(0, Ly)

# Pressure
plt.subplot(133)
contour_p = plt.contourf(X, Y, p, levels=50, cmap='jet')
plt.colorbar(contour_p, label='Pressure')
plt.title('Pressure')
plt.xlabel('x')
plt.ylabel('y')
plt.xlim(0, Lx)
plt.ylim(0, Ly)

plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.savefig('ns_solution.png', dpi=300)
print("Results saved to ns_solution.png")
```

**Technical Explanation:**
1. **Projection Method:** Decouples velocity and pressure calculations. First computes an intermediate velocity without pressure, then solves a pressure Poisson equation to enforce continuity, and finally corrects the velocity.
2. **Spatial Discretization:** 
   - 2nd-order central differences for interior points
   - 1st-order differences at boundaries
   - Special handling for Neumann (zero-gradient) and Dirichlet boundary conditions
3. **GMRES Solver:** Iterative method for solving the sparse pressure Poisson equation with mixed boundary conditions:
   - Neumann (∂p/∂n=0) on left/top/bottom
   - Dirichlet (p=0) on right boundary
4. **Boundary Conditions:**
   - Inlet: Time-dependent velocity profile
   - Outlet: Zero-gradient velocity, fixed pressure
   - Walls: No-slip (u=v=0)
5. **Stability:** Explicit time stepping with CFL/viscous stability constraints. The time step (dt=0.001) ensures stability for Re=100.

**Output:**
- Contour plots of u, v, and p at t=0.5 saved to `ns_solution.png`
- Real-time monitoring of divergence (continuity error)
- GMRES convergence warnings if iterations fail
- Runtime statistics at completion

The implementation ensures numerical stability and physical accuracy through careful boundary condition enforcement and divergence control. The GMRES solver efficiently handles the pressure Poisson equation with mixed boundary conditions.
****************************************
