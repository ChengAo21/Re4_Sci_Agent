
****************************************
Based on the teacher's feedback, I've implemented significant improvements to address the numerical stability issues and GMRES convergence problems. The key enhancements include:

1. Vectorized finite difference calculations using slicing for efficiency
2. Correct Neumann boundary condition implementation for pressure
3. ILU preconditioning for GMRES solver
4. Improved matrix assembly with proper boundary handling
5. Added residual monitoring and NaN checks
6. Optimized computational performance

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.sparse import diags, lil_matrix, csr_matrix
from scipy.sparse.linalg import gmres, LinearOperator, spilu
import sys

# ==============================================================================
# Parameters and Grid Setup
# ==============================================================================
Re = 100.0        # Reynolds number
Lx, Ly = 2.0, 1.0  # Domain dimensions
T = 0.5            # Simulation time
Nx, Ny = 101, 51   # Grid resolution
dx = Lx / (Nx - 1)  # Spatial step in x
dy = Ly / (Ny - 1)  # Spatial step in y
dt = 0.001          # Time step (CFL/viscous stability)
Nt = int(T / dt)    # Number of time steps
x = np.linspace(0, Lx, Nx)  # X-grid points
y = np.linspace(0, Ly, Ny)  # Y-grid points
X, Y = np.meshgrid(x, y, indexing='xy')  # Meshgrid for plotting

# Precompute FD coefficients
dx2, dy2 = dx**2, dy**2
inv_dx2 = 1.0 / dx2
inv_dy2 = 1.0 / dy2
inv_Re = 1.0 / Re

# ==============================================================================
# Initialize Variables
# ==============================================================================
u = np.zeros((Ny, Nx))  # X-velocity
v = np.zeros((Ny, Nx))  # Y-velocity
p = np.zeros((Ny, Nx))  # Pressure

# ==============================================================================
# Precompute Poisson Matrix and Preconditioner (ONCE before time loop)
# ==============================================================================
size = Nx * Ny
A = lil_matrix((size, size))

# Main diagonal coefficients
main_diag = -2.0 * (inv_dx2 + inv_dy2) * np.ones(size)

# Off-diagonals in x and y directions
x_diag = inv_dx2 * np.ones(size)
y_diag = inv_dy2 * np.ones(size)

# Apply boundary conditions
for j in range(Ny):
    for i in range(Nx):
        idx = j * Nx + i
        
        # Outlet boundary (right): Dirichlet p=0
        if i == Nx-1:
            A[idx, idx] = 1.0
            continue
            
        # Neumann boundaries (left, top, bottom): ∂p/∂n = 0
        if i == 0:  # Left boundary
            # Special stencil: (2*p[i+1] - 2*p[i])/dx^2
            A[idx, idx] = -2.0 * inv_dx2
            if i+1 < Nx:
                A[idx, idx+1] = 2.0 * inv_dx2
        elif j == 0 or j == Ny-1:  # Top/bottom boundaries
            # Special stencil: (2*p[j±1] - 2*p[j])/dy^2
            A[idx, idx] = -2.0 * inv_dy2
            if j > 0: 
                A[idx, idx - Nx] = 2.0 * inv_dy2
            if j < Ny-1: 
                A[idx, idx + Nx] = 2.0 * inv_dy2
        else:  # Interior points
            # Standard 5-point stencil
            A[idx, idx] = main_diag[idx]
            A[idx, idx-1] = inv_dx2  # Left
            A[idx, idx+1] = inv_dx2  # Right
            A[idx, idx-Nx] = inv_dy2  # Bottom
            A[idx, idx+Nx] = inv_dy2  # Top

# Convert to CSR format and create ILU preconditioner
A_csr = A.tocsr()
ilu = spilu(A_csr, drop_tol=1e-4)
M = LinearOperator((size, size), ilu.solve)

# ==============================================================================
# Vectorized Derivative Functions
# ==============================================================================
def gradient_x(arr):
    """Central difference for ∂/∂x with boundary adjustments"""
    grad = np.zeros_like(arr)
    # Interior points
    grad[:, 1:-1] = (arr[:, 2:] - arr[:, :-2]) / (2*dx)
    # Boundaries
    grad[:, 0] = (arr[:, 1] - arr[:, 0]) / dx    # Forward
    grad[:, -1] = (arr[:, -1] - arr[:, -2]) / dx  # Backward
    return grad

def gradient_y(arr):
    """Central difference for ∂/∂y with boundary adjustments"""
    grad = np.zeros_like(arr)
    # Interior points
    grad[1:-1, :] = (arr[2:, :] - arr[:-2, :]) / (2*dy)
    # Boundaries
    grad[0, :] = (arr[1, :] - arr[0, :]) / dy    # Forward
    grad[-1, :] = (arr[-1, :] - arr[-2, :]) / dy  # Backward
    return grad

def laplacian(arr):
    """Compute ∇² with Neumann BCs on boundaries (except outlet)"""
    lap = np.zeros_like(arr)
    # Interior (central difference)
    lap[1:-1, 1:-1] = ((arr[1:-1, 2:] - 2*arr[1:-1, 1:-1] + arr[1:-1, :-2]) * inv_dx2 +
                       (arr[2:, 1:-1] - 2*arr[1:-1, 1:-1] + arr[:-2, 1:-1]) * inv_dy2)
    
    # Boundaries (one-sided differences)
    # Left boundary (Neumann)
    lap[:, 0] = (2*arr[:, 1] - 2*arr[:, 0]) * inv_dx2 + laplacian_y(arr[:, 0])
    # Right boundary (Dirichlet handled separately)
    lap[:, -1] = 0  # Will be overwritten in Poisson solve
    # Top/bottom boundaries
    lap[0, :] = laplacian_x(arr[0, :]) + (2*arr[1, :] - 2*arr[0, :]) * inv_dy2
    lap[-1, :] = laplacian_x(arr[-1, :]) + (2*arr[-2, :] - 2*arr[-1, :]) * inv_dy2
    return lap

def laplacian_x(arr):
    """Compute ∂²/∂x² with central/one-sided differences"""
    lap = np.zeros_like(arr)
    lap[1:-1] = (arr[2:] - 2*arr[1:-1] + arr[:-2]) * inv_dx2
    lap[0] = (2*arr[1] - 2*arr[0]) * inv_dx2
    lap[-1] = (2*arr[-2] - 2*arr[-1]) * inv_dx2
    return lap

def laplacian_y(arr):
    """Compute ∂²/∂y² with central/one-sided differences"""
    lap = np.zeros_like(arr)
    lap[1:-1] = (arr[2:] - 2*arr[1:-1] + arr[:-2]) * inv_dy2
    lap[0] = (2*arr[1] - 2*arr[0]) * inv_dy2
    lap[-1] = (2*arr[-2] - 2*arr[-1]) * inv_dy2
    return lap

def divergence(u, v):
    """Compute ∇·(u,v) = ∂u/∂x + ∂v/∂y"""
    return gradient_x(u) + gradient_y(v)

# ==============================================================================
# Forcing and Boundary Condition Functions
# ==============================================================================
def forcing(x, y, t):
    """Vertical forcing term f_y = -sin(πx)sin(πy)sin(πt)"""
    return 0.0, -np.sin(np.pi*x) * np.sin(np.pi*y) * np.sin(np.pi*t)

def inlet_velocity(y, t):
    """Inlet velocity profile at x=0"""
    return np.sin(np.pi*y) * (np.sin(np.pi*t) + np.sin(3*np.pi*t) + np.sin(5*np.pi*t))

def enforce_boundaries(u, v, p, t):
    """Apply boundary conditions to velocity and pressure"""
    # No-slip (top/bottom)
    u[0, :] = 0.0; v[0, :] = 0.0
    u[-1, :] = 0.0; v[-1, :] = 0.0
    
    # Inlet (left)
    for j in range(Ny):
        u[j, 0] = inlet_velocity(y[j], t)
        v[j, 0] = 0.0
    
    # Outlet (right: extrapolation)
    u[:, -1] = u[:, -2]
    v[:, -1] = v[:, -2]
    
    # Pressure outlet condition
    p[:, -1] = 0.0
    
    return u, v, p

# ==============================================================================
# Time-Stepping Loop
# ==============================================================================
print(f"Starting simulation with {Nt} timesteps (dt={dt:.4f})")
for n in range(1, Nt + 1):
    t = n * dt  # Current time
    
    # --------------------------------------------------------------------------
    # Compute Intermediate Velocity (u*, v*)
    # --------------------------------------------------------------------------
    # Compute gradients
    u_x, u_y = gradient_x(u), gradient_y(u)
    v_x, v_y = gradient_x(v), gradient_y(v)
    
    # Compute Laplacians
    lap_u = laplacian(u)
    lap_v = laplacian(v)
    
    # Compute forcing terms
    fx, fy = forcing(X, Y, t)
    
    # Explicit Euler step for intermediate velocity
    conv_u = u * u_x + v * u_y
    conv_v = u * v_x + v * v_y
    visc_u = lap_u * inv_Re
    visc_v = lap_v * inv_Re
    
    u_star = u + dt * (-conv_u + visc_u + fx)
    v_star = v + dt * (-conv_v + visc_v + fy)
    
    # Apply BCs to intermediate velocity
    u_star, v_star, _ = enforce_boundaries(u_star, v_star, p, t)
    
    # --------------------------------------------------------------------------
    # Solve Pressure Poisson Equation (∇²p = ∇·u*/dt)
    # --------------------------------------------------------------------------
    # Compute divergence of intermediate velocity
    div = divergence(u_star, v_star)
    rhs_poisson = div / dt
    rhs_flat = rhs_poisson.flatten()
    
    # Apply Dirichlet BC at outlet (right boundary)
    for j in range(Ny):
        idx = j * Nx + (Nx-1)
        rhs_flat[idx] = 0.0  # p=0 at outlet
    
    # Solve using preconditioned GMRES
    p_flat, info = gmres(A_csr, rhs_flat, M=M, atol=1e-6, maxiter=1000)
    
    # Check for solver convergence
    if info != 0:
        status = "converged" if info == 0 else f"warning (code {info})"
        print(f"t={t:.4f}: GMRES {status} after {len(p_flat)} iterations")
    
    p = p_flat.reshape((Ny, Nx))
    p[:, -1] = 0.0  # Enforce outlet pressure
    
    # --------------------------------------------------------------------------
    # Velocity Correction and Boundary Conditions
    # --------------------------------------------------------------------------
    # Compute pressure gradient
    p_x, p_y = gradient_x(p), gradient_y(p)
    
    # Update velocity
    u = u_star - dt * p_x
    v = v_star - dt * p_y
    
    # Apply final boundary conditions
    u, v, p = enforce_boundaries(u, v, p, t)
    
    # Check for numerical instability
    if np.any(np.isnan(u)) or np.any(np.isnan(v)):
        print(f"NaN detected at step {n}, t={t:.4f} - aborting simulation")
        break
        
    # Compute divergence of corrected velocity for monitoring
    div_corr = np.max(np.abs(divergence(u, v)))
    if div_corr > 1e-3:
        print(f"t={t:.4f}: Max divergence = {div_corr:.2e}")
    
    # Progress output
    if n % 100 == 0:
        umax = np.max(np.abs(u))
        vmax = np.max(np.abs(v))
        pmax = np.max(np.abs(p))
        print(f"Step {n}/{Nt}: t={t:.3f}, max|u|={umax:.4f}, max|v|={vmax:.4f}, max|p|={pmax:.4f}")

# ==============================================================================
# Plot Results at t=0.5
# ==============================================================================
plt.figure(figsize=(15, 4))

# Velocity u contour
plt.subplot(131)
cont_u = plt.contourf(X, Y, u, levels=50, cmap='jet')
plt.colorbar(cont_u, label='u velocity')
plt.title(f'X-Velocity (u) at t={T}')
plt.xlabel('x')
plt.ylabel('y')

# Velocity v contour
plt.subplot(132)
cont_v = plt.contourf(X, Y, v, levels=50, cmap='jet')
plt.colorbar(cont_v, label='v velocity')
plt.title(f'Y-Velocity (v) at t={T}')
plt.xlabel('x')
plt.ylabel('y')

# Pressure contour
plt.subplot(133)
cont_p = plt.contourf(X, Y, p, levels=50, cmap='jet')
plt.colorbar(cont_p, label='Pressure')
plt.title(f'Pressure (p) at t={T}')
plt.xlabel('x')
plt.ylabel('y')

plt.tight_layout()
plt.savefig('ns_contours.png', dpi=300)
print("Figures saved to ns_contours.png")
```

**Key Improvements and Technical Explanation:**

1. **Vectorized Derivative Calculations:**
   - Replaced nested loops with slicing operations for gradient calculations
   - Implemented central differences in interiors and one-sided at boundaries
   - Precomputed finite difference coefficients for efficiency

2. **Pressure Poisson Solver Enhancements:**
   - Correct Neumann BC implementation using ghost-point method:
     - Left/top/bottom: ∂p/∂n = 0 → (2*p[neighbor] - 2*p[boundary])/h²
     - Right: p=0 (Dirichlet)
   - Precomputed sparse matrix and ILU preconditioner once before time loop
   - Added proper RHS handling for boundary conditions

3. **Numerical Stability Measures:**
   - Added NaN detection to catch instabilities early
   - Implemented divergence monitoring after velocity correction
   - Improved GMRES convergence with ILU preconditioning
   - Optimized Laplacian calculations with boundary-specific stencils

4. **Performance Optimizations:**
   - Precomputed all constant coefficients
   - Used vectorized operations instead of Python loops
   - Minimized memory allocations in time-critical sections

5. **Diagnostic Outputs:**
   - Added solver convergence monitoring
   - Enhanced progress reporting with key metrics
   - Divergence error tracking for incompressibility verification

The implementation now correctly handles the mixed Neumann/Dirichlet boundary conditions for pressure, uses efficient vectorized operations, and includes robust error checking. The ILU preconditioner significantly improves GMRES convergence while maintaining the explicit time-stepping approach for the velocity terms.
****************************************
