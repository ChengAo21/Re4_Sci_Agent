
****************************************
```python
import numpy as np
import matplotlib.pyplot as plt

# Technical explanation:
# We solve the linear system H_n x = b where H_n is the Hilbert matrix of size n,
# and b is chosen so that the exact solution x = (1,1,...,1)^T.
# We implement three direct methods from scratch:
# 1) LU decomposition with partial pivoting,
# 2) Cholesky decomposition (exploiting symmetry and positive definiteness),
# 3) QR decomposition via Householder reflections.
#
# For each method and each n in the specified range, we compute the numerical solution,
# then calculate the infinity norm error compared to the exact solution.
# Finally, we plot the error trends to compare the methods' accuracy and stability.

def hilbert_matrix(n):
    # Construct the n x n Hilbert matrix H_n with entries h_ij = 1/(i+j-1)
    i = np.arange(1, n+1)
    j = np.arange(1, n+1)
    H = 1.0 / (i[:, None] + j[None, :] - 1)
    return H

def forward_substitution(L, b):
    # Solve L y = b for y, where L is lower triangular with unit or non-unit diagonal
    n = L.shape[0]
    y = np.zeros_like(b, dtype=np.float64)
    for i in range(n):
        y[i] = b[i] - L[i, :i] @ y[:i]
        if abs(L[i,i]) < 1e-15:
            raise np.linalg.LinAlgError("Zero diagonal element in forward substitution")
        y[i] /= L[i,i]
    return y

def backward_substitution(U, y):
    # Solve U x = y for x, where U is upper triangular
    n = U.shape[0]
    x = np.zeros_like(y, dtype=np.float64)
    for i in reversed(range(n)):
        x[i] = y[i] - U[i, i+1:] @ x[i+1:]
        if abs(U[i,i]) < 1e-15:
            raise np.linalg.LinAlgError("Zero diagonal element in backward substitution")
        x[i] /= U[i,i]
    return x

def lu_decomposition_partial_pivoting(A):
    # LU decomposition with partial pivoting: PA = LU
    # Returns P (permutation matrix), L (lower triangular with unit diagonal), U (upper triangular)
    n = A.shape[0]
    U = A.copy().astype(np.float64)
    L = np.eye(n, dtype=np.float64)
    P = np.eye(n, dtype=np.float64)
    
    for k in range(n-1):
        # Partial pivoting: find pivot row
        pivot_row = np.argmax(np.abs(U[k:, k])) + k
        if abs(U[pivot_row, k]) < 1e-15:
            raise np.linalg.LinAlgError("Matrix is singular to working precision.")
        if pivot_row != k:
            # Swap rows in U
            U[[k, pivot_row], :] = U[[pivot_row, k], :]
            # Swap rows in P
            P[[k, pivot_row], :] = P[[pivot_row, k], :]
            if k > 0:
                # Swap rows in L for columns before k
                L[[k, pivot_row], :k] = L[[pivot_row, k], :k]
        # Elimination
        for i in range(k+1, n):
            L[i,k] = U[i,k] / U[k,k]
            U[i,k:] = U[i,k:] - L[i,k]*U[k,k:]
            U[i,k] = 0.0  # Explicitly zero out for numerical stability
    return P, L, U

def solve_lu(A, b):
    # Solve Ax = b using LU decomposition with partial pivoting from scratch
    P, L, U = lu_decomposition_partial_pivoting(A)
    Pb = P @ b
    y = forward_substitution(L, Pb)
    x = backward_substitution(U, y)
    return x

def cholesky_decomposition(A):
    # Cholesky decomposition: A = L L^T for symmetric positive definite A
    n = A.shape[0]
    L = np.zeros_like(A, dtype=np.float64)
    for i in range(n):
        for j in range(i+1):
            s = A[i,j] - L[i,:j] @ L[j,:j].T
            if i == j:
                if s <= 0:
                    raise np.linalg.LinAlgError("Matrix is not positive definite.")
                L[i,j] = np.sqrt(s)
            else:
                L[i,j] = s / L[j,j]
    return L

def solve_cholesky(A, b):
    # Solve Ax = b using Cholesky decomposition from scratch
    L = cholesky_decomposition(A)
    y = forward_substitution(L, b)
    x = backward_substitution(L.T, y)
    return x

def householder_reflection(a):
    # Compute Householder vector for vector a to zero out all but first component
    v = a.copy()
    sigma = np.linalg.norm(a)
    if sigma == 0:
        beta = 0
        v[0] = 1
    else:
        if a[0] >= 0:
            sigma = -sigma
        v[0] = v[0] - sigma
        beta = 2 / (v @ v)
    return v, beta, sigma

def qr_decomposition_householder(A):
    # QR decomposition using Householder reflections: A = Q R
    n, m = A.shape
    R = A.copy().astype(np.float64)
    Q = np.eye(n, dtype=np.float64)
    for k in range(min(n, m)):
        x = R[k:, k]
        v, beta, sigma = householder_reflection(x)
        if beta == 0:
            continue
        # Apply reflection to R
        R[k:, k:] -= beta * np.outer(v, v @ R[k:, k:])
        # Apply reflection to Q
        Q[:, k:] -= beta * np.outer(Q[:, k:] @ v, v)
    return Q, R

def solve_qr(A, b):
    # Solve Ax = b using QR decomposition via Householder reflections from scratch
    Q, R = qr_decomposition_householder(A)
    Qt_b = Q.T @ b
    x = backward_substitution(R[:A.shape[1], :], Qt_b[:A.shape[1]])
    return x

def infinity_norm_error(x_computed, x_exact):
    # Compute infinity norm error ||x_computed - x_exact||_∞
    return np.max(np.abs(x_computed - x_exact))

def run_experiments(ns):
    # Run all methods for each n in ns, collect infinity norm errors
    errors_lu = []
    errors_cholesky = []
    errors_qr = []
    
    for n in ns:
        H = hilbert_matrix(n)
        x_exact = np.ones(n)
        b = H @ x_exact
        
        # LU with partial pivoting
        try:
            x_lu = solve_lu(H, b)
            err_lu = infinity_norm_error(x_lu, x_exact)
        except Exception as e:
            err_lu = np.nan
            print(f"LU failed for n={n}: {e}")
        
        # Cholesky decomposition
        try:
            x_chol = solve_cholesky(H, b)
            err_chol = infinity_norm_error(x_chol, x_exact)
        except Exception as e:
            err_chol = np.nan
            print(f"Cholesky failed for n={n}: {e}")
        
        # QR decomposition via Householder
        try:
            x_qr = solve_qr(H, b)
            err_qr = infinity_norm_error(x_qr, x_exact)
        except Exception as e:
            err_qr = np.nan
            print(f"QR failed for n={n}: {e}")
        
        errors_lu.append(err_lu)
        errors_cholesky.append(err_chol)
        errors_qr.append(err_qr)
        
        # Detailed result printing for current n
        print(f"n = {n}")
        print(f"  LU with partial pivoting error (L∞): {err_lu:.3e}")
        print(f"  Cholesky decomposition error (L∞): {err_chol:.3e}")
        print(f"  QR decomposition (Householder) error (L∞): {err_qr:.3e}")
        print("-"*50)
    
    return errors_lu, errors_cholesky, errors_qr

def plot_errors(ns, errors_lu, errors_chol, errors_qr):
    # Plot infinity norm errors vs n for each method
    plt.figure(figsize=(10,6))
    plt.semilogy(ns, errors_lu, 'o-', label='LU with Partial Pivoting')
    plt.semilogy(ns, errors_chol, 's-', label='Cholesky Decomposition')
    plt.semilogy(ns, errors_qr, '^-', label='QR Decomposition (Householder)')
    plt.xlabel('Matrix size n')
    plt.ylabel('Infinity norm error')
    plt.title('Infinity Norm Error of Numerical Solutions for Hilbert Systems')
    plt.legend()
    plt.grid(True, which='both', linestyle='--', linewidth=0.7)
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    ns = list(range(5, 51, 5))  # n = 5, 10, ..., 50
    errors_lu, errors_chol, errors_qr = run_experiments(ns)
    plot_errors(ns, errors_lu, errors_chol, errors_qr)
```

****************************************
