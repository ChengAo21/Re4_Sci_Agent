
****************************************
```python
import numpy as np
import scipy.linalg
import matplotlib.pyplot as plt

# Technical explanation:
# The Hilbert matrix H_n is symmetric positive definite (SPD) but extremely ill-conditioned for large n.
# We solve H_n x = b where x = (1,1,...,1)^T exactly, so b = H_n @ x.
# We implement three direct methods:
# 1) LU factorization with scaled partial pivoting (improves numerical stability over simple partial pivoting)
# 2) Cholesky factorization with a small diagonal regularization to ensure numerical positive definiteness
# 3) Baseline: numpy.linalg.solve (built-in solver)
# Additionally, we implement an SVD-based solver to provide a numerically stable solution for comparison.
# We compute the infinity norm error ||x_hat - x||_∞ for each method and n.
# Finally, we plot the error growth vs n and the condition number growth to observe the effect of ill-conditioning.

def hilbert_matrix(n):
    # Construct Hilbert matrix H_n of size n x n
    i = np.arange(1, n+1)
    j = i.reshape(-1, 1)
    H = 1.0 / (i + j - 1)
    return H

def forward_substitution(L, b):
    # Solve L y = b for y, L lower triangular
    n = L.shape[0]
    y = np.zeros_like(b, dtype=np.float64)
    for i in range(n):
        y[i] = b[i] - L[i, :i] @ y[:i]
        y[i] /= L[i, i]
    return y

def backward_substitution(U, y):
    # Solve U x = y for x, U upper triangular
    n = U.shape[0]
    x = np.zeros_like(y, dtype=np.float64)
    for i in reversed(range(n)):
        x[i] = y[i] - U[i, i+1:] @ x[i+1:]
        x[i] /= U[i, i]
    return x

def lu_factorization_scaled_pivoting(A):
    # LU factorization with scaled partial pivoting from scratch
    # A is n x n matrix
    n = A.shape[0]
    U = A.copy().astype(np.float64)
    L = np.eye(n, dtype=np.float64)
    P = np.eye(n, dtype=np.float64)

    # Compute scale factors for each row (max absolute value in the row)
    scale = np.max(np.abs(U), axis=1)
    if np.any(scale == 0):
        raise ValueError("Zero row detected in matrix.")

    for k in range(n-1):
        # Determine pivot row using scaled partial pivoting
        ratios = np.abs(U[k:n, k]) / scale[k:n]
        pivot_index = np.argmax(ratios) + k
        if pivot_index != k:
            # Swap rows in U
            U[[k, pivot_index], :] = U[[pivot_index, k], :]
            # Swap rows in P
            P[[k, pivot_index], :] = P[[pivot_index, k], :]
            # Swap rows in L for columns before k
            if k > 0:
                L[[k, pivot_index], :k] = L[[pivot_index, k], :k]
            # Swap scale factors
            scale[k], scale[pivot_index] = scale[pivot_index], scale[k]

        # Elimination
        if np.abs(U[k, k]) < 1e-15:
            raise ValueError("Zero (or near-zero) pivot encountered during LU factorization.")
        for i in range(k+1, n):
            L[i, k] = U[i, k] / U[k, k]
            U[i, k:] = U[i, k:] - L[i, k] * U[k, k:]
            U[i, k] = 0.0  # Explicitly zero for numerical stability

    return P, L, U

def solve_lu(P, L, U, b):
    # Solve Ax = b given LU factorization with permutation P
    # PA = LU => A = P^T LU
    # Solve Ly = Pb
    Pb = P @ b
    y = forward_substitution(L, Pb)
    x = backward_substitution(U, y)
    return x

def cholesky_factorization_regularized(A, epsilon=1e-14):
    # Cholesky factorization A = L L^T for SPD matrix A with diagonal regularization
    # Add small regularization to diagonal to improve numerical stability
    A_reg = A + epsilon * np.eye(A.shape[0])
    n = A_reg.shape[0]
    L = np.zeros_like(A_reg, dtype=np.float64)
    for i in range(n):
        for j in range(i+1):
            s = A_reg[i, j] - L[i, :j] @ L[j, :j]
            if i == j:
                if s <= 0:
                    raise ValueError("Matrix not positive definite (numerical issue in Cholesky).")
                L[i, j] = np.sqrt(s)
            else:
                L[i, j] = s / L[j, j]
    return L

def solve_cholesky(L, b):
    # Solve Ax = b given Cholesky factor L (A=LL^T)
    y = forward_substitution(L, b)
    x = backward_substitution(L.T, y)
    return x

def solve_svd(A, b, tol=1e-14):
    # Solve Ax = b using SVD pseudoinverse for numerical stability
    U, s, VT = np.linalg.svd(A)
    # Invert singular values with tolerance to avoid division by zero
    s_inv = np.array([1/si if si > tol else 0.0 for si in s])
    A_pinv = (VT.T * s_inv) @ U.T
    x = A_pinv @ b
    return x

def compute_error(x_hat, x_exact):
    # Compute infinity norm error ||x_hat - x_exact||_∞
    return np.max(np.abs(x_hat - x_exact))

def plot_errors(ns, errors_dict):
    # Plot errors vs n on log scale
    plt.figure(figsize=(10, 6))
    for label, errors in errors_dict.items():
        plt.plot(ns, errors, marker='o', label=label)
    plt.yscale('log')
    plt.xlabel('Matrix size n')
    plt.ylabel(r'$L_\infty$ error')
    plt.title('Infinity norm error of solution methods for Hilbert system')
    plt.grid(True, which='both', ls='--')
    plt.legend()
    plt.tight_layout()
    plt.show()

def plot_condition_numbers(ns, cond_numbers):
    # Plot condition number growth on log scale
    plt.figure(figsize=(10, 6))
    plt.plot(ns, cond_numbers, 'r-o')
    plt.yscale('log')
    plt.xlabel('Matrix size n')
    plt.ylabel('Condition number of Hilbert matrix')
    plt.title('Condition number growth of Hilbert matrix H_n')
    plt.grid(True, which='both', ls='--')
    plt.tight_layout()
    plt.show()

def main():
    ns = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
    error_lu = []
    error_cholesky = []
    error_numpy = []
    error_svd = []
    cond_numbers = []

    for n in ns:
        H = hilbert_matrix(n)
        x_exact = np.ones(n)
        b = H @ x_exact

        # Condition number (2-norm)
        cond = np.linalg.cond(H)
        cond_numbers.append(cond)

        # --- LU factorization with scaled partial pivoting ---
        try:
            P, L, U = lu_factorization_scaled_pivoting(H)
            x_lu = solve_lu(P, L, U, b)
            err_lu = compute_error(x_lu, x_exact)
        except Exception as e:
            err_lu = np.nan
            print(f"LU failed for n={n}: {e}")

        # --- Cholesky factorization with regularization ---
        try:
            L_chol = cholesky_factorization_regularized(H, epsilon=1e-14)
            x_chol = solve_cholesky(L_chol, b)
            err_chol = compute_error(x_chol, x_exact)
        except Exception as e:
            err_chol = np.nan
            print(f"Cholesky failed for n={n}: {e}")

        # --- numpy.linalg.solve baseline ---
        try:
            x_np = np.linalg.solve(H, b)
            err_np = compute_error(x_np, x_exact)
        except Exception as e:
            err_np = np.nan
            print(f"numpy.linalg.solve failed for n={n}: {e}")

        # --- SVD-based solver for numerical stability ---
        try:
            x_svd = solve_svd(H, b)
            err_svd = compute_error(x_svd, x_exact)
        except Exception as e:
            err_svd = np.nan
            print(f"SVD solver failed for n={n}: {e}")

        error_lu.append(err_lu)
        error_cholesky.append(err_chol)
        error_numpy.append(err_np)
        error_svd.append(err_svd)

        # Detailed result printing
        print(f"n = {n}")
        print(f"Condition number of H_n: {cond:.3e}")
        print(f"LU error (L∞ norm): {err_lu:.3e}")
        print(f"Cholesky error (L∞ norm): {err_chol:.3e}")
        print(f"numpy.linalg.solve error (L∞ norm): {err_np:.3e}")
        print(f"SVD-based solver error (L∞ norm): {err_svd:.3e}")
        print("-" * 50)

    # Plotting errors vs n
    errors_dict = {
        'LU factorization (scaled pivoting)': error_lu,
        'Cholesky factorization (regularized)': error_cholesky,
        'numpy.linalg.solve': error_numpy,
        'SVD-based solver': error_svd
    }
    plot_errors(ns, errors_dict)

    # Plot condition number growth
    plot_condition_numbers(ns, cond_numbers)

if __name__ == "__main__":
    main()
```

****************************************
