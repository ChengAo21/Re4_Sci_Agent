
****************************************
```python
import numpy as np
import scipy.linalg
import matplotlib.pyplot as plt

# Technical explanation:
# The Hilbert matrix H_n is symmetric positive definite but extremely ill-conditioned for large n.
# We solve H_n x = b where x = (1,1,...,1)^T exactly, so b = H_n @ x.
# We implement three direct methods from scratch:
# 1) Gaussian elimination with partial pivoting (LU factorization)
# 2) Cholesky decomposition (since H_n is SPD)
# 3) Baseline: numpy.linalg.solve (built-in solver)
# 
# For LU and Cholesky, we implement the factorization and forward/backward substitution manually.
# We compute the infinity norm error ||x_hat - x||_∞ for each method and n.
# Finally, we plot the error growth vs n to observe the effect of ill-conditioning.

def hilbert_matrix(n):
    # Construct Hilbert matrix H_n of size n x n
    i = np.arange(1, n+1)
    j = i.reshape(-1,1)
    H = 1.0 / (i + j - 1)
    return H

def forward_substitution(L, b):
    # Solve L y = b for y, L lower triangular
    n = L.shape[0]
    y = np.zeros_like(b, dtype=np.float64)
    for i in range(n):
        y[i] = b[i] - L[i,:i] @ y[:i]
        y[i] /= L[i,i]
    return y

def backward_substitution(U, y):
    # Solve U x = y for x, U upper triangular
    n = U.shape[0]
    x = np.zeros_like(y, dtype=np.float64)
    for i in reversed(range(n)):
        x[i] = y[i] - U[i,i+1:] @ x[i+1:]
        x[i] /= U[i,i]
    return x

def lu_factorization(A):
    # LU factorization with partial pivoting from scratch
    # A is n x n matrix
    n = A.shape[0]
    U = A.copy().astype(np.float64)
    L = np.eye(n, dtype=np.float64)
    P = np.eye(n, dtype=np.float64)
    for k in range(n-1):
        # Partial pivoting
        pivot_row = np.argmax(np.abs(U[k:n,k])) + k
        if pivot_row != k:
            # Swap rows in U
            U[[k,pivot_row], :] = U[[pivot_row,k], :]
            # Swap rows in P
            P[[k,pivot_row], :] = P[[pivot_row,k], :]
            if k > 0:
                # Swap rows in L for columns before k
                L[[k,pivot_row], :k] = L[[pivot_row,k], :k]
        # Elimination
        for i in range(k+1, n):
            if U[k,k] == 0:
                raise ValueError("Zero pivot encountered.")
            L[i,k] = U[i,k] / U[k,k]
            U[i,k:] = U[i,k:] - L[i,k]*U[k,k:]
            U[i,k] = 0.0  # Explicitly zero for numerical stability
    return P, L, U

def solve_lu(P, L, U, b):
    # Solve Ax = b given LU factorization with permutation P
    # PA = LU => A = P^T LU
    # Solve Ly = Pb
    Pb = P @ b
    y = forward_substitution(L, Pb)
    x = backward_substitution(U, y)
    return x

def cholesky_factorization(A):
    # Cholesky factorization A = L L^T for SPD matrix A
    n = A.shape[0]
    L = np.zeros_like(A, dtype=np.float64)
    for i in range(n):
        for j in range(i+1):
            s = A[i,j] - L[i,:j] @ L[j,:j]
            if i == j:
                if s <= 0:
                    raise ValueError("Matrix not positive definite.")
                L[i,j] = np.sqrt(s)
            else:
                L[i,j] = s / L[j,j]
    return L

def solve_cholesky(L, b):
    # Solve Ax = b given Cholesky factor L (A=LL^T)
    y = forward_substitution(L, b)
    x = backward_substitution(L.T, y)
    return x

def compute_error(x_hat, x_exact):
    # Compute infinity norm error ||x_hat - x_exact||_∞
    return np.max(np.abs(x_hat - x_exact))

def main():
    ns = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50]
    error_lu = []
    error_cholesky = []
    error_numpy = []
    cond_numbers = []

    for n in ns:
        H = hilbert_matrix(n)
        x_exact = np.ones(n)
        b = H @ x_exact

        # Condition number (2-norm)
        cond = np.linalg.cond(H)
        cond_numbers.append(cond)

        # --- LU factorization with partial pivoting ---
        try:
            P, L, U = lu_factorization(H)
            x_lu = solve_lu(P, L, U, b)
            err_lu = compute_error(x_lu, x_exact)
        except Exception as e:
            err_lu = np.nan
            print(f"LU failed for n={n}: {e}")

        # --- Cholesky factorization ---
        try:
            L_chol = cholesky_factorization(H)
            x_chol = solve_cholesky(L_chol, b)
            err_chol = compute_error(x_chol, x_exact)
        except Exception as e:
            err_chol = np.nan
            print(f"Cholesky failed for n={n}: {e}")

        # --- numpy.linalg.solve baseline ---
        try:
            x_np = np.linalg.solve(H, b)
            err_np = compute_error(x_np, x_exact)
        except Exception as e:
            err_np = np.nan
            print(f"numpy.linalg.solve failed for n={n}: {e}")

        error_lu.append(err_lu)
        error_cholesky.append(err_chol)
        error_numpy.append(err_np)

        # Detailed result printing
        print(f"n = {n}")
        print(f"Condition number of H_n: {cond:.3e}")
        print(f"LU error (L∞ norm): {err_lu:.3e}")
        print(f"Cholesky error (L∞ norm): {err_chol:.3e}")
        print(f"numpy.linalg.solve error (L∞ norm): {err_np:.3e}")
        print("-"*50)

    # Plotting errors vs n
    plt.figure(figsize=(10,6))
    plt.plot(ns, error_lu, 'o-', label='LU factorization')
    plt.plot(ns, error_cholesky, 's-', label='Cholesky factorization')
    plt.plot(ns, error_numpy, '^-', label='numpy.linalg.solve')
    plt.yscale('log')
    plt.xlabel('Matrix size n')
    plt.ylabel(r'$L_\infty$ error')
    plt.title('Infinity norm error of solution methods for Hilbert system')
    plt.grid(True, which='both', ls='--')
    plt.legend()
    plt.tight_layout()
    plt.show()

    # Plot condition number growth
    plt.figure(figsize=(10,6))
    plt.plot(ns, cond_numbers, 'r-o')
    plt.yscale('log')
    plt.xlabel('Matrix size n')
    plt.ylabel('Condition number of Hilbert matrix')
    plt.title('Condition number growth of Hilbert matrix H_n')
    plt.grid(True, which='both', ls='--')
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()
```

****************************************
