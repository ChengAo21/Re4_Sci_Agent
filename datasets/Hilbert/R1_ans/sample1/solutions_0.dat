
****************************************
To solve the Hilbert matrix system \(H_n x = b\) with the exact solution \(x = (1, 1, \ldots, 1)^T\), we implement three numerical methods from scratch: LU decomposition with partial pivoting, Cholesky decomposition (exploiting symmetry), and QR decomposition via Householder reflections. The \(L_\infty\) error is computed for each method across increasing matrix sizes \(n = 5, 10, \ldots, 50\).

### Technical Approach:
1. **Hilbert Matrix Construction**: \(H_n\) is formed with entries \(h_{ij} = 1/(i + j - 1)\) using 0-based indexing.
2. **Vector Initialization**: \(b = H_n \times \mathbf{1}\) ensures the exact solution is \(\mathbf{1}\).
3. **Numerical Methods**:
   - **LU with Partial Pivoting**: Decomposes \(H_n = PLU\), solves via forward/backward substitution with permutation.
   - **Cholesky Decomposition**: For symmetric positive definite \(H_n\), computes \(H_n = LL^T\), solves via forward/backward substitution.
   - **QR via Householder**: Orthogonal factorization \(H_n = QR\), applies reflectors to \(b\), solves \(Rx = Q^Tb\).
4. **Error Calculation**: \(L_\infty\) error \(\|x_{\text{computed}} - \mathbf{1}\|_\infty\) is evaluated.

### Code Implementation:
```python
import numpy as np
import matplotlib.pyplot as plt

# Forward substitution for unit lower triangular matrix (used in LU)
def forward_substitution_unit(L, b):
    n = L.shape[0]
    x = np.zeros(n)
    for i in range(n):
        x[i] = b[i] - L[i, :i] @ x[:i]
    return x

# Forward substitution for lower triangular matrix (used in Cholesky)
def forward_substitution(L, b):
    n = L.shape[0]
    x = np.zeros(n)
    for i in range(n):
        x[i] = (b[i] - L[i, :i] @ x[:i]) / L[i, i]
    return x

# Back substitution for upper triangular matrix
def back_substitution(U, b):
    n = U.shape[0]
    x = np.zeros(n)
    for i in range(n-1, -1, -1):
        x[i] = (b[i] - U[i, i+1:] @ x[i+1:]) / U[i, i]
    return x

# LU decomposition with partial pivoting
def lu_decomposition(A):
    n = A.shape[0]
    U = A.copy()
    L = np.eye(n)
    p = np.arange(n)
    for k in range(n-1):
        idx = np.argmax(np.abs(U[k:, k])) + k
        if idx != k:
            U[[k, idx], k:] = U[[idx, k], k:]
            if k > 0:
                L[[k, idx], :k] = L[[idx, k], :k]
            p[[k, idx]] = p[[idx, k]]
        for i in range(k+1, n):
            L[i, k] = U[i, k] / U[k, k]
            U[i, k:] = U[i, k:] - L[i, k] * U[k, k:]
    return L, U, p

# Cholesky decomposition for symmetric positive definite matrices
def cholesky_decomposition(A):
    n = A.shape[0]
    L = np.zeros((n, n))
    for i in range(n):
        for j in range(i+1):
            s = A[i, j] - L[i, :j] @ L[j, :j]
            if i == j:
                L[i, j] = np.sqrt(s)
            else:
                L[i, j] = s / L[j, j]
    return L

# QR decomposition via Householder reflections and system solving
def householder_qr_solve(A, b):
    n = A.shape[0]
    R = A.copy()
    b = b.copy()
    V = []
    for k in range(n-1):
        x = R[k:, k]
        norm_x = np.linalg.norm(x)
        if norm_x == 0:
            continue
        sgn = 1 if x[0] >= 0 else -1
        u = x.copy()
        u[0] += sgn * norm_x
        norm_u_sq = u @ u
        if norm_u_sq < 1e-15:
            continue
        beta = 2.0 / norm_u_sq
        w = beta * (u @ R[k:, k:])
        R[k:, k:] -= np.outer(u, w)
        V.append(u)
    for k in range(len(V)):
        u = V[k]
        beta = 2.0 / (u @ u)
        w = beta * (u @ b[k:])
        b[k:] -= w * u
    x = back_substitution(R[:n, :n], b[:n])
    return x

# Main analysis for n = 5, 10, ..., 50
ns = np.arange(5, 51, 5)
errors_lu, errors_chol, errors_qr = [], [], []

for n in ns:
    # Construct Hilbert matrix H
    H = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            H[i, j] = 1.0 / (i + j + 1)
    x_exact = np.ones(n)
    b = H @ x_exact
    
    # Solve with LU decomposition
    L, U, p = lu_decomposition(H)
    b_perm = b[p]
    y = forward_substitution_unit(L, b_perm)
    x_lu = back_substitution(U, y)
    errors_lu.append(np.max(np.abs(x_lu - x_exact)))
    
    # Solve with Cholesky decomposition (handle failure for large n)
    try:
        L_chol = cholesky_decomposition(H)
        y = forward_substitution(L_chol, b)
        x_chol = back_substitution(L_chol.T, y)
        errors_chol.append(np.max(np.abs(x_chol - x_exact)))
    except:
        errors_chol.append(np.nan)
    
    # Solve with QR decomposition
    x_qr = householder_qr_solve(H, b)
    errors_qr.append(np.max(np.abs(x_qr - x_exact)))

# Plot results
plt.figure(figsize=(10, 6))
plt.plot(ns, errors_lu, 'o-', label='LU Decomposition')
plt.plot(ns, errors_chol, 's-', label='Cholesky Decomposition')
plt.plot(ns, errors_qr, 'd-', label='QR Decomposition')
plt.yscale('log')
plt.xlabel('Matrix Size (n)')
plt.ylabel('$L_\infty$ Error')
plt.title('Error Comparison for Hilbert Matrix Solvers')
plt.legend()
plt.grid(True, which="both", ls="-"))
plt.show()
```

### Explanation:
1. **Matrix Construction**: Hilbert matrix \(H_n\) is built using nested loops for given \(n\).
2. **LU Decomposition**:
   - Partial pivoting handles ill-conditioning by row swaps.
   - Forward/backward substitution solve permuted system \(Ly = Pb\), \(Ux = y\).
3. **Cholesky Decomposition**:
   - Exploits symmetry with \(H_n = LL^T\).
   - Forward substitution solves \(Ly = b\), backward solves \(L^Tx = y\).
4. **QR Decomposition**:
   - Householder reflectors orthogonalize \(H_n\) into \(QR\).
   - Reflectors transform \(b\) to \(Q^Tb\), followed by solving \(Rx = Q^Tb\).
5. **Error Analysis**: \(L_\infty\) error is computed as the maximum deviation from the exact solution \(\mathbf{1}\).
6. **Visualization**: Errors are plotted on a log scale to compare method stability across \(n\).

This implementation provides a clear comparison of numerical stability, with QR decomposition generally offering superior accuracy for ill-conditioned Hilbert matrices.
****************************************
